commit c5e8e83249c32811b4b490d933f97bd457dc22c2
Author: StyriamMZ <styriam@o2.pl>
Date:   Tue Nov 10 22:01:51 2020 +0100

    2.7.0

diff --git a/__init__.py b/__init__.py
index 07da0d6..a428d39 100644
--- a/__init__.py
+++ b/__init__.py
@@ -11,7 +11,7 @@ bl_info = {
     "category": "User Interface" }
     
     
-import bpy      
+import bpy
 
 # load and reload submodules
 ##################################    
diff --git a/operators/modal.py b/operators/modal.py
index f6fc32e..19e78c1 100644
--- a/operators/modal.py
+++ b/operators/modal.py
@@ -52,11 +52,11 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
     def invoke(self, context, event):
         global running_modals
         context.active_object.select_set(True)
-        if LightImage.selected_object is None:
-            idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
-            LightImage.selected_object = LightImage.lights[idx]
 
         if running_modals:
+            if LightImage.selected_object is None:
+                idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
+                LightImage.selected_object = LightImage.lights[idx]
             active_object = LightImage.selected_object
             self.mouse_x=active_object.loc.x
             self.mouse_y=active_object.loc.y
@@ -134,11 +134,11 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
     def invoke(self, context, event):
         global running_modals
         context.active_object.select_set(True)
-        if LightImage.selected_object is None:
-            idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
-            LightImage.selected_object = LightImage.lights[idx]
 
         if running_modals:
+            if LightImage.selected_object is None:
+                idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
+                LightImage.selected_object = LightImage.lights[idx]
             active_object = LightImage.selected_object
             self.mouse_x=active_object.loc.x
             self.mouse_y=active_object.loc.y
@@ -212,19 +212,21 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
     def invoke(self, context, event):
         global running_modals
         context.active_object.select_set(True)
-        if LightImage.selected_object is None:
-            idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
-            LightImage.selected_object = LightImage.lights[idx]
+        lls_collection, profile_collection, profile, handle = llscol_profilecol_profile_handle(context)
+        self.profile_handle = handle
 
         if running_modals:
+            if LightImage.selected_object is None:
+                idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
+                LightImage.selected_object = LightImage.lights[idx]
             # override starting mouse position
             global panel_global
             self.mouse_x = LightImage.selected_object.loc.x
             self.mouse_y = LightImage.selected_object.loc.y
-            self.light_object = LightImage.selected_object._lls_object
+            self.light_handle = LightImage.selected_object._lls_object.parent
             self.light_actuator = LightImage.selected_object._lls_actuator
             self.base_object_rotation = self.light_actuator.rotation_euler.copy()
-            self.base_object_distance = self.light_object.location.x
+            self.base_object_distance = self.light_handle.location.z
             self.canvas_width = panel_global.width
             self.canvas_height = panel_global.height
         else:
@@ -232,16 +234,16 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
             self.mouse_x = context.area.width/2
             self.mouse_y = context.area.height/2
             self.light_actuator = context.object.parent.parent
-            self.light_object = context.object.parent
+            self.light_handle = context.object.parent
             self.base_object_rotation = context.object.parent.parent.rotation_euler.copy()
-            self.base_object_distance = context.object.parent.location.x
+            self.base_object_distance = self.light_handle.location.z
         super().invoke(context, event)
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
         global running_modals
         self.light_actuator.rotation_euler = self.base_object_rotation
-        self.light_object.location.x = self.base_object_distance
+        self.light_handle.location.z = self.base_object_distance
         
         global GRABBING
         GRABBING = False
@@ -270,10 +272,22 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
             y_factor = .0025 #pi / 250
 
         if self.z_key:
-            self.light_object.location.x = max(self.base_object_distance + dv.x * 0.05, 0)
+            self.light_handle.location.z = max(self.base_object_distance + dv.x * 0.05, 0)
             import bpy_extras
-            self.z_start_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, self.light_object.matrix_world.to_translation().normalized() * context.space_data.clip_end)
-            self.z_end_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, Vector((0,0,0)))
+            start_pos = self.light_handle.matrix_world.to_translation() - self.profile_handle.location
+            start_pos = start_pos.normalized() * context.space_data.clip_end + self.profile_handle.location
+            self.z_start_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, start_pos)
+            if self.z_start_position is None:
+                self.z_start_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, self.light_handle.matrix_world.to_translation())
+            self.z_end_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, self.profile_handle.location)
+            
+            # self.z_start_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, self.light_handle.matrix_world.to_translation().normalized() * context.space_data.clip_end)
+            # self.z_end_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, Vector((0,0,0)))
+
+            if self.z_start_position is None or self.z_end_position is None:
+                self.z_start_position = Vector((0,0))
+                self.z_end_position = Vector((0,0))
+
             if running_modals:
                 global panel_global
                 v1 = panel_global.point_lt
diff --git a/operators/modal_utils.py b/operators/modal_utils.py
index 3881dbb..ba8984e 100644
--- a/operators/modal_utils.py
+++ b/operators/modal_utils.py
@@ -495,8 +495,6 @@ class LightImage(Rectangle):
 
     @classmethod
     def refresh(cls):
-        props = bpy.context.scene.LLStudio
-
         cls.selected_object = None
         for l in cls.lights:
             try:

commit 6ba8505b29f4fe96dddd37093bbcb6048688e226
Author: StyriamMZ <styriam@o2.pl>
Date:   Tue Nov 10 06:09:58 2020 +0100

    2.7.0

diff --git a/deleteOperator.py b/deleteOperator.py
index d9adde2..7a5a9d8 100644
--- a/deleteOperator.py
+++ b/deleteOperator.py
@@ -26,9 +26,16 @@ class DeleteOperator(bpy.types.Operator):
             context.view_layer.objects.active = obj
             if hasattr(obj, 'use_fake_user'):
                 obj.use_fake_user = False
-            ret = bpy.ops.scene.delete_leomoon_studio_light()
-            if 'CANCELLED' in ret:
+            try:
+                ret = bpy.ops.scene.delete_leomoon_studio_light()
+            except:
                 self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
+                return {'FINISHED'}
+            else:
+                if 'CANCELLED' in ret:
+                    self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
+                    return {'FINISHED'}
+
         
         bpy.ops.object.delete('INVOKE_DEFAULT', use_global=self.use_global, confirm=False)
 
diff --git a/light_data.py b/light_data.py
index ed4288f..667e703 100644
--- a/light_data.py
+++ b/light_data.py
@@ -142,7 +142,7 @@ def salvage_data(lls_collection):
             light['radius'] = lls_handle.location.z
             light['position'] = [lls_handle.parent.rotation_euler.x, lls_handle.parent.rotation_euler.y]
             light['rotation'] = lls_handle.rotation_euler.y
-            light['scale'] = lls_handle.scale
+            light['scale'] = lls_handle.scale[:]
             light['type'] = lls_handle.LLStudio.type
         except:
             print("Handled error while parsing lls_handle")
@@ -165,19 +165,27 @@ def salvage_data(lls_collection):
     if VERBOSE: print(light)
     return light
 
-def light_from_dict(light_dict, profile_collection):
-    if isinstance(light_dict, dict):
-        light_dict = LightDict(light_dict)
-        light_dict['basic']['color'] = light_dict['advanced']['Color Overlay'][:3]
-        light_dict['basic']['color_saturation'] = light_dict['advanced']['Color Saturation']
-        light_dict['basic']['intensity'] = light_dict['advanced']['Intensity']
-        if VERBOSE: print(light_dict)
+def light_from_dict(from_dict, profile_collection):
+    if isinstance(from_dict, dict):
+        light_dict = LightDict(from_dict)
+        if not 'basic' in from_dict:
+            light_dict['basic']['color'] = light_dict['advanced']['Color Overlay'][:3]
+            light_dict['basic']['color_saturation'] = light_dict['advanced']['Color Saturation']
+            light_dict['basic']['intensity'] = light_dict['advanced']['Intensity']
+            if VERBOSE:
+                print('_'*5, 'LightDict', '_'*5)
+                print(light_dict)
+        if not 'order_index' in from_dict:
+            light_dict['order_index'] = None
+    else:
+        light_dict = from_dict
 
     profile_empty = [ob for ob in profile_collection.objects if ob.name.startswith('LLS_PROFILE')][0]
     # before
     A = set(profile_empty.children)
 
     bpy.ops.scene.add_leomoon_studio_light()
+    print(f"Added light: {light_dict['light_name']}")
 
     # after operation
     B = set(profile_empty.children)
@@ -197,7 +205,13 @@ def light_from_dict(light_dict, profile_collection):
     actuator.rotation_euler.y = light_dict['position'][1]
     actuator.rotation_euler.z = 0
 
+    lhandle.LLStudio.light_name = light_dict['light_name']
+    if light_dict['order_index'] is not None:
+        lhandle.LLStudio.order_index = light_dict['order_index']
+    lhandle.scale = light_dict['scale']
+
     lhandle.LLStudio.type = 'BASIC'
+
     bpy.context.view_layer.objects.active = lbasic_object
     lbasic_object.data.LLStudio.color = light_dict['basic']['color']
     
@@ -207,10 +221,6 @@ def light_from_dict(light_dict, profile_collection):
     lhandle.LLStudio.type = light_dict['type']
 
     # Advanced
-    lhandle.LLStudio.light_name = light_dict['light_name']
-    lhandle.LLStudio.order_index = light_dict['order_index']
-    lhandle.scale = light_dict['scale']
-
     new_mat_nodes = ladvanced_object.material_slots[0].material.node_tree.nodes
     new_mat_nodes["Group"].inputs[2].default_value = light_dict['advanced']['Texture Switch']
     new_mat_nodes["Group"].inputs[3].default_value[0] = light_dict['advanced']['Color Overlay'][0]
@@ -245,147 +255,11 @@ def light_from_dict(light_dict, profile_collection):
 def convert_old_light(lls_mesh, profile_collection):
     # Salvage data
     col = lls_mesh.users_collection[0]
-    '''
-    context = bpy.context
-    objects = [ob for ob in col.objects]
-    light_handle = [ob for ob in objects if ob.name.startswith("LLS_LIGHT.")]
-    if light_handle: light_handle = light_handle[0]
-    family_obs = family(light_handle)
-
-    # old version
-    light = {}
-    mat_nodes = lls_mesh.active_material.node_tree.nodes
-    light['light_name'] = lls_mesh.LLStudio.light_name
-    light['order_index'] = lls_mesh.LLStudio.order_index
-    light['radius'] = lls_mesh.location.x
-    light['position'] = [lls_mesh.parent.rotation_euler.x, lls_mesh.parent.rotation_euler.y]
-    light['rotation'] = lls_mesh.rotation_euler.x
-    light['type'] = 'ADVANCED'
-
-    light['light_name'] = lls_mesh.LLStudio.light_name
-    light['order_index'] = lls_mesh.LLStudio.order_index
-
-    # advanced
-    light['scale'] = [lls_mesh.scale.x, lls_mesh.scale.y, lls_mesh.scale.z]
-    texpath = lls_mesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
-    light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
-
-    light['Texture Switch'] = mat_nodes["Group"].inputs[2].default_value
-    light['Color Overlay'] = [mat_nodes["Group"].inputs[3].default_value[0],
-                            mat_nodes["Group"].inputs[3].default_value[1],
-                            mat_nodes["Group"].inputs[3].default_value[2],
-                            mat_nodes["Group"].inputs[3].default_value[3]]
-    light['Color Saturation'] = mat_nodes["Group"].inputs[4].default_value
-    light['Intensity'] = mat_nodes["Group"].inputs[5].default_value
-    light['Mask - Gradient Switch'] = mat_nodes["Group"].inputs[6].default_value
-    light['Mask - Gradient Type'] = mat_nodes["Group"].inputs[7].default_value
-    light['Mask - Gradient Amount'] = mat_nodes["Group"].inputs[8].default_value
-    light['Mask - Ring Switch'] = mat_nodes["Group"].inputs[9].default_value
-    light['Mask - Ring Inner Radius'] = mat_nodes["Group"].inputs[10].default_value
-    light['Mask - Ring Outer Radius'] = mat_nodes["Group"].inputs[11].default_value
-    light['Mask - Top to Bottom'] = mat_nodes["Group"].inputs[12].default_value
-    light['Mask - Bottom to Top'] = mat_nodes["Group"].inputs[13].default_value
-    light['Mask - Left to Right'] = mat_nodes["Group"].inputs[14].default_value
-    light['Mask - Right to Left'] = mat_nodes["Group"].inputs[15].default_value
-    light['Mask - Diagonal Top Left'] = mat_nodes["Group"].inputs[16].default_value
-    light['Mask - Diagonal Top Right'] = mat_nodes["Group"].inputs[17].default_value
-    light['Mask - Diagonal Bottom Right'] = mat_nodes["Group"].inputs[18].default_value
-    light['Mask - Diagonal Bottom Left'] = mat_nodes["Group"].inputs[19].default_value
-    '''
 
     light = salvage_data(col)
     if VERBOSE: print(light)
 
-
     # Some crucial objects are missing. Delete whole light collection
     bpy.ops.object.delete_custom({"selected_objects": [lls_mesh,]}, use_global=False, confirm=True)
-    # bpy.ops.object.delete_custom({"active_object": lls_mesh, "object": lls_mesh, "selected_objects": [lls_mesh,]}, use_global=False, confirm=True)
-    # bpy.data.collections.remove(col)
-    # if VERBOSE: traceback.print_exc()
-    # update_light_sets(panel, context, always)
-    # return
-
-    light_from_dict(light, profile_collection)
-
-    '''
-    profile_empty = [ob for ob in profile_collection.objects if ob.name.startswith('LLS_PROFILE')][0]
-    # before
-    A = set(profile_empty.children)
-
-    bpy.ops.scene.add_leomoon_studio_light()
-
-    # after operation
-    B = set(profile_empty.children)
-
-    # whats the difference
-    lgrp = (A ^ B).pop()
-
-    actuator = [c for c in family(lgrp) if "LLS_ROTATION" in c.name][0]
-    lhandle = [c for c in family(lgrp) if "LLS_LIGHT_HANDLE" in c.name][0]
-    ladvanced_object = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
-    lbasic_object = [c for c in family(lgrp) if "LLS_LIGHT_AREA" in c.name][0]
-
-    lhandle.location.z = light['radius']
-    lhandle.rotation_euler.y = light['rotation']
-
-    actuator.rotation_euler.x = light['position'][0]
-    actuator.rotation_euler.y = light['position'][1]
-    actuator.rotation_euler.z = 0
-
-    lhandle.LLStudio.type = 'BASIC'
-    context.view_layer.objects.active = lbasic_object
-    lbasic_object.data.LLStudio.color.r = light['Color Overlay'][0]
-    lbasic_object.data.LLStudio.color.g = light['Color Overlay'][1]
-    lbasic_object.data.LLStudio.color.b = light['Color Overlay'][2]
-    
-    lbasic_object.data.LLStudio.color_saturation = light['Color Saturation']
-    lbasic_object.data.LLStudio.intensity = light['Intensity']
-    lbasic_object.data.size = light['scale'][0] * 9
-    lbasic_object.data.size_y = light['scale'][1] * 9
-    
-    lhandle.LLStudio.type = 'ADVANCED'
-
-    # Advanced
-    ladvanced_object.scale.x = light['scale'][0]
-    ladvanced_object.scale.y = light['scale'][1]
-    ladvanced_object.scale.z = light['scale'][2]
-
-
-    lhandle.LLStudio.light_name = light['light_name']
-    lhandle.LLStudio.order_index = light['order_index']
 
-    new_mat_nodes = ladvanced_object.material_slots[0].material.node_tree.nodes
-    new_mat_nodes["Group"].inputs[2].default_value = light['Texture Switch']
-    new_mat_nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
-    new_mat_nodes["Group"].inputs[3].default_value[1] = light['Color Overlay'][1]
-    new_mat_nodes["Group"].inputs[3].default_value[2] = light['Color Overlay'][2]
-    new_mat_nodes["Group"].inputs[3].default_value[3] = light['Color Overlay'][3]
-    new_mat_nodes["Group"].inputs[4].default_value = light['Color Saturation']
-    new_mat_nodes["Group"].inputs[5].default_value = light['Intensity']
-    new_mat_nodes["Group"].inputs[6].default_value = light['Mask - Gradient Switch']
-    new_mat_nodes["Group"].inputs[7].default_value = light['Mask - Gradient Type']
-    new_mat_nodes["Group"].inputs[8].default_value = light['Mask - Gradient Amount']
-    new_mat_nodes["Group"].inputs[9].default_value = light['Mask - Ring Switch']
-    new_mat_nodes["Group"].inputs[10].default_value = light['Mask - Ring Inner Radius']
-    new_mat_nodes["Group"].inputs[11].default_value = light['Mask - Ring Outer Radius']
-    new_mat_nodes["Group"].inputs[12].default_value = light['Mask - Top to Bottom']
-    new_mat_nodes["Group"].inputs[13].default_value = light['Mask - Bottom to Top']
-    new_mat_nodes["Group"].inputs[14].default_value = light['Mask - Left to Right']
-    new_mat_nodes["Group"].inputs[15].default_value = light['Mask - Right to Left']
-    new_mat_nodes["Group"].inputs[16].default_value = light['Mask - Diagonal Top Left']
-    new_mat_nodes["Group"].inputs[17].default_value = light['Mask - Diagonal Top Right']
-    new_mat_nodes["Group"].inputs[18].default_value = light['Mask - Diagonal Bottom Right']
-    new_mat_nodes["Group"].inputs[19].default_value = light['Mask - Diagonal Bottom Left']
-
-    # new_mat_nodes["Group"].inputs[3].default_value = light['Opacity']
-    # new_mat_nodes["Group"].inputs[4].default_value = light['Falloff']
-    # new_mat_nodes["Group"].inputs[5].default_value = light['Color Saturation']
-    # new_mat_nodes["Group"].inputs[6].default_value = light['Half']
-
-    script_file = os.path.realpath(__file__)
-    dir = os.path.dirname(script_file)
-    if os.path.isabs(light['tex']):
-        new_mat_nodes["Light Texture"].image.filepath = light['tex']
-    else:
-        new_mat_nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
-    '''
\ No newline at end of file
+    light_from_dict(light, profile_collection)
\ No newline at end of file
diff --git a/light_list.py b/light_list.py
index 2f494f9..b7ff690 100644
--- a/light_list.py
+++ b/light_list.py
@@ -295,21 +295,6 @@ class LIST_OT_LightListCopyItem(bpy.types.Operator):
         for e in props.light_list[lls_handle.LLStudio.order_index + 1 : ]:
             bpy.data.objects[e.handle_name].LLStudio.order_index += 1
 
-        
-        
-        # basic_col_copy = [l.users_collection[0] for l in lls_handle_copy.children if l.type == 'LIGHT'][0]
-        # advanced_col_copy = [l.users_collection[0] for l in lls_handle_copy.children if l.type == 'MESH'][0]
-
-        # basic_view_copy = find_view_layer(basic_col_copy, bpy.context.view_layer.layer_collection)
-        # advanced_view_copy = find_view_layer(advanced_col_copy, bpy.context.view_layer.layer_collection)
-
-        # if visible_light_object.type == 'MESH':
-        #     advanced_view_copy.exclude = False
-        #     basic_view_copy.exclude = True
-        # else:
-        #     advanced_view_copy.exclude = True
-        #     basic_view_copy.exclude = False
-
         update_light_list_set(context)
         
         light_object = [obj for obj in lls_handle_copy.children if obj.visible_get()][0]
diff --git a/light_operators.py b/light_operators.py
index 0d8fc87..8706b60 100644
--- a/light_operators.py
+++ b/light_operators.py
@@ -24,62 +24,14 @@ class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
     light_list: CollectionProperty(type = light_list.LightListItem)
     light_list_index: IntProperty(name = "Index for light_list", default = 0, get=light_list.get_list_index, set=light_list.set_list_index)
 
-    # def active_light_type_get(self):
-    #     light_handle = bpy.context.object.parent
-    #     visible_lights = [c for c in light_handle.children if c.visible_get()]
-    #     if len(visible_lights) != 1:
-    #         # TODO: fix it
-    #         return 0
-    #     light_object = visible_lights[0]
-    #     if light_object.type == 'MESH':
-    #         return 0
-    #     else:
-    #         return 1
-    
-    # def active_light_type_set(self, value):
-    #     light_handle = bpy.context.object.parent
-    #     basic_col = [l.users_collection[0] for l in light_handle.children if l.type == 'LIGHT'][0]
-    #     advanced_col = [l.users_collection[0] for l in light_handle.children if l.type == 'MESH'][0]
-
-    #     basic_view = find_view_layer(basic_col, bpy.context.view_layer.layer_collection)
-    #     advanced_view = find_view_layer(advanced_col, bpy.context.view_layer.layer_collection)
-
-    #     if value == 0:
-    #         # ADVANCED
-    #         basic_view.exclude = True
-    #         advanced_view.exclude = False
-    #         bpy.context.view_layer.objects.active = advanced_col.objects[0]
-    #     elif value == 1:
-    #         # BASIC
-    #         basic_view.exclude = False
-    #         advanced_view.exclude = True
-    #         bpy.context.view_layer.objects.active = basic_col.objects[0]
-
-
-    # active_light_type: EnumProperty(
-    #     name="Light Type",
-    #     items=(
-    #         ('ADVANCED', "Advanced", "Cycles only"),
-    #         ('BASIC', "Basic", "Cycles & EEVEE"),
-    #     ),
-    #     default='ADVANCED',
-    #     get=active_light_type_get,
-    #     set=active_light_type_set,
-    # )
-
 class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
     light_name: StringProperty()
     order_index: IntProperty()
     
     def active_light_type_update(self, context):
-        # if not context.object:
-        #     light_handle = bpy.data.objects[context.scene.LLStudio.light_list[self.order_index].handle_name]
-        #     print(light_handle)
-        # else:
-        #     light_handle = context.object.parent
         try:
             light_handle = bpy.data.objects[context.scene.LLStudio.light_list[self.order_index].handle_name]
-        except:
+        except Exception as e:
             return
         
         try:
@@ -101,7 +53,7 @@ class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
                 bpy.context.view_layer.objects.active = basic_col.objects[0]
                 basic_col.objects[0].select_set(True)
                 basic_col.objects[0].data.LLStudio.intensity = basic_col.objects[0].data.LLStudio.intensity
-        except IndexError:
+        except IndexError as e:
             lls_col = light_handle.users_collection[0]
             light = salvage_data(lls_col)
             light_root = light_handle.parent.parent
@@ -142,7 +94,7 @@ class LeoMoon_Light_Studio_Light_Properties(bpy.types.PropertyGroup):
         update=color_update,
     )
     def light_power_formula(self, context):
-        if not bpy.context.object.type == 'LIGHT':
+        if not bpy.context.object or not bpy.context.object.type == 'LIGHT':
             return
         
         try:
@@ -320,7 +272,6 @@ class AddBSLight(bpy.types.Operator):
                 
                 context.view_layer.objects.active = light_object
                 light_object.select_set(True)
-                print(light_object)
 
                 # light = advanced_light_layer.collection.objects[0]
                 # light.LLStudio.order_index = len(context.scene.LLStudio.light_list)
diff --git a/light_profiles.py b/light_profiles.py
index 9834734..88b9081 100644
--- a/light_profiles.py
+++ b/light_profiles.py
@@ -262,7 +262,10 @@ from . import light_operators
 def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
     plist = props.profile_list
     for profile in profiles:
-        print(profile)
+        if VERBOSE:
+            print('_'*5, 'Parse profile', '_'*5)
+            print(json.dumps(profile, indent=4, separators=(',', ': ')))
+
         bpy.ops.lls_list.new_profile()
         props.list_index = len(plist)-1
         plist[-1].name = profile["name"]
@@ -279,88 +282,6 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             handle.location.z = profile['handle_position'][2]
 
         for light in profile["lights"]:
-            '''
-            # before
-            A = set(profile_empty.children)
-
-            bpy.ops.scene.add_leomoon_studio_light()
-
-            # after operation
-            B = set(profile_empty.children)
-
-            # whats the difference
-            lgrp = (A ^ B).pop()
-
-            actuator = [c for c in family(lgrp) if "LLS_ROTATION" in c.name][0]
-            lhandle = [c for c in family(lgrp) if "LLS_LIGHT_HANDLE" in c.name][0]
-            ladvanced_object = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
-            lbasic_object = [c for c in family(lgrp) if "LLS_LIGHT_AREA" in c.name][0]
-
-            lhandle.location.z = light['radius']
-            lhandle.rotation_euler.y = light['rotation']
-
-            actuator.rotation_euler.x = light['position'][0]
-            actuator.rotation_euler.y = light['position'][1]
-            actuator.rotation_euler.z = 0
-
-            # Basic
-            # Set basic area light as visible to change properties. Another way: move area light properties from Light to Object type
-            lhandle.LLStudio.type = 'BASIC'
-            context.view_layer.objects.active = lbasic_object
-            lbasic_object.data.LLStudio.color.r = light['basic']['color'][0]
-            lbasic_object.data.LLStudio.color.g = light['basic']['color'][1]
-            lbasic_object.data.LLStudio.color.b = light['basic']['color'][2]
-            
-            lbasic_object.data.LLStudio.color_saturation = light['basic']['color_saturation']
-            lbasic_object.data.LLStudio.intensity = light['basic']['intensity']
-            lbasic_object.data.size = light['basic']['size']
-            lbasic_object.data.size_y = light['basic']['size_y']
-            
-            lhandle.LLStudio.type = light['type']
-            
-            # Advanced
-            ladvanced_object.scale.x = light['advanced']['scale'][0]
-            ladvanced_object.scale.y = light['advanced']['scale'][1]
-            ladvanced_object.scale.z = light['advanced']['scale'][2]
-
-
-            if 'light_name' in light:
-                lhandle.LLStudio.light_name = light['light_name']
-            if 'order_index' in light:
-                lhandle.LLStudio.order_index = light['order_index']
-
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['advanced']['Texture Switch']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['advanced']['Color Overlay'][0]
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1] = light['advanced']['Color Overlay'][1]
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2] = light['advanced']['Color Overlay'][2]
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3] = light['advanced']['Color Overlay'][3]
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['advanced']['Color Saturation']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['advanced']['Intensity']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['advanced']['Mask - Gradient Switch']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value = light['advanced']['Mask - Gradient Type']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value = light['advanced']['Mask - Gradient Amount']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value = light['advanced']['Mask - Ring Switch']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value = light['advanced']['Mask - Ring Inner Radius']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value = light['advanced']['Mask - Ring Outer Radius']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value = light['advanced']['Mask - Top to Bottom']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value = light['advanced']['Mask - Bottom to Top']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value = light['advanced']['Mask - Left to Right']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value = light['advanced']['Mask - Right to Left']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value = light['advanced']['Mask - Diagonal Top Left']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value = light['advanced']['Mask - Diagonal Top Right']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value = light['advanced']['Mask - Diagonal Bottom Right']
-            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value = light['advanced']['Mask - Diagonal Bottom Left']
-
-            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value = light['advanced']['Opacity']
-            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['advanced']['Falloff']
-            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['advanced']['Color Saturation']
-            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['advanced']['Half']
-
-            if os.path.isabs(light['advanced']['tex']):
-                ladvanced_object.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = light['advanced']['tex']
-            else:
-                ladvanced_object.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['advanced']['tex'])
-            '''
             if version < 3:
                 # most of light settings are moved to advanced sub dict. copy whole dict for the simplicity sake
                 light['advanced'] = light.copy()
@@ -407,61 +328,6 @@ def compose_profile(list_index):
     handle = getProfileHandle(profile)
     profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
     for light_collection in profile_collection.children:
-        '''
-        # lmesh = [ob for ob in light_collection.objects if ob.name.startswith('LLS_LIGHT_MESH')][0]
-        lhandle = [ob for ob in light_collection.objects if ob.name.startswith('LLS_LIGHT_HANDLE')][0]
-        ladvanced_object = [ob for ob in lhandle.children if ob.name.startswith('LLS_LIGHT_MESH')][0]
-        lbasic_object = [ob for ob in lhandle.children if ob.name.startswith('LLS_LIGHT_AREA')][0]
-        light = {'advanced': {}, 'basic': {}}
-        light_basic = light['basic']
-        light_advanced = light['advanced']
-
-        actuator = [ob for ob in light_collection.objects if ob.name.startswith('LLS_ROTATION')][0]
-        light['light_name'] = lhandle.LLStudio.light_name
-        light['order_index'] = lhandle.LLStudio.order_index
-        light['radius'] = lhandle.location.z
-        light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
-        light['rotation'] = lhandle.rotation_euler.y
-        light['type'] = lhandle.LLStudio.type
-
-        # basic_dict = {k: getattr(lbasic_object.data, k) for k in lbasic_object.data.__dir__() if not k.startswith('_') and type(getattr(lbasic_object.data, k))}# in {float, int, bool, str, Color}
-        # print(basic_dict)
-        
-        light_basic['color'] = [lbasic_object.data.LLStudio.color.r, lbasic_object.data.LLStudio.color.g, lbasic_object.data.LLStudio.color.b]
-        light_basic['color_saturation'] = lbasic_object.data.LLStudio.color_saturation
-        light_basic['intensity'] = lbasic_object.data.LLStudio.intensity
-        light_basic['size'] = lbasic_object.data.size
-        light_basic['size_y'] = lbasic_object.data.size_y
-
-
-        # advanced
-        light_advanced['scale'] = [ladvanced_object.scale.x, ladvanced_object.scale.y, ladvanced_object.scale.z]
-        texpath = ladvanced_object.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
-        light_advanced['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
-
-        light_advanced['Texture Switch'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
-        light_advanced['Color Overlay'] = [ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0],
-                                  ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1],
-                                  ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2],
-                                  ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3]]
-        light_advanced['Color Saturation'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
-        light_advanced['Intensity'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
-        light_advanced['Mask - Gradient Switch'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
-        light_advanced['Mask - Gradient Type'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value
-        light_advanced['Mask - Gradient Amount'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value
-        light_advanced['Mask - Ring Switch'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value
-        light_advanced['Mask - Ring Inner Radius'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value
-        light_advanced['Mask - Ring Outer Radius'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value
-        light_advanced['Mask - Top to Bottom'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value
-        light_advanced['Mask - Bottom to Top'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value
-        light_advanced['Mask - Left to Right'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value
-        light_advanced['Mask - Right to Left'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value
-        light_advanced['Mask - Diagonal Top Left'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value
-        light_advanced['Mask - Diagonal Top Right'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value
-        light_advanced['Mask - Diagonal Bottom Right'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value
-        light_advanced['Mask - Diagonal Bottom Left'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value
-        '''
-
         light = salvage_data(light_collection)
         profile_dict['lights'].append(light.dict)
         profile_dict['lights'].sort(key=lambda x: x["order_index"])
diff --git a/operators/__init__.py b/operators/__init__.py
index f413312..bd09bf2 100644
--- a/operators/__init__.py
+++ b/operators/__init__.py
@@ -12,7 +12,7 @@ def update_clear():
     global UPDATED
     UPDATED = False
 
-VERBOSE = True
+VERBOSE = False
 
 AREA_DEFAULT_SIZE = 9
 
@@ -27,5 +27,4 @@ class LightOperator:
                context.scene.LLStudio.initialized and \
                object and \
                object.name.startswith('LLS_LIGHT_') and \
-               isFamily(object) and \
-               object.select_get()
\ No newline at end of file
+               isFamily(object)
\ No newline at end of file
diff --git a/operators/modal.py b/operators/modal.py
index 463c5dd..f6fc32e 100644
--- a/operators/modal.py
+++ b/operators/modal.py
@@ -51,6 +51,11 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
 
     def invoke(self, context, event):
         global running_modals
+        context.active_object.select_set(True)
+        if LightImage.selected_object is None:
+            idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
+            LightImage.selected_object = LightImage.lights[idx]
+
         if running_modals:
             active_object = LightImage.selected_object
             self.mouse_x=active_object.loc.x
@@ -128,6 +133,11 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
 
     def invoke(self, context, event):
         global running_modals
+        context.active_object.select_set(True)
+        if LightImage.selected_object is None:
+            idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
+            LightImage.selected_object = LightImage.lights[idx]
+
         if running_modals:
             active_object = LightImage.selected_object
             self.mouse_x=active_object.loc.x
@@ -139,7 +149,7 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
         super().invoke(context, event)
         
         if running_modals:
-            self.base_object_scale = LightImage.selected_object.light_scale.copy()
+            self.base_object_scale = LightImage.selected_object._lls_handle.scale.copy()
         else:
             self.base_object_scale = get_scale_adapter(context.object)
         return {"RUNNING_MODAL"}
@@ -147,7 +157,7 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
     def _cancel(self, context, event):
         global running_modals
         if running_modals:
-            LightImage.selected_object.light_scale = self.base_object_scale
+            LightImage.selected_object._lls_handle.scale = self.base_object_scale
         else:
             # context.object.scale = self.base_object_scale
             set_scale_adapter(context.object, self.base_object_scale)
@@ -169,7 +179,7 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
 
         global running_modals
         if running_modals:
-            LightImage.selected_object.light_scale = new_scale
+            LightImage.selected_object._lls_handle.scale = new_scale
         else:
             set_scale_adapter(context.object, new_scale)
         bpy.context.workspace.status_text_set(f"Scale X: {new_scale.x:.3f} Y: {new_scale.z:.3f}  [X/Y] Axis, [Shift] Precision mode")
@@ -201,6 +211,10 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
 
     def invoke(self, context, event):
         global running_modals
+        context.active_object.select_set(True)
+        if LightImage.selected_object is None:
+            idx = LightImage.find_idx(context.active_object.parent.users_collection[0])
+            LightImage.selected_object = LightImage.lights[idx]
 
         if running_modals:
             # override starting mouse position
diff --git a/operators/modal_utils.py b/operators/modal_utils.py
index abc8411..3881dbb 100644
--- a/operators/modal_utils.py
+++ b/operators/modal_utils.py
@@ -536,9 +536,9 @@ class LightImage(Rectangle):
         if self.rot != self._lls_handle.rotation_euler.y:
             updated |= True
             self.rot = self._lls_handle.rotation_euler.y
-        if self._scale != self.light_scale:
+        if self._scale != self._lls_handle.scale:
             updated |= True
-            self._scale = self.light_scale.copy()
+            self._scale = self._lls_handle.scale.copy()
             self.width = LightImage.default_size * self._scale.x
             self.height = LightImage.default_size * self._scale.z
             self._lls_basic_collection.objects[0].data.LLStudio.intensity = self._lls_basic_collection.objects[0].data.LLStudio.intensity
@@ -576,28 +576,10 @@ class LightImage(Rectangle):
             raise Exception("Malformed light")
         return None
 
-    @property
-    def light_scale(self):
-        return self._lls_handle.scale
-        # if self._lls_object.type == 'MESH':
-        #     return self._lls_object.scale
-        # else:
-        #     return Vector((1, self._lls_object.data.size / AREA_DEFAULT_SIZE, self._lls_object.data.size_y / AREA_DEFAULT_SIZE))
-    
-    @light_scale.setter
-    def light_scale(self, vec):
-        self._lls_handle.scale = vec
-        # if self._lls_object.type == 'MESH':
-        #     self._lls_object.scale = vec
-        # else:
-        #     self._lls_object.data.size = vec[1] * AREA_DEFAULT_SIZE
-        #     self._lls_object.data.size_y = vec[2] * AREA_DEFAULT_SIZE
-
     def __init__(self, context, panel, lls_light_collection):
         self.panel = panel
         self.__panel_loc = Vector((.5, .5))
 
-        # try:
         self._collection = lls_light_collection
         self._lls_handle = [m for m in lls_light_collection.objects if m.name.startswith("LLS_LIGHT_HANDLE")][0]
         self._lls_actuator = self._lls_object.parent.parent
@@ -607,12 +589,8 @@ class LightImage(Rectangle):
         self._lls_advanced_collection = [m for m in lls_light_collection.children if m.name.startswith("LLS_Advanced")][0]
         self._basic_view_layer = find_view_layer(self._lls_basic_collection, context.view_layer.layer_collection)
         self._advanced_view_layer = find_view_layer(self._lls_advanced_collection, context.view_layer.layer_collection)
-        # except Exception:
-        #     raise Exception
 
 
-        # self._image_path = ""
-        print('__Init__')
         self.image = self._lls_advanced_collection.objects[0].active_material.node_tree.nodes["Light Texture"].image
         self._image_path = self._lls_advanced_collection.objects[0].active_material.node_tree.nodes["Light Texture"].image.filepath
         self._lls_rot = None
@@ -628,6 +606,7 @@ class LightImage(Rectangle):
         self.mute_border = Border(self, (.7, 0, 0, 1))
         self.select_border = Border(self, (.2, .9, .2, 1))
         #self.select_border.weight = 2
+        self.active_border = Border(self, (.1, .45, .1, 1))
 
     @property
     def mute(self):
@@ -698,6 +677,8 @@ class LightImage(Rectangle):
     def draw(self):
         try:
             select = self._lls_object.select_get()
+            # select = self._lls_object == bpy.context.active_object and self._lls_object.select_get()
+            active_select = self._lls_object == bpy.context.active_object
         except ReferenceError:
             return
         except AttributeError:
@@ -718,8 +699,10 @@ class LightImage(Rectangle):
 
         if self.mute:
             self.mute_border.draw()
-        elif select:
+        elif select and active_select:
             self.select_border.draw()
+        elif active_select:
+            self.active_border.draw()
         else:
             self.default_border.draw()
 

commit 3aebc3dc2684ad0439c116923d5dd56ed13526a2
Author: StyriamMZ <styriam@o2.pl>
Date:   Mon Nov 9 23:36:51 2020 +0100

    2.7.0

diff --git a/LLS4.blend b/LLS4.blend
index 6b13bea..d84e3df 100644
Binary files a/LLS4.blend and b/LLS4.blend differ
diff --git a/light_data.py b/light_data.py
index 1f38beb..ed4288f 100644
--- a/light_data.py
+++ b/light_data.py
@@ -6,11 +6,6 @@ import os
 class LightDict:
     _dict = {
         "advanced": {
-            "scale": [
-                1.0,
-                1.0,
-                1.0
-            ],
             "tex": "Soft Box A.exr",
             "Texture Switch": 1.0,
             "Color Overlay": [
@@ -44,8 +39,6 @@ class LightDict:
             ],
             "color_saturation": 0.0,
             "intensity": 2.0,
-            "size": 9.0,
-            "size_y": 9.0
         },
         "light_name": "",
         "order_index": 0,
@@ -55,6 +48,11 @@ class LightDict:
             0.0
         ],
         "rotation": 0.0,
+        "scale": [
+            1.0,
+            1.0,
+            1.0
+        ],
         "type": "ADVANCED"
     }
 
@@ -106,8 +104,9 @@ def salvage_data(lls_collection):
             light['light_name'] = lls_mesh.LLStudio.light_name
             light['order_index'] = lls_mesh.LLStudio.order_index
 
+            light['scale'] = [lls_mesh.scale.y, lls_mesh.scale.x, lls_mesh.scale.z]
+
             # advanced
-            light['advanced']['scale'] = [lls_mesh.scale.x, lls_mesh.scale.y, lls_mesh.scale.z]
             texpath = lls_mesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
             light['advanced']['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
 
@@ -143,6 +142,7 @@ def salvage_data(lls_collection):
             light['radius'] = lls_handle.location.z
             light['position'] = [lls_handle.parent.rotation_euler.x, lls_handle.parent.rotation_euler.y]
             light['rotation'] = lls_handle.rotation_euler.y
+            light['scale'] = lls_handle.scale
             light['type'] = lls_handle.LLStudio.type
         except:
             print("Handled error while parsing lls_handle")
@@ -152,8 +152,6 @@ def salvage_data(lls_collection):
             light['basic']['color'] = [lls_basic.data.LLStudio.color.r, lls_basic.data.LLStudio.color.g, lls_basic.data.LLStudio.color.b]
             light['basic']['color_saturation'] = lls_basic.data.LLStudio.color_saturation
             light['basic']['intensity'] = lls_basic.data.LLStudio.intensity
-            light['basic']['size'] = lls_basic.data.size
-            light['basic']['size_y'] = lls_basic.data.size_y
         except:
             print("Handled error while parsing Light Handle")
     else:
@@ -161,8 +159,6 @@ def salvage_data(lls_collection):
             light['basic']['color'] = light['advanced']['Color Overlay'][:3]
             light['basic']['color_saturation'] = light['advanced']['Color Saturation']
             light['basic']['intensity'] = light['advanced']['Intensity']
-            light['basic']['size'] = light['advanced']['scale'][0] * 9
-            light['basic']['size_y'] = light['advanced']['scale'][1] * 9
         except:
             print("Handled error while parsing Area Light")
     
@@ -207,16 +203,13 @@ def light_from_dict(light_dict, profile_collection):
     
     lbasic_object.data.LLStudio.color_saturation = light_dict['basic']['color_saturation']
     lbasic_object.data.LLStudio.intensity = light_dict['basic']['intensity']
-    lbasic_object.data.size = light_dict['basic']['size']
-    lbasic_object.data.size_y = light_dict['basic']['size_y']
     
     lhandle.LLStudio.type = light_dict['type']
 
     # Advanced
-    ladvanced_object.scale = light_dict['advanced']['scale']
-
     lhandle.LLStudio.light_name = light_dict['light_name']
     lhandle.LLStudio.order_index = light_dict['order_index']
+    lhandle.scale = light_dict['scale']
 
     new_mat_nodes = ladvanced_object.material_slots[0].material.node_tree.nodes
     new_mat_nodes["Group"].inputs[2].default_value = light_dict['advanced']['Texture Switch']
diff --git a/light_operators.py b/light_operators.py
index 48ac283..0d8fc87 100644
--- a/light_operators.py
+++ b/light_operators.py
@@ -77,7 +77,11 @@ class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
         #     print(light_handle)
         # else:
         #     light_handle = context.object.parent
-        light_handle = bpy.data.objects[context.scene.LLStudio.light_list[self.order_index].handle_name]
+        try:
+            light_handle = bpy.data.objects[context.scene.LLStudio.light_list[self.order_index].handle_name]
+        except:
+            return
+        
         try:
             basic_col = [l.users_collection[0] for l in light_handle.children if l.type == 'LIGHT'][0]
             advanced_col = [l.users_collection[0] for l in light_handle.children if l.type == 'MESH'][0]
@@ -89,11 +93,14 @@ class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
                 basic_view.exclude = True
                 advanced_view.exclude = False
                 bpy.context.view_layer.objects.active = advanced_col.objects[0]
+                advanced_col.objects[0].select_set(True)
             elif self.type == 'BASIC':
                 # BASIC
                 basic_view.exclude = False
                 advanced_view.exclude = True
                 bpy.context.view_layer.objects.active = basic_col.objects[0]
+                basic_col.objects[0].select_set(True)
+                basic_col.objects[0].data.LLStudio.intensity = basic_col.objects[0].data.LLStudio.intensity
         except IndexError:
             lls_col = light_handle.users_collection[0]
             light = salvage_data(lls_col)
@@ -135,8 +142,11 @@ class LeoMoon_Light_Studio_Light_Properties(bpy.types.PropertyGroup):
         update=color_update,
     )
     def light_power_formula(self, context):
+        if not bpy.context.object.type == 'LIGHT':
+            return
+        
         try:
-            bpy.context.object.data.energy = self.intensity * context.object.data.size / AREA_DEFAULT_SIZE * context.object.data.size_y / AREA_DEFAULT_SIZE * 250
+            bpy.context.object.data.energy = self.intensity * context.object.parent.scale.x * context.object.parent.scale.z * 250
         except:
             bpy.context.object.data.energy = self.intensity
 
diff --git a/operators/modal.py b/operators/modal.py
index 6ee2cdd..463c5dd 100644
--- a/operators/modal.py
+++ b/operators/modal.py
@@ -97,17 +97,22 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
         return {"PASS_THROUGH"}
 
 def get_scale_adapter(light_object):
-    if light_object.type == 'MESH':
-        return light_object.scale.copy()
-    elif light_object.type == 'LIGHT':
-        return Vector((light_object.data.size / 9, light_object.data.size / 9, light_object.data.size_y / 9))
+    return light_object.parent.scale.copy()
+    # if light_object.type == 'MESH':
+    #     return light_object.scale.copy()
+    # elif light_object.type == 'LIGHT':
+    #     return Vector((light_object.data.size / 9, light_object.data.size / 9, light_object.data.size_y / 9))
 
 def set_scale_adapter(light_object, new_scale):
-    if light_object.type == 'MESH':
-        light_object.scale = new_scale
-    elif light_object.type == 'LIGHT':
-        light_object.data.size = new_scale.y * 9
-        light_object.data.size_y = new_scale.z * 9
+    light_object.parent.scale = new_scale
+    if light_object.type == 'LIGHT':
+        light_object.data.LLStudio.intensity = light_object.data.LLStudio.intensity
+
+    # if light_object.type == 'MESH':
+    #     light_object.scale = new_scale
+    # elif light_object.type == 'LIGHT':
+    #     light_object.data.size = new_scale.y * 9
+    #     light_object.data.size_y = new_scale.z * 9
 
 class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
     bl_idname = "light_studio.scale"
@@ -156,8 +161,10 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
     def _modal(self, context, event):
         new_scale = self.base_object_scale * self.delta_length_factor()
         if self.x_key:
+            new_scale.y = self.base_object_scale.y
             new_scale.z = self.base_object_scale.z
         if self.y_key:
+            new_scale.x = self.base_object_scale.x
             new_scale.y = self.base_object_scale.y
 
         global running_modals
@@ -165,7 +172,7 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
             LightImage.selected_object.light_scale = new_scale
         else:
             set_scale_adapter(context.object, new_scale)
-        bpy.context.workspace.status_text_set(f"Scale X: {new_scale.y:.3f} Y: {new_scale.z:.3f}  [X/Y] Axis, [Shift] Precision mode")
+        bpy.context.workspace.status_text_set(f"Scale X: {new_scale.x:.3f} Y: {new_scale.z:.3f}  [X/Y] Axis, [Shift] Precision mode")
         #context.area.header_text_set(text=f"Scale X: {new_scale.y:.3f} Y: {new_scale.z:.3f}  [X/Y] Axis, [Shift] Precision mode")
 
         if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
diff --git a/operators/modal_utils.py b/operators/modal_utils.py
index cc6bf09..abc8411 100644
--- a/operators/modal_utils.py
+++ b/operators/modal_utils.py
@@ -516,7 +516,7 @@ class LightImage(Rectangle):
 
     def panel_loc_to_area_px_lt(self):
         panel_px_loc = Vector((self.panel.width * self.panel_loc.x, -self.panel.height * (1-self.panel_loc.y)))
-        return panel_px_loc + self.panel.point_lt - Vector((LightImage.default_size*self._scale.y/2, LightImage.default_size*self._scale.z/2))
+        return panel_px_loc + self.panel.point_lt - Vector((LightImage.default_size*self._scale.x/2, LightImage.default_size*self._scale.z/2))
 
     def _update_panel_loc(self):
         self.panel_loc.x = (self._lls_rot.x + pi) % (2*pi) / (2*pi)
@@ -539,8 +539,9 @@ class LightImage(Rectangle):
         if self._scale != self.light_scale:
             updated |= True
             self._scale = self.light_scale.copy()
-            self.width = LightImage.default_size * self._scale.y
+            self.width = LightImage.default_size * self._scale.x
             self.height = LightImage.default_size * self._scale.z
+            self._lls_basic_collection.objects[0].data.LLStudio.intensity = self._lls_basic_collection.objects[0].data.LLStudio.intensity
 
         if updated:
             self._update_panel_loc()
@@ -577,18 +578,20 @@ class LightImage(Rectangle):
 
     @property
     def light_scale(self):
-        if self._lls_object.type == 'MESH':
-            return self._lls_object.scale
-        else:
-            return Vector((1, self._lls_object.data.size / AREA_DEFAULT_SIZE, self._lls_object.data.size_y / AREA_DEFAULT_SIZE))
+        return self._lls_handle.scale
+        # if self._lls_object.type == 'MESH':
+        #     return self._lls_object.scale
+        # else:
+        #     return Vector((1, self._lls_object.data.size / AREA_DEFAULT_SIZE, self._lls_object.data.size_y / AREA_DEFAULT_SIZE))
     
     @light_scale.setter
     def light_scale(self, vec):
-        if self._lls_object.type == 'MESH':
-            self._lls_object.scale = vec
-        else:
-            self._lls_object.data.size = vec[1] * AREA_DEFAULT_SIZE
-            self._lls_object.data.size_y = vec[2] * AREA_DEFAULT_SIZE
+        self._lls_handle.scale = vec
+        # if self._lls_object.type == 'MESH':
+        #     self._lls_object.scale = vec
+        # else:
+        #     self._lls_object.data.size = vec[1] * AREA_DEFAULT_SIZE
+        #     self._lls_object.data.size_y = vec[2] * AREA_DEFAULT_SIZE
 
     def __init__(self, context, panel, lls_light_collection):
         self.panel = panel

commit 44f068ad22ac4663fd992794786ccf6308e37b5c
Author: StyriamMZ <styriam@o2.pl>
Date:   Mon Nov 9 22:23:28 2020 +0100

    2.7.0

diff --git a/light_operators.py b/light_operators.py
index baef42e..48ac283 100644
--- a/light_operators.py
+++ b/light_operators.py
@@ -114,6 +114,7 @@ class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
         update=active_light_type_update,
     ) 
 
+from . operators import AREA_DEFAULT_SIZE
 class LeoMoon_Light_Studio_Light_Properties(bpy.types.PropertyGroup):
     def color_update(self, context):
         bpy.context.object.data.color = Vector((1,1,1)).lerp(Vector(self.color), self.color_saturation)
@@ -133,10 +134,9 @@ class LeoMoon_Light_Studio_Light_Properties(bpy.types.PropertyGroup):
         max=1,
         update=color_update,
     )
-
     def light_power_formula(self, context):
         try:
-            bpy.context.object.data.energy = self.intensity * context.object.data.size * context.object.data.size_y * 250
+            bpy.context.object.data.energy = self.intensity * context.object.data.size / AREA_DEFAULT_SIZE * context.object.data.size_y / AREA_DEFAULT_SIZE * 250
         except:
             bpy.context.object.data.energy = self.intensity
 
@@ -298,14 +298,24 @@ class AddBSLight(bpy.types.Operator):
                 basic_light_layer = find_view_layer(basic_light_collection, context.view_layer.layer_collection)
                 advanced_light_layer = find_view_layer(advanced_light_collection, context.view_layer.layer_collection)
                 if context.scene.render.engine == "BLENDER_EEVEE":
-                    basic_light_layer.exclude = False
-                    advanced_light_layer.exclude = True
+                    # basic_light_layer.exclude = False
+                    # advanced_light_layer.exclude = True
+                    light_object = basic_light_collection.objects[0]
+                    light_handle.LLStudio.type = 'BASIC'
                 else:
-                    basic_light_layer.exclude = True
-                    advanced_light_layer.exclude = False
+                    # basic_light_layer.exclude = True
+                    # advanced_light_layer.exclude = False
+                    light_object = advanced_light_collection.objects[0]
+                    light_handle.LLStudio.type = 'ADVANCED'
+                
+                context.view_layer.objects.active = light_object
+                light_object.select_set(True)
+                print(light_object)
 
-                light = advanced_light_layer.collection.objects[0]
+                # light = advanced_light_layer.collection.objects[0]
                 # light.LLStudio.order_index = len(context.scene.LLStudio.light_list)
+                # light_handle.LLStudio.order_index = len(context.scene.LLStudio.light_list)
+
 
 
 
diff --git a/operators/__init__.py b/operators/__init__.py
index dc6d7a9..f413312 100644
--- a/operators/__init__.py
+++ b/operators/__init__.py
@@ -14,6 +14,8 @@ def update_clear():
 
 VERBOSE = True
 
+AREA_DEFAULT_SIZE = 9
+
 from .. common import isFamily
 class LightOperator:
     @classmethod
@@ -25,4 +27,5 @@ class LightOperator:
                context.scene.LLStudio.initialized and \
                object and \
                object.name.startswith('LLS_LIGHT_') and \
-               isFamily(object)
\ No newline at end of file
+               isFamily(object) and \
+               object.select_get()
\ No newline at end of file
diff --git a/operators/modal_utils.py b/operators/modal_utils.py
index 0a792a8..cc6bf09 100644
--- a/operators/modal_utils.py
+++ b/operators/modal_utils.py
@@ -177,7 +177,7 @@ lightIconShader.bind()
 border_shader2Dcolor = gpu.types.GPUShader(border_vertex_shader, border_fragment_shader)
 border_shader2Dcolor.bind()
 
-AREA_DEFAULT_SIZE = 8.91651
+from . import AREA_DEFAULT_SIZE
 
 class Rectangle:
     def __init__(self, start_point, width, height):
@@ -580,14 +580,13 @@ class LightImage(Rectangle):
         if self._lls_object.type == 'MESH':
             return self._lls_object.scale
         else:
-            return Vector((self._lls_object.data.size / AREA_DEFAULT_SIZE, self._lls_object.data.size_y / AREA_DEFAULT_SIZE, 1))
+            return Vector((1, self._lls_object.data.size / AREA_DEFAULT_SIZE, self._lls_object.data.size_y / AREA_DEFAULT_SIZE))
     
     @light_scale.setter
     def light_scale(self, vec):
         if self._lls_object.type == 'MESH':
             self._lls_object.scale = vec
         else:
-            print(vec)
             self._lls_object.data.size = vec[1] * AREA_DEFAULT_SIZE
             self._lls_object.data.size_y = vec[2] * AREA_DEFAULT_SIZE
 

commit e002a3d59f8959c63d8f2cfc37d7fa5dd9a29b8f
Author: StyriamMZ <styriam@o2.pl>
Date:   Mon Nov 9 10:27:41 2020 +0100

    2.7.0

diff --git a/.gitignore b/.gitignore
index 894a44c..9f9634b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -102,3 +102,4 @@ venv.bak/
 
 # mypy
 .mypy_cache/
+/skrypt
diff --git a/LLS3.blend b/LLS3.blend
deleted file mode 100644
index f0e1cc8..0000000
Binary files a/LLS3.blend and /dev/null differ
diff --git a/LLS4.blend b/LLS4.blend
new file mode 100644
index 0000000..6b13bea
Binary files /dev/null and b/LLS4.blend differ
diff --git a/__init__.py b/__init__.py
index ea52a14..07da0d6 100644
--- a/__init__.py
+++ b/__init__.py
@@ -4,7 +4,7 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 6, 2),
+    "version": (2, 7, 0),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
@@ -24,7 +24,7 @@ auto_load.init()
 # register
 ################################## 
 
-from . light_operators import LeoMoon_Light_Studio_Properties, LeoMoon_Light_Studio_Object_Properties
+from . light_operators import LeoMoon_Light_Studio_Properties, LeoMoon_Light_Studio_Object_Properties, LeoMoon_Light_Studio_Light_Properties
 from . import deleteOperator, light_brush
 from . operators import modal
 
@@ -33,6 +33,7 @@ def register():
     bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
     bpy.types.Scene.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Properties", type = LeoMoon_Light_Studio_Properties)
     bpy.types.Object.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Object Properties", type = LeoMoon_Light_Studio_Object_Properties)
+    bpy.types.Light.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Light Properties", type = LeoMoon_Light_Studio_Light_Properties)
     deleteOperator.add_shortkeys()
     light_brush.add_shortkeys()
     modal.add_shortkeys()
diff --git a/common.py b/common.py
index 49ef486..af94742 100644
--- a/common.py
+++ b/common.py
@@ -99,6 +99,11 @@ def getLightMesh():
     lm = [l for l in family(lg) if l.name.startswith("LLS_LIGHT_MESH")]
     return lm[0] if len(lm) else None
 
+# def getLightHandle():
+#     lg = findLightGrp(bpy.context.active_object)
+#     lm = [l for l in family(lg) if l.name.startswith("LLS_LIGHT_HANDLE")]
+#     return lm[0] if len(lm) else None
+
 def getLightController():
     obs = bpy.context.view_layer.objects
     lightGrp = obs.active
@@ -116,7 +121,7 @@ def findLightProfile(ob):
         
     return None
 
-def getLightHandle(ob=None):
+def getProfileHandle(ob=None):
     if not ob:
         ob = bpy.context.scene.objects.active
 
@@ -138,84 +143,137 @@ def refreshMaterials():
         mixNode = mat.node_tree.nodes['Mix Shader'].inputs['Fac']
         mixNode.default_value = mixNode.default_value
 
-def duplicate_collection(collection, parent_collection):
-    new_collection = bpy.data.collections.new(collection.name)
+# def duplicate_collection(collection, parent_collection):
+#     new_collection = bpy.data.collections.new(collection.name)
+
+#     new_names = {}
+#     matrix_data = {}
+
+#     for obj in collection.objects:
+#         new_obj = obj.copy()
+
+#         new_names[obj.name] = new_obj
+#         matrix_data[new_obj.name] = {
+#             "matrix_basis": obj.matrix_basis.copy(),
+#             "matrix_local": obj.matrix_local.copy(),
+#             "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
+#             "matrix_world": obj.matrix_world.copy()
+#             }
+
+#         if new_obj.data:
+#             new_obj.data = obj.data.copy()
+#         for slot in new_obj.material_slots:
+#             slot.material = slot.material.copy()
+#         new_obj.parent = obj.parent
+#         new_collection.objects.link(new_obj)
+
+#     for obj in new_collection.objects:
+#         if obj.parent:
+#             if obj.parent.name in new_names:
+#                 obj.parent = new_names[obj.parent.name]
+#             obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
+#             #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
+#             obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
+#             #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
+
+
+#     if parent_collection:
+#         parent_collection.children.link(new_collection)
+
+#     iter_list = [collection.children]
+#     parent_collection = new_collection
+
+#     while len(iter_list) > 0:
+#         new_iter_list = []
+
+#         for iter in iter_list:
+#             for collection in iter:
+
+#                 new_collection = bpy.data.collections.new(collection.name)
 
+#                 for obj in collection.objects:
+#                     new_obj = obj.copy()
+
+#                     new_names[obj.name] = new_obj
+#                     matrix_data[new_obj.name] = {
+#                         "matrix_basis": obj.matrix_basis.copy(),
+#                         "matrix_local": obj.matrix_local.copy(),
+#                         "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
+#                         "matrix_world": obj.matrix_world.copy()
+#                         }
+
+#                     if new_obj.data:
+#                         new_obj.data = obj.data.copy()
+#                     for slot in new_obj.material_slots:
+#                         slot.material = slot.material.copy()
+#                     new_obj.parent = obj.parent
+#                     new_collection.objects.link(new_obj)
+
+#                 for obj in new_collection.objects:
+#                     if obj.parent:
+#                         obj.parent = new_names[obj.parent.name]
+#                         obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
+#                         #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
+#                         obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
+#                         #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
+
+#                 parent_collection.children.link(new_collection)
+
+#                 if len(collection.children) > 0:
+#                     new_iter_list.append(collection.children)
+
+#         iter_list = new_iter_list
+#     return parent_collection
+
+
+def duplicate_collection(collection, parent_collection):
     new_names = {}
     matrix_data = {}
+    profile_handle = [obj for obj in collection.objects if obj.name.startswith("LLS_HANDLE")]
+    profile_handle = profile_handle[0] if profile_handle else None
+    print(profile_handle)
+
+    def rec_dup(collection, parent_collection):
+        new_collection = bpy.data.collections.new(collection.name)
+        for obj in collection.objects:
+            new_obj = obj.copy()
+
+            new_names[obj.name] = new_obj
+            matrix_data[new_obj.name] = {
+                "matrix_basis": obj.matrix_basis.copy(),
+                "matrix_local": obj.matrix_local.copy(),
+                "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
+                "matrix_world": obj.matrix_world.copy()
+                }
+
+            if new_obj.data:
+                new_obj.data = obj.data.copy()
+            for slot in new_obj.material_slots:
+                slot.material = slot.material.copy()
+            new_obj.parent = obj.parent
+            new_collection.objects.link(new_obj)
+
+        for obj in new_collection.objects:
+            if obj.parent:
+                if obj.parent.name in new_names:
+                    obj.parent = new_names[obj.parent.name]
+                obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
+                #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
+                obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
+                #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
+                if profile_handle and obj.name.startswith("LLS_LIGHT_HANDLE"):
+                    obj.constraints['Copy Location'].target = new_names[profile_handle.name]
+
+
+        if parent_collection:
+            parent_collection.children.link(new_collection)
+        
+        iter_list = collection.children[:]
+        parent_collection = new_collection
+
+        for col in iter_list:
+            rec_dup(col, parent_collection)
+        
+        return parent_collection
 
-    for obj in collection.objects:
-        new_obj = obj.copy()
-
-        new_names[obj.name] = new_obj
-        matrix_data[new_obj.name] = {
-            "matrix_basis": obj.matrix_basis.copy(),
-            "matrix_local": obj.matrix_local.copy(),
-            "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
-            "matrix_world": obj.matrix_world.copy()
-            }
-
-        if new_obj.data:
-            new_obj.data = obj.data.copy()
-        for slot in new_obj.material_slots:
-            slot.material = slot.material.copy()
-        new_obj.parent = obj.parent
-        new_collection.objects.link(new_obj)
-
-    for obj in new_collection.objects:
-        if obj.parent:
-            if obj.parent.name in new_names:
-                obj.parent = new_names[obj.parent.name]
-            obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
-            #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
-            obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
-            #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
-
-
-    if parent_collection:
-        parent_collection.children.link(new_collection)
-
-    iter_list = [collection.children]
-    parent_collection = new_collection
-
-    while len(iter_list) > 0:
-        new_iter_list = []
-
-        for iter in iter_list:
-            for collection in iter:
-
-                new_collection = bpy.data.collections.new(collection.name)
-
-                for obj in collection.objects:
-                    new_obj = obj.copy()
-
-                    new_names[obj.name] = new_obj
-                    matrix_data[new_obj.name] = {
-                        "matrix_basis": obj.matrix_basis.copy(),
-                        "matrix_local": obj.matrix_local.copy(),
-                        "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
-                        "matrix_world": obj.matrix_world.copy()
-                        }
-
-                    if new_obj.data:
-                        new_obj.data = obj.data.copy()
-                    for slot in new_obj.material_slots:
-                        slot.material = slot.material.copy()
-                    new_obj.parent = obj.parent
-                    new_collection.objects.link(new_obj)
-
-                for obj in new_collection.objects:
-                    if obj.parent:
-                        obj.parent = new_names[obj.parent.name]
-                        obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
-                        #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
-                        obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
-                        #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
-
-                parent_collection.children.link(new_collection)
-
-                if len(collection.children) > 0:
-                    new_iter_list.append(collection.children)
-
-        iter_list = new_iter_list
-    return parent_collection
\ No newline at end of file
+    return rec_dup(collection, parent_collection)
\ No newline at end of file
diff --git a/deleteOperator.py b/deleteOperator.py
index 1e07f9e..d9adde2 100644
--- a/deleteOperator.py
+++ b/deleteOperator.py
@@ -15,6 +15,8 @@ class DeleteOperator(bpy.types.Operator):
 
     @classmethod
     def poll(cls, context):
+        if not context.area:
+            return True
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
     
     def execute(self, context):
diff --git a/gui.py b/gui.py
index be92642..abdbc8e 100644
--- a/gui.py
+++ b/gui.py
@@ -51,7 +51,7 @@ class LLS_PT_Lights(bpy.types.Panel):
 
         col = row.column(align=True)
         col.operator('scene.add_leomoon_studio_light', icon='ADD', text="")
-        col.operator('scene.delete_leomoon_studio_light', icon='REMOVE', text="")
+        col.operator('scene.delete_leomoon_studio_light', icon='REMOVE', text="").confirm=False
         col.operator('lls_list.copy_light', icon='DUPLICATE', text="")
 
         col.separator()
@@ -72,32 +72,43 @@ class LLS_PT_Selected(bpy.types.Panel):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
 
     def draw(self, context):
-        if context.active_object and (context.active_object.name.startswith('LLS_CONTROLLER') or context.active_object.name.startswith('LLS_LIGHT_MESH')):
+        if context.active_object and context.active_object.name.startswith('LLS_LIGHT_'):
             layout = self.layout
             wm = context.window_manager
 
             col = layout.column(align=True)
             # col.operator('lls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
 
-            box = layout.box()
-            col = box.column()
-            col.template_icon_view(wm, "lls_tex_previews", show_labels=True)
-            col.label(text=os.path.splitext(wm.lls_tex_previews)[0])
-
-            layout.separator()
-            try:
-                lls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
-                for input in lls_inputs[2:]:
-                    if input.type == "RGBA":
-                        layout.prop(input, 'default_value', text=input.name)
-                        col = layout.column(align=True)
-                    else:
-                        col.prop(input, 'default_value', text=input.name)
-            except:
-                col.label(text="LLS_light material is not valid.")
-                if operators.VERBOSE:
-                    traceback.print_exc()
-            col.prop(getLightMesh(), 'location', index=0) #light radius
+            row = col.row()
+            # row.prop(context.scene.LLStudio, 'active_light_type', expand=True)
+            row.prop(context.object.parent.LLStudio, 'type', expand=True)
+            col.separator()
+
+            if context.object.type == 'LIGHT':
+                row = col.row()
+                row.prop(context.object.data.LLStudio, 'color')
+                col.prop(context.object.data.LLStudio, 'color_saturation', slider=True)
+                col.prop(context.object.data.LLStudio, 'intensity')
+            elif context.object.type == 'MESH':
+                box = layout.box()
+                col = box.column()
+                col.template_icon_view(wm, "lls_tex_previews", show_labels=True)
+                col.label(text=os.path.splitext(wm.lls_tex_previews)[0])
+
+                layout.separator()
+                try:
+                    lls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
+                    for input in lls_inputs[2:]:
+                        if input.type == "RGBA":
+                            layout.prop(input, 'default_value', text=input.name)
+                            col = layout.column(align=True)
+                        else:
+                            col.prop(input, 'default_value', text=input.name)
+                except:
+                    col.label(text="LLS_light material is not valid.")
+                    if operators.VERBOSE:
+                        traceback.print_exc()
+            col.prop(getLightMesh().parent, 'location', index=2, text="Distance") #light radius
 
 @force_register
 class LLS_PT_ProfileList(bpy.types.Panel):
diff --git a/light_brush.py b/light_brush.py
index 6faae50..bf6fe4e 100644
--- a/light_brush.py
+++ b/light_brush.py
@@ -86,17 +86,16 @@ def raycast(context, event, diff):
     #####
     profile = findLightGrp(context.active_object).parent
     handle = [ob for ob in profile.children if ob.name.startswith('LLS_HANDLE')][0]
-    lightmesh = getLightMesh()
-    actuator = lightmesh.parent
+    light_handle = context.active_object.parent
+    actuator = light_handle.parent
     position = intersect_line_sphere(
         location - handle.location,
         (normal if diff else view_vector.reflect(normal)) + location - handle.location,
         Vector((0,0,0)),
-        lightmesh.location.x,
+        light_handle.location.z,
         False,
         )[0]
 
-
     if not position:
         return {'RUNNING_MODAL'}
 
@@ -124,7 +123,7 @@ class LLSLightBrush(bpy.types.Operator, LightOperator):
                 self.aux = False
             return {'RUNNING_MODAL'}
 
-        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
+        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | <Normal>' if self.normal_type else '<Reflection> | Normal'}")
 
         if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'Z', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
             # allow navigation
@@ -150,6 +149,11 @@ class LLSLightBrush(bpy.types.Operator, LightOperator):
 
     def invoke(self, context, event):
         if context.space_data.type == 'VIEW_3D':
+            # set workspace tool to select
+            self.beginning_tool = context.workspace.tools.from_space_view3d_mode("OBJECT", create=False).idname
+            print(self.beginning_tool)
+            bpy.ops.wm.tool_set_by_id('INVOKE_DEFAULT', name='builtin.select_box')
+
             context.window_manager.modal_handler_add(self)
             return {'RUNNING_MODAL'}
         else:
@@ -164,12 +168,12 @@ key_released = False
 class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
     """Point on object to position light and reflection"""
     bl_idname = "light_studio.fast_3d_edit"
-    bl_label = "Light Brush"
+    bl_label = "Fast 3D Edit"
     bl_options = {"UNDO"}
-
+    
     continuous: BoolProperty(default=False, name="Hold to use", description="Button behaviour.\n ON: Hold button to use. Release button to stop.\n OFF: Hold LMB to use, release LMB to stop.")
     normal_type: BoolProperty(default=False, name="Light along normal", description="Default reflection type.\n ON: Light along normal\n OFF: surface reflection (what you are looking for in most cases)")
-
+    
     def modal(self, context, event):
         screens = [window.screen for window in context.window_manager.windows]
         regions3d = [(area.spaces[0].region_3d, region) for screen in screens for area in screen.areas if area.type == context.area.type for region in area.regions if region.type == context.region.type]
@@ -195,7 +199,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
 
 
         global key_released
-        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
+        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | <Normal>' if self.normal_type else '<Reflection> | Normal'}")
         # print(event.type, event.value)
         if self.continuous:
             if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
@@ -203,6 +207,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
                 return {'PASS_THROUGH'}
             elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
                 context.area.header_text_set(text=None)
+                bpy.ops.wm.tool_set_by_id('INVOKE_DEFAULT', name=self.beginning_tool)
                 return {'FINISHED'}
             elif event.type == 'N' and event.value == 'PRESS':
                 self.normal_type = not self.normal_type
@@ -212,6 +217,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
                 return {'PASS_THROUGH'}
             elif event.value == 'RELEASE' and not event.type in {'MOUSEMOVE', 'INBETWEEN_MOUSEMOVE', 'N'}:
                 context.area.header_text_set(text=None)
+                bpy.ops.wm.tool_set_by_id('INVOKE_DEFAULT', name=self.beginning_tool)
                 return {'FINISHED'}
             elif event.value == 'RELEASE':
                 key_released = True
@@ -222,6 +228,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
                 return {'PASS_THROUGH'}
             elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
                 context.area.header_text_set(text=None)
+                bpy.ops.wm.tool_set_by_id('INVOKE_DEFAULT', name=self.beginning_tool)
                 return {'FINISHED'}
             elif event.type == 'N' and event.value == 'PRESS':
                 self.normal_type = not self.normal_type
@@ -231,6 +238,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
                 return {'PASS_THROUGH'}
             elif event.type == 'LEFTMOUSE' and event.value == 'RELEASE' and key_released:
                 context.area.header_text_set(text=None)
+                bpy.ops.wm.tool_set_by_id('INVOKE_DEFAULT', name=self.beginning_tool)
                 return {'FINISHED'}
             elif event.type in {self.keymap_key, 'LEFTMOUSE'} and event.value == 'RELEASE':
                 key_released = True
@@ -241,6 +249,13 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
 
     def invoke(self, context, event):
         context.window_manager.modal_handler_add(self)
+
+        # set workspace tool to select
+        self.beginning_tool = context.workspace.tools.from_space_view3d_mode("OBJECT", create=False).idname
+        print(self.beginning_tool)
+        bpy.ops.wm.tool_set_by_id('INVOKE_DEFAULT', name='builtin.select_box')
+
+
         km, kmi = get_user_keymap_item('Object Mode', self.__class__.bl_idname)
         self.keymap_key = kmi.type if kmi else 'F'
         global key_released
@@ -249,6 +264,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
             raycast(context, event, self.normal_type)
         return {'RUNNING_MODAL'}
 
+
 addon_keymaps = []
 def add_shortkeys():
     wm = bpy.context.window_manager
diff --git a/light_data.py b/light_data.py
new file mode 100644
index 0000000..1f38beb
--- /dev/null
+++ b/light_data.py
@@ -0,0 +1,398 @@
+import bpy
+from . common import family
+from . operators import VERBOSE
+import os
+
+class LightDict:
+    _dict = {
+        "advanced": {
+            "scale": [
+                1.0,
+                1.0,
+                1.0
+            ],
+            "tex": "Soft Box A.exr",
+            "Texture Switch": 1.0,
+            "Color Overlay": [
+                1.0,
+                0.4000000059604645,
+                0.15000000596046448,
+                1.0
+            ],
+            "Color Saturation": 0.0,
+            "Intensity": 2.0,
+            "Mask - Gradient Switch": 0.0,
+            "Mask - Gradient Type": 0.0,
+            "Mask - Gradient Amount": 0.0,
+            "Mask - Ring Switch": 0.0,
+            "Mask - Ring Inner Radius": 0.0,
+            "Mask - Ring Outer Radius": 0.0,
+            "Mask - Top to Bottom": 0.0,
+            "Mask - Bottom to Top": 0.0,
+            "Mask - Left to Right": 0.0,
+            "Mask - Right to Left": 0.0,
+            "Mask - Diagonal Top Left": 0.0,
+            "Mask - Diagonal Top Right": 0.0,
+            "Mask - Diagonal Bottom Right": 0.0,
+            "Mask - Diagonal Bottom Left": 0.0
+        },
+        "basic": {
+            "color": [
+                1.0,
+                1.0,
+                1.0
+            ],
+            "color_saturation": 0.0,
+            "intensity": 2.0,
+            "size": 9.0,
+            "size_y": 9.0
+        },
+        "light_name": "",
+        "order_index": 0,
+        "radius": 30.0,
+        "position": [
+            0.0,
+            0.0
+        ],
+        "rotation": 0.0,
+        "type": "ADVANCED"
+    }
+
+    def __init__(self, real_dict=None):
+        import copy
+        self.dict = copy.deepcopy(self._dict)
+        
+        if real_dict:
+            self.dict.update(real_dict)
+    
+    def __getitem__(self, key):
+        return self.dict[key]
+    
+    def __setitem__(self, key, val):
+        self.dict[key] = val
+    
+    def __str__(self):
+        import json
+        return json.dumps(self.dict, indent=4, separators=(',', ': '))
+
+def salvage_data(lls_collection):
+    # Salvage data
+    objects = [ob for ob in lls_collection.objects]
+    light_handle = [ob for ob in objects if ob.name.startswith("LLS_LIGHT.")]
+    if light_handle: light_handle = light_handle[0]
+    family_obs = family(light_handle)
+
+    lls_mesh = [ob for ob in family_obs if ob.name.startswith("LLS_LIGHT_MESH")]
+    if lls_mesh: lls_mesh = lls_mesh[0]
+
+    lls_basic = [ob for ob in family_obs if ob.name.startswith("LLS_LIGHT_AREA")]
+    if lls_basic: lls_basic = lls_basic[0]
+
+    lls_handle = [ob for ob in family_obs if ob.name.startswith("LLS_LIGHT_HANDLE")]
+    if lls_handle: lls_handle = lls_handle[0]
+
+    # old version
+    light = LightDict()
+    if lls_mesh:
+        # Include obsolete values. Newer lls_handle will override them (if found)
+        try:
+            light['light_name'] = lls_mesh.LLStudio.light_name
+            light['order_index'] = lls_mesh.LLStudio.order_index
+            light['radius'] = lls_mesh.location.x
+            light['position'] = [lls_mesh.parent.rotation_euler.x, lls_mesh.parent.rotation_euler.y]
+            light['rotation'] = -lls_mesh.rotation_euler.x
+            light['type'] = 'ADVANCED'
+
+            light['light_name'] = lls_mesh.LLStudio.light_name
+            light['order_index'] = lls_mesh.LLStudio.order_index
+
+            # advanced
+            light['advanced']['scale'] = [lls_mesh.scale.x, lls_mesh.scale.y, lls_mesh.scale.z]
+            texpath = lls_mesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
+            light['advanced']['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
+
+            mat_nodes = lls_mesh.active_material.node_tree.nodes
+            light['advanced']['Texture Switch'] = mat_nodes["Group"].inputs[2].default_value
+            light['advanced']['Color Overlay'] = [mat_nodes["Group"].inputs[3].default_value[0],
+                                    mat_nodes["Group"].inputs[3].default_value[1],
+                                    mat_nodes["Group"].inputs[3].default_value[2],
+                                    mat_nodes["Group"].inputs[3].default_value[3]]
+            light['advanced']['Color Saturation'] = mat_nodes["Group"].inputs[4].default_value
+            light['advanced']['Intensity'] = mat_nodes["Group"].inputs[5].default_value
+            light['advanced']['Mask - Gradient Switch'] = mat_nodes["Group"].inputs[6].default_value
+            light['advanced']['Mask - Gradient Type'] = mat_nodes["Group"].inputs[7].default_value
+            light['advanced']['Mask - Gradient Amount'] = mat_nodes["Group"].inputs[8].default_value
+            light['advanced']['Mask - Ring Switch'] = mat_nodes["Group"].inputs[9].default_value
+            light['advanced']['Mask - Ring Inner Radius'] = mat_nodes["Group"].inputs[10].default_value
+            light['advanced']['Mask - Ring Outer Radius'] = mat_nodes["Group"].inputs[11].default_value
+            light['advanced']['Mask - Top to Bottom'] = mat_nodes["Group"].inputs[12].default_value
+            light['advanced']['Mask - Bottom to Top'] = mat_nodes["Group"].inputs[13].default_value
+            light['advanced']['Mask - Left to Right'] = mat_nodes["Group"].inputs[14].default_value
+            light['advanced']['Mask - Right to Left'] = mat_nodes["Group"].inputs[15].default_value
+            light['advanced']['Mask - Diagonal Top Left'] = mat_nodes["Group"].inputs[16].default_value
+            light['advanced']['Mask - Diagonal Top Right'] = mat_nodes["Group"].inputs[17].default_value
+            light['advanced']['Mask - Diagonal Bottom Right'] = mat_nodes["Group"].inputs[18].default_value
+            light['advanced']['Mask - Diagonal Bottom Left'] = mat_nodes["Group"].inputs[19].default_value
+        except:
+            print("Error while parsing Mesh Light")
+    
+    if lls_handle:
+        try:
+            light['light_name'] = lls_handle.LLStudio.light_name
+            light['order_index'] = lls_handle.LLStudio.order_index
+            light['radius'] = lls_handle.location.z
+            light['position'] = [lls_handle.parent.rotation_euler.x, lls_handle.parent.rotation_euler.y]
+            light['rotation'] = lls_handle.rotation_euler.y
+            light['type'] = lls_handle.LLStudio.type
+        except:
+            print("Handled error while parsing lls_handle")
+    
+    if lls_basic:
+        try:
+            light['basic']['color'] = [lls_basic.data.LLStudio.color.r, lls_basic.data.LLStudio.color.g, lls_basic.data.LLStudio.color.b]
+            light['basic']['color_saturation'] = lls_basic.data.LLStudio.color_saturation
+            light['basic']['intensity'] = lls_basic.data.LLStudio.intensity
+            light['basic']['size'] = lls_basic.data.size
+            light['basic']['size_y'] = lls_basic.data.size_y
+        except:
+            print("Handled error while parsing Light Handle")
+    else:
+        try:
+            light['basic']['color'] = light['advanced']['Color Overlay'][:3]
+            light['basic']['color_saturation'] = light['advanced']['Color Saturation']
+            light['basic']['intensity'] = light['advanced']['Intensity']
+            light['basic']['size'] = light['advanced']['scale'][0] * 9
+            light['basic']['size_y'] = light['advanced']['scale'][1] * 9
+        except:
+            print("Handled error while parsing Area Light")
+    
+    if VERBOSE: print(light)
+    return light
+
+def light_from_dict(light_dict, profile_collection):
+    if isinstance(light_dict, dict):
+        light_dict = LightDict(light_dict)
+        light_dict['basic']['color'] = light_dict['advanced']['Color Overlay'][:3]
+        light_dict['basic']['color_saturation'] = light_dict['advanced']['Color Saturation']
+        light_dict['basic']['intensity'] = light_dict['advanced']['Intensity']
+        if VERBOSE: print(light_dict)
+
+    profile_empty = [ob for ob in profile_collection.objects if ob.name.startswith('LLS_PROFILE')][0]
+    # before
+    A = set(profile_empty.children)
+
+    bpy.ops.scene.add_leomoon_studio_light()
+
+    # after operation
+    B = set(profile_empty.children)
+
+    # whats the difference
+    lgrp = (A ^ B).pop()
+
+    actuator = [c for c in family(lgrp) if "LLS_ROTATION" in c.name][0]
+    lhandle = [c for c in family(lgrp) if "LLS_LIGHT_HANDLE" in c.name][0]
+    ladvanced_object = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
+    lbasic_object = [c for c in family(lgrp) if "LLS_LIGHT_AREA" in c.name][0]
+
+    lhandle.location.z = light_dict['radius']
+    lhandle.rotation_euler.y = light_dict['rotation']
+
+    actuator.rotation_euler.x = light_dict['position'][0]
+    actuator.rotation_euler.y = light_dict['position'][1]
+    actuator.rotation_euler.z = 0
+
+    lhandle.LLStudio.type = 'BASIC'
+    bpy.context.view_layer.objects.active = lbasic_object
+    lbasic_object.data.LLStudio.color = light_dict['basic']['color']
+    
+    lbasic_object.data.LLStudio.color_saturation = light_dict['basic']['color_saturation']
+    lbasic_object.data.LLStudio.intensity = light_dict['basic']['intensity']
+    lbasic_object.data.size = light_dict['basic']['size']
+    lbasic_object.data.size_y = light_dict['basic']['size_y']
+    
+    lhandle.LLStudio.type = light_dict['type']
+
+    # Advanced
+    ladvanced_object.scale = light_dict['advanced']['scale']
+
+    lhandle.LLStudio.light_name = light_dict['light_name']
+    lhandle.LLStudio.order_index = light_dict['order_index']
+
+    new_mat_nodes = ladvanced_object.material_slots[0].material.node_tree.nodes
+    new_mat_nodes["Group"].inputs[2].default_value = light_dict['advanced']['Texture Switch']
+    new_mat_nodes["Group"].inputs[3].default_value[0] = light_dict['advanced']['Color Overlay'][0]
+    new_mat_nodes["Group"].inputs[3].default_value[1] = light_dict['advanced']['Color Overlay'][1]
+    new_mat_nodes["Group"].inputs[3].default_value[2] = light_dict['advanced']['Color Overlay'][2]
+    new_mat_nodes["Group"].inputs[3].default_value[3] = light_dict['advanced']['Color Overlay'][3]
+    new_mat_nodes["Group"].inputs[4].default_value = light_dict['advanced']['Color Saturation']
+    new_mat_nodes["Group"].inputs[5].default_value = light_dict['advanced']['Intensity']
+    new_mat_nodes["Group"].inputs[6].default_value = light_dict['advanced']['Mask - Gradient Switch']
+    new_mat_nodes["Group"].inputs[7].default_value = light_dict['advanced']['Mask - Gradient Type']
+    new_mat_nodes["Group"].inputs[8].default_value = light_dict['advanced']['Mask - Gradient Amount']
+    new_mat_nodes["Group"].inputs[9].default_value = light_dict['advanced']['Mask - Ring Switch']
+    new_mat_nodes["Group"].inputs[10].default_value = light_dict['advanced']['Mask - Ring Inner Radius']
+    new_mat_nodes["Group"].inputs[11].default_value = light_dict['advanced']['Mask - Ring Outer Radius']
+    new_mat_nodes["Group"].inputs[12].default_value = light_dict['advanced']['Mask - Top to Bottom']
+    new_mat_nodes["Group"].inputs[13].default_value = light_dict['advanced']['Mask - Bottom to Top']
+    new_mat_nodes["Group"].inputs[14].default_value = light_dict['advanced']['Mask - Left to Right']
+    new_mat_nodes["Group"].inputs[15].default_value = light_dict['advanced']['Mask - Right to Left']
+    new_mat_nodes["Group"].inputs[16].default_value = light_dict['advanced']['Mask - Diagonal Top Left']
+    new_mat_nodes["Group"].inputs[17].default_value = light_dict['advanced']['Mask - Diagonal Top Right']
+    new_mat_nodes["Group"].inputs[18].default_value = light_dict['advanced']['Mask - Diagonal Bottom Right']
+    new_mat_nodes["Group"].inputs[19].default_value = light_dict['advanced']['Mask - Diagonal Bottom Left']
+
+    script_file = os.path.realpath(__file__)
+    dir = os.path.dirname(script_file)
+    if os.path.isabs(light_dict['advanced']['tex']):
+        new_mat_nodes["Light Texture"].image.filepath = light_dict['advanced']['tex']
+    else:
+        new_mat_nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light_dict['advanced']['tex'])
+
+
+def convert_old_light(lls_mesh, profile_collection):
+    # Salvage data
+    col = lls_mesh.users_collection[0]
+    '''
+    context = bpy.context
+    objects = [ob for ob in col.objects]
+    light_handle = [ob for ob in objects if ob.name.startswith("LLS_LIGHT.")]
+    if light_handle: light_handle = light_handle[0]
+    family_obs = family(light_handle)
+
+    # old version
+    light = {}
+    mat_nodes = lls_mesh.active_material.node_tree.nodes
+    light['light_name'] = lls_mesh.LLStudio.light_name
+    light['order_index'] = lls_mesh.LLStudio.order_index
+    light['radius'] = lls_mesh.location.x
+    light['position'] = [lls_mesh.parent.rotation_euler.x, lls_mesh.parent.rotation_euler.y]
+    light['rotation'] = lls_mesh.rotation_euler.x
+    light['type'] = 'ADVANCED'
+
+    light['light_name'] = lls_mesh.LLStudio.light_name
+    light['order_index'] = lls_mesh.LLStudio.order_index
+
+    # advanced
+    light['scale'] = [lls_mesh.scale.x, lls_mesh.scale.y, lls_mesh.scale.z]
+    texpath = lls_mesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
+    light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
+
+    light['Texture Switch'] = mat_nodes["Group"].inputs[2].default_value
+    light['Color Overlay'] = [mat_nodes["Group"].inputs[3].default_value[0],
+                            mat_nodes["Group"].inputs[3].default_value[1],
+                            mat_nodes["Group"].inputs[3].default_value[2],
+                            mat_nodes["Group"].inputs[3].default_value[3]]
+    light['Color Saturation'] = mat_nodes["Group"].inputs[4].default_value
+    light['Intensity'] = mat_nodes["Group"].inputs[5].default_value
+    light['Mask - Gradient Switch'] = mat_nodes["Group"].inputs[6].default_value
+    light['Mask - Gradient Type'] = mat_nodes["Group"].inputs[7].default_value
+    light['Mask - Gradient Amount'] = mat_nodes["Group"].inputs[8].default_value
+    light['Mask - Ring Switch'] = mat_nodes["Group"].inputs[9].default_value
+    light['Mask - Ring Inner Radius'] = mat_nodes["Group"].inputs[10].default_value
+    light['Mask - Ring Outer Radius'] = mat_nodes["Group"].inputs[11].default_value
+    light['Mask - Top to Bottom'] = mat_nodes["Group"].inputs[12].default_value
+    light['Mask - Bottom to Top'] = mat_nodes["Group"].inputs[13].default_value
+    light['Mask - Left to Right'] = mat_nodes["Group"].inputs[14].default_value
+    light['Mask - Right to Left'] = mat_nodes["Group"].inputs[15].default_value
+    light['Mask - Diagonal Top Left'] = mat_nodes["Group"].inputs[16].default_value
+    light['Mask - Diagonal Top Right'] = mat_nodes["Group"].inputs[17].default_value
+    light['Mask - Diagonal Bottom Right'] = mat_nodes["Group"].inputs[18].default_value
+    light['Mask - Diagonal Bottom Left'] = mat_nodes["Group"].inputs[19].default_value
+    '''
+
+    light = salvage_data(col)
+    if VERBOSE: print(light)
+
+
+    # Some crucial objects are missing. Delete whole light collection
+    bpy.ops.object.delete_custom({"selected_objects": [lls_mesh,]}, use_global=False, confirm=True)
+    # bpy.ops.object.delete_custom({"active_object": lls_mesh, "object": lls_mesh, "selected_objects": [lls_mesh,]}, use_global=False, confirm=True)
+    # bpy.data.collections.remove(col)
+    # if VERBOSE: traceback.print_exc()
+    # update_light_sets(panel, context, always)
+    # return
+
+    light_from_dict(light, profile_collection)
+
+    '''
+    profile_empty = [ob for ob in profile_collection.objects if ob.name.startswith('LLS_PROFILE')][0]
+    # before
+    A = set(profile_empty.children)
+
+    bpy.ops.scene.add_leomoon_studio_light()
+
+    # after operation
+    B = set(profile_empty.children)
+
+    # whats the difference
+    lgrp = (A ^ B).pop()
+
+    actuator = [c for c in family(lgrp) if "LLS_ROTATION" in c.name][0]
+    lhandle = [c for c in family(lgrp) if "LLS_LIGHT_HANDLE" in c.name][0]
+    ladvanced_object = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
+    lbasic_object = [c for c in family(lgrp) if "LLS_LIGHT_AREA" in c.name][0]
+
+    lhandle.location.z = light['radius']
+    lhandle.rotation_euler.y = light['rotation']
+
+    actuator.rotation_euler.x = light['position'][0]
+    actuator.rotation_euler.y = light['position'][1]
+    actuator.rotation_euler.z = 0
+
+    lhandle.LLStudio.type = 'BASIC'
+    context.view_layer.objects.active = lbasic_object
+    lbasic_object.data.LLStudio.color.r = light['Color Overlay'][0]
+    lbasic_object.data.LLStudio.color.g = light['Color Overlay'][1]
+    lbasic_object.data.LLStudio.color.b = light['Color Overlay'][2]
+    
+    lbasic_object.data.LLStudio.color_saturation = light['Color Saturation']
+    lbasic_object.data.LLStudio.intensity = light['Intensity']
+    lbasic_object.data.size = light['scale'][0] * 9
+    lbasic_object.data.size_y = light['scale'][1] * 9
+    
+    lhandle.LLStudio.type = 'ADVANCED'
+
+    # Advanced
+    ladvanced_object.scale.x = light['scale'][0]
+    ladvanced_object.scale.y = light['scale'][1]
+    ladvanced_object.scale.z = light['scale'][2]
+
+
+    lhandle.LLStudio.light_name = light['light_name']
+    lhandle.LLStudio.order_index = light['order_index']
+
+    new_mat_nodes = ladvanced_object.material_slots[0].material.node_tree.nodes
+    new_mat_nodes["Group"].inputs[2].default_value = light['Texture Switch']
+    new_mat_nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
+    new_mat_nodes["Group"].inputs[3].default_value[1] = light['Color Overlay'][1]
+    new_mat_nodes["Group"].inputs[3].default_value[2] = light['Color Overlay'][2]
+    new_mat_nodes["Group"].inputs[3].default_value[3] = light['Color Overlay'][3]
+    new_mat_nodes["Group"].inputs[4].default_value = light['Color Saturation']
+    new_mat_nodes["Group"].inputs[5].default_value = light['Intensity']
+    new_mat_nodes["Group"].inputs[6].default_value = light['Mask - Gradient Switch']
+    new_mat_nodes["Group"].inputs[7].default_value = light['Mask - Gradient Type']
+    new_mat_nodes["Group"].inputs[8].default_value = light['Mask - Gradient Amount']
+    new_mat_nodes["Group"].inputs[9].default_value = light['Mask - Ring Switch']
+    new_mat_nodes["Group"].inputs[10].default_value = light['Mask - Ring Inner Radius']
+    new_mat_nodes["Group"].inputs[11].default_value = light['Mask - Ring Outer Radius']
+    new_mat_nodes["Group"].inputs[12].default_value = light['Mask - Top to Bottom']
+    new_mat_nodes["Group"].inputs[13].default_value = light['Mask - Bottom to Top']
+    new_mat_nodes["Group"].inputs[14].default_value = light['Mask - Left to Right']
+    new_mat_nodes["Group"].inputs[15].default_value = light['Mask - Right to Left']
+    new_mat_nodes["Group"].inputs[16].default_value = light['Mask - Diagonal Top Left']
+    new_mat_nodes["Group"].inputs[17].default_value = light['Mask - Diagonal Top Right']
+    new_mat_nodes["Group"].inputs[18].default_value = light['Mask - Diagonal Bottom Right']
+    new_mat_nodes["Group"].inputs[19].default_value = light['Mask - Diagonal Bottom Left']
+
+    # new_mat_nodes["Group"].inputs[3].default_value = light['Opacity']
+    # new_mat_nodes["Group"].inputs[4].default_value = light['Falloff']
+    # new_mat_nodes["Group"].inputs[5].default_value = light['Color Saturation']
+    # new_mat_nodes["Group"].inputs[6].default_value = light['Half']
+
+    script_file = os.path.realpath(__file__)
+    dir = os.path.dirname(script_file)
+    if os.path.isabs(light['tex']):
+        new_mat_nodes["Light Texture"].image.filepath = light['tex']
+    else:
+        new_mat_nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
+    '''
\ No newline at end of file
diff --git a/light_list.py b/light_list.py
index cbd8b0b..2f494f9 100644
--- a/light_list.py
+++ b/light_list.py
@@ -6,6 +6,7 @@ from itertools import chain
 from . operators import modal
 from . operators.modal import close_control_panel, update_light_sets
 from . operators.modal_utils import send_light_to_top, LightImage
+from . light_data import *
 
 _ = os.sep
 
@@ -14,16 +15,16 @@ class LightListItem(bpy.types.PropertyGroup):
     def update_name(self, context):
         name = self.name
         if self.name == '':
-            name = self.mesh_name
+            name = self.handle_name
             self.name = name
-        bpy.data.objects[self.mesh_name].LLStudio.light_name = name
+        bpy.data.objects[self.handle_name].LLStudio.light_name = name
 
     name: StringProperty(
             name="Profile Name",
             default="Untitled",
             update=update_name)
-
-    mesh_name: StringProperty(
+    
+    handle_name: StringProperty(
             description="",
             default="")
 
@@ -31,12 +32,12 @@ class LLS_UL_LightList(bpy.types.UIList):
     def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
         custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.LLStudio.list_index else 'LIGHT'
 
-        if item.mesh_name in context.scene.objects:
+        if item.handle_name in context.scene.objects:
             # Make sure your code supports all 3 layout types
             if self.layout_type in {'DEFAULT', 'COMPACT'}:
                 layout.prop(item, 'name', text='', emboss=False, translate=False)
 
-                mesh_object = context.scene.objects[item.mesh_name]
+                mesh_object = context.scene.objects[item.handle_name]
                 mesh_collection = get_collection(mesh_object)
 
                 view_layer = find_view_layer(mesh_collection, context.view_layer.layer_collection)
@@ -47,9 +48,9 @@ class LLS_UL_LightList(bpy.types.UIList):
                 props = context.scene.LLStudio
                 excluded=0
                 for li in props.light_list:
-                    if not li.mesh_name in context.scene.objects:
+                    if not li.handle_name in context.scene.objects:
                         continue
-                    mesh_object = context.scene.objects[li.mesh_name]
+                    mesh_object = context.scene.objects[li.handle_name]
                     mesh_collection = get_collection(mesh_object)
                     vl = find_view_layer(mesh_collection, context.view_layer.layer_collection)
                     excluded += vl.exclude
@@ -65,21 +66,55 @@ def get_list_index(self):
     ob = bpy.context.view_layer.objects.active
     if isFamily(ob):
         for i, li in enumerate(self.light_list):
-            if li.mesh_name == ob.name:
+            if li.handle_name == ob.parent.name:
                 return i
     return -1
 
 def set_list_index(self, index):
     selected_light = self.light_list[index]
-    ob = bpy.context.scene.objects[selected_light.mesh_name]       # Get the object
+    light_handle = bpy.context.scene.objects[selected_light.handle_name]       # Get the object
+
+    light_collection = light_handle.users_collection[0]
+    light_layer = find_view_layer(light_collection, bpy.context.view_layer.layer_collection)
+    if light_layer.exclude:
+        return
+    
     bpy.ops.object.select_all(action='DESELECT') # Deselect all objects
-    if ob.name in bpy.context.view_layer.objects:
-        bpy.context.view_layer.objects.active = ob
-        ob.select_set(True)
 
-    if modal.running_modals:
-        light_icon = [l for l in LightImage.lights if l._lls_mesh == ob][0]
-        send_light_to_top(light_icon)
+    try:
+        basic_light_collection = [c for c in light_collection.children if c.name.startswith('LLS_Basic')][0]
+        basic_light_layer = find_view_layer(basic_light_collection, bpy.context.view_layer.layer_collection)
+
+        advanced_light_collection = [c for c in light_collection.children if c.name.startswith('LLS_Advanced')][0]
+        advanced_light_layer = find_view_layer(advanced_light_collection, bpy.context.view_layer.layer_collection)
+
+        if basic_light_layer.exclude + advanced_light_layer.exclude != 1:
+            advanced_light_layer.exclude = False
+            basic_light_layer.exclude = True
+
+        if not basic_light_layer.exclude:
+            light_object = basic_light_collection.objects[0]
+        elif not advanced_light_layer.exclude:
+            light_object = advanced_light_collection.objects[0]
+
+
+        if light_object.name in bpy.context.view_layer.objects:
+            bpy.context.view_layer.objects.active = light_object
+            light_object.select_set(True)
+
+        if modal.running_modals:
+            light_icon = [l for l in LightImage.lights if l._lls_handle == light_object.parent][0]
+            send_light_to_top(light_icon)
+    except IndexError:
+        print("Malformed light. Trying to fix.")
+        light = salvage_data(light_collection)
+        light_root = light_handle.parent.parent
+        profile_collection = light_root.parent.users_collection[0]
+        family_obs = family(light_root)
+        bpy.ops.object.delete({"selected_objects": list(family_obs)}, use_global=True)
+        bpy.data.collections.remove(light_collection)
+        light_from_dict(light, profile_collection)
+
 
 def update_light_list_set(context):
     '''Update light list set. Use when the light list needs to be synced with real object hierarchy. '''
@@ -89,13 +124,28 @@ def update_light_list_set(context):
         props.light_list.clear()
 
         lls_lights = set(profile_collection.children)
-        lights = [m for col in lls_lights for m in col.objects if m.name.startswith("LLS_LIGHT_MESH")]
+        
+        lights = [m for col in lls_lights for m in col.objects if m.name.startswith("LLS_LIGHT_HANDLE")]
         lights.sort(key= lambda m: m.LLStudio.order_index)
-        for i, lls_mesh in enumerate(lights):
-            lls_mesh.LLStudio.order_index = i
+        for i, lls_handle in enumerate(lights):
+            lls_handle.LLStudio.order_index = i
             ll = props.light_list.add()
-            ll.mesh_name = lls_mesh.name
-            ll.name = lls_mesh.LLStudio.light_name if lls_mesh.LLStudio.light_name else lls_mesh.name
+            ll.handle_name = lls_handle.name
+            ll.name = lls_handle.LLStudio.light_name if lls_handle.LLStudio.light_name else f"Light {lls_handle.LLStudio.order_index}"
+
+            view_layer = find_view_layer(lls_handle.users_collection[0], context.view_layer.layer_collection)
+            visible_lights = [c for c in lls_handle.children if c.visible_get()]
+            if len(visible_lights) == 1 and not view_layer.exclude:
+                light_object = visible_lights[0]
+                real_light_type = 'ADVANCED' if light_object.type == 'MESH' else 'BASIC'
+                if real_light_type != lls_handle.LLStudio.type:
+                    lls_handle.LLStudio.type = lls_handle.LLStudio.type
+            else:
+                if not view_layer.exclude:
+                    lls_handle.LLStudio.type = lls_handle.LLStudio.type
+                else:
+                    for vl in view_layer.children:
+                        vl.exclude = True
 
 class LLS_OT_MuteToggle(bpy.types.Operator):
     bl_idname = "light_studio.mute_toggle"
@@ -110,12 +160,15 @@ class LLS_OT_MuteToggle(bpy.types.Operator):
 
     def execute(self, context):
         props = context.scene.LLStudio
-        mesh_name = props.light_list[self.index].mesh_name
-        mesh_object = context.scene.objects[mesh_name]
-        mesh_collection = get_collection(mesh_object)
+        handle_name = props.light_list[self.index].handle_name
+        light_handle = context.scene.objects[handle_name]
+        light_collection = get_collection(light_handle)
 
-        view_layer = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+        view_layer = find_view_layer(light_collection, context.view_layer.layer_collection)
         view_layer.exclude = not view_layer.exclude
+
+        if not view_layer.exclude:
+            light_handle.LLStudio.type = light_handle.LLStudio.type
         return {"FINISHED"}
 
 class LLS_OT_Isolate(bpy.types.Operator):
@@ -131,28 +184,34 @@ class LLS_OT_Isolate(bpy.types.Operator):
 
     def execute(self, context):
         props = context.scene.LLStudio
-        mesh_name = props.light_list[self.index].mesh_name
-        mesh_object = context.scene.objects[mesh_name]
-        mesh_collection = get_collection(mesh_object)
-        view_layer = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+        handle_name = props.light_list[self.index].handle_name
+        light_handle = context.scene.objects[handle_name]
+        light_collection = get_collection(light_handle)
+        view_layer = find_view_layer(light_collection, context.view_layer.layer_collection)
         
         view_layers=[]
         excluded=0
         for li in props.light_list:
-            mesh_object = context.scene.objects[li.mesh_name]
-            mesh_collection = get_collection(mesh_object)
+            lls_handle = context.scene.objects[li.handle_name]
+            light_collection = get_collection(lls_handle)
 
-            vl = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+            vl = find_view_layer(light_collection, context.view_layer.layer_collection)
             view_layers.append(vl)
             excluded += vl.exclude
+        print([v.name for v in view_layers])
 
         if not view_layer.exclude and excluded == len(view_layers)-1:
             for v in view_layers:
                 v.exclude = False
+                lls_handle = v.children[0].collection.objects[0].parent
+                lls_handle.LLStudio.type = lls_handle.LLStudio.type
         else:
             for v in view_layers:
-                v.exclude = True
+                if not v.exclude:
+                    # Do not set exclude=True twice because it propagates to children.
+                    v.exclude = True
             view_layer.exclude = False
+            light_handle.LLStudio.type = light_handle.LLStudio.type
 
         return {"FINISHED"}
 
@@ -186,8 +245,8 @@ class LLS_OT_LightListMoveItem(bpy.types.Operator):
             return{'CANCELLED'}
 
         for i, e in enumerate(list):
-            if e.mesh_name in bpy.data.objects:
-                bpy.data.objects[e.mesh_name].LLStudio.order_index = i
+            if e.handle_name in bpy.data.objects:
+                bpy.data.objects[e.handle_name].LLStudio.order_index = i
 
         return{'FINISHED'}
 
@@ -204,35 +263,91 @@ class LIST_OT_LightListCopyItem(bpy.types.Operator):
                context.mode == 'OBJECT' and \
                context.scene.LLStudio.initialized and \
                light and \
-               light.name.startswith('LLS_LIGHT')
+               light.name.startswith('LLS_LIGHT_')
 
     def execute(self, context):
         props = context.scene.LLStudio
         list = props.profile_list
 
+        light_handle = context.object.parent
+        visible_lights = [c for c in light_handle.children if c.visible_get()]
+        if len(visible_lights) != 1:
+            visible_light_object = light_handle.children[0]
+        else:
+            visible_light_object = visible_lights[0]
+
 
         lls_collection, profile_collection = llscol_profilecol(context)
-        lls_mesh = context.object
-        lcol = [c for c in lls_mesh.users_collection if c.name.startswith('LLS_Light')]
+        lls_handle = context.object.parent
+        lcol = [c for c in lls_handle.users_collection if c.name.startswith('LLS_Light')]
         
         if not lcol:
             return{'CANCELLED'}
         
         lcol = lcol[0]
         light_copy = duplicate_collection(lcol, profile_collection)
-        lls_mesh_copy = [lm for lm in light_copy.objects if lm.name.startswith('LLS_LIGHT_MESH')][0] # original light mesh exists so no checks necessary
-        lls_mesh_copy.LLStudio.light_name += " Copy"
-        lls_mesh_copy.LLStudio.order_index += 1
+        lls_handle_copy = [lm for lm in light_copy.objects if lm.name.startswith('LLS_LIGHT_HANDLE')][0] # original light mesh exists so no checks necessary
+        lls_handle_copy.LLStudio.light_name = lls_handle.LLStudio.light_name if lls_handle.LLStudio.light_name else f"Light {lls_handle.LLStudio.order_index}"
+        lls_handle_copy.LLStudio.light_name += " Copy"
+        lls_handle_copy.LLStudio.order_index += 1
 
         # place copied profile next to source profile
-        for e in props.light_list[lls_mesh.LLStudio.order_index + 1 : ]:
-            bpy.data.objects[e.mesh_name].LLStudio.order_index += 1
+        for e in props.light_list[lls_handle.LLStudio.order_index + 1 : ]:
+            bpy.data.objects[e.handle_name].LLStudio.order_index += 1
+
+        
+        
+        # basic_col_copy = [l.users_collection[0] for l in lls_handle_copy.children if l.type == 'LIGHT'][0]
+        # advanced_col_copy = [l.users_collection[0] for l in lls_handle_copy.children if l.type == 'MESH'][0]
+
+        # basic_view_copy = find_view_layer(basic_col_copy, bpy.context.view_layer.layer_collection)
+        # advanced_view_copy = find_view_layer(advanced_col_copy, bpy.context.view_layer.layer_collection)
+
+        # if visible_light_object.type == 'MESH':
+        #     advanced_view_copy.exclude = False
+        #     basic_view_copy.exclude = True
+        # else:
+        #     advanced_view_copy.exclude = True
+        #     basic_view_copy.exclude = False
 
         update_light_list_set(context)
+        
+        light_object = [obj for obj in lls_handle_copy.children if obj.visible_get()][0]
+        bpy.context.view_layer.objects.active = light_object
+        light_object.select_set(True)
 
         if modal.panel_global:
             update_light_sets(modal.panel_global, context, always=True)
-            light_icon = [l for l in LightImage.lights if l._lls_mesh == lls_mesh][0]
+            light_icon = [l for l in LightImage.lights if l._lls_handle == lls_handle][0]
             send_light_to_top(light_icon)
 
-        return{'FINISHED'}
\ No newline at end of file
+        return{'FINISHED'}
+
+from bpy.app.handlers import persistent
+@persistent
+def load_post(scene):
+    context = bpy.context
+    props = bpy.context.scene.LLStudio
+    
+    if not props.initialized:
+        return
+
+    lls_collection, profile_collection = llscol_profilecol(context)
+
+    if profile_collection is None:
+        return
+
+    # props.light_list.clear()
+
+    lls_lights = set(profile_collection.children)
+    
+    lights = [m for col in lls_lights for m in col.objects if m.name.startswith("LLS_LIGHT_MESH")]
+    for i, lls_mesh in enumerate(lights):
+        convert_old_light(lls_mesh, profile_collection)
+    update_light_list_set(bpy.context)
+
+def register():
+    bpy.app.handlers.load_post.append(load_post)
+
+def unregister():
+    bpy.app.handlers.load_post.remove(load_post)
\ No newline at end of file
diff --git a/light_operators.py b/light_operators.py
index 7d190ca..baef42e 100644
--- a/light_operators.py
+++ b/light_operators.py
@@ -1,10 +1,13 @@
 import bpy
-from bpy.props import BoolProperty, PointerProperty, FloatProperty, CollectionProperty, IntProperty, StringProperty
+from bpy.props import BoolProperty, PointerProperty, FloatProperty, CollectionProperty, IntProperty, StringProperty, EnumProperty, FloatVectorProperty
+from mathutils import Vector
 from . light_profiles import ListItem, update_list_index
 from . common import *
 import os
 from . import operators
 from . import light_list
+from . operators import VERBOSE
+from . light_data import *
 
 _ = os.sep
 
@@ -21,9 +24,129 @@ class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
     light_list: CollectionProperty(type = light_list.LightListItem)
     light_list_index: IntProperty(name = "Index for light_list", default = 0, get=light_list.get_list_index, set=light_list.set_list_index)
 
+    # def active_light_type_get(self):
+    #     light_handle = bpy.context.object.parent
+    #     visible_lights = [c for c in light_handle.children if c.visible_get()]
+    #     if len(visible_lights) != 1:
+    #         # TODO: fix it
+    #         return 0
+    #     light_object = visible_lights[0]
+    #     if light_object.type == 'MESH':
+    #         return 0
+    #     else:
+    #         return 1
+    
+    # def active_light_type_set(self, value):
+    #     light_handle = bpy.context.object.parent
+    #     basic_col = [l.users_collection[0] for l in light_handle.children if l.type == 'LIGHT'][0]
+    #     advanced_col = [l.users_collection[0] for l in light_handle.children if l.type == 'MESH'][0]
+
+    #     basic_view = find_view_layer(basic_col, bpy.context.view_layer.layer_collection)
+    #     advanced_view = find_view_layer(advanced_col, bpy.context.view_layer.layer_collection)
+
+    #     if value == 0:
+    #         # ADVANCED
+    #         basic_view.exclude = True
+    #         advanced_view.exclude = False
+    #         bpy.context.view_layer.objects.active = advanced_col.objects[0]
+    #     elif value == 1:
+    #         # BASIC
+    #         basic_view.exclude = False
+    #         advanced_view.exclude = True
+    #         bpy.context.view_layer.objects.active = basic_col.objects[0]
+
+
+    # active_light_type: EnumProperty(
+    #     name="Light Type",
+    #     items=(
+    #         ('ADVANCED', "Advanced", "Cycles only"),
+    #         ('BASIC', "Basic", "Cycles & EEVEE"),
+    #     ),
+    #     default='ADVANCED',
+    #     get=active_light_type_get,
+    #     set=active_light_type_set,
+    # )
+
 class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
     light_name: StringProperty()
     order_index: IntProperty()
+    
+    def active_light_type_update(self, context):
+        # if not context.object:
+        #     light_handle = bpy.data.objects[context.scene.LLStudio.light_list[self.order_index].handle_name]
+        #     print(light_handle)
+        # else:
+        #     light_handle = context.object.parent
+        light_handle = bpy.data.objects[context.scene.LLStudio.light_list[self.order_index].handle_name]
+        try:
+            basic_col = [l.users_collection[0] for l in light_handle.children if l.type == 'LIGHT'][0]
+            advanced_col = [l.users_collection[0] for l in light_handle.children if l.type == 'MESH'][0]
+
+            basic_view = find_view_layer(basic_col, context.view_layer.layer_collection)
+            advanced_view = find_view_layer(advanced_col, context.view_layer.layer_collection)
+            if self.type == 'ADVANCED':
+                # ADVANCED
+                basic_view.exclude = True
+                advanced_view.exclude = False
+                bpy.context.view_layer.objects.active = advanced_col.objects[0]
+            elif self.type == 'BASIC':
+                # BASIC
+                basic_view.exclude = False
+                advanced_view.exclude = True
+                bpy.context.view_layer.objects.active = basic_col.objects[0]
+        except IndexError:
+            lls_col = light_handle.users_collection[0]
+            light = salvage_data(lls_col)
+            light_root = light_handle.parent.parent
+            profile_collection = light_root.parent.users_collection[0]
+            family_obs = family(light_root)
+            bpy.ops.object.delete({"selected_objects": list(family_obs)}, use_global=True)
+            bpy.data.collections.remove(lls_col)
+            light_from_dict(light, profile_collection)
+    
+    type: EnumProperty(
+        name="Light Type",
+        items=(
+            ('ADVANCED', "Advanced", "Cycles only"),
+            ('BASIC', "Basic", "Cycles & EEVEE"),
+        ),
+        default='ADVANCED',
+        update=active_light_type_update,
+    ) 
+
+class LeoMoon_Light_Studio_Light_Properties(bpy.types.PropertyGroup):
+    def color_update(self, context):
+        bpy.context.object.data.color = Vector((1,1,1)).lerp(Vector(self.color), self.color_saturation)
+
+    color: FloatVectorProperty(
+        name="Color",
+        subtype="COLOR",
+        default=(1,1,1),
+        size=3,
+        soft_min=0,
+        soft_max=1,
+        update=color_update,
+    )
+    color_saturation: FloatProperty(
+        name="Color Saturation",
+        min=0,
+        max=1,
+        update=color_update,
+    )
+
+    def light_power_formula(self, context):
+        try:
+            bpy.context.object.data.energy = self.intensity * context.object.data.size * context.object.data.size_y * 250
+        except:
+            bpy.context.object.data.energy = self.intensity
+
+    intensity: FloatProperty(
+        name="Intensity",
+        soft_min=0,
+        soft_max=10000,
+        default=2,
+        update=light_power_formula,
+    )
 
 class CreateBlenderLightStudio(bpy.types.Operator):
     bl_idname = "scene.create_leomoon_light_studio"
@@ -39,8 +162,8 @@ class CreateBlenderLightStudio(bpy.types.Operator):
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
 
-        bpy.ops.wm.append(filepath=_+'LLS3.blend'+_+'Collection'+_,
-        directory=os.path.join(dir,"LLS3.blend"+_+"Collection"+_),
+        bpy.ops.wm.append(filepath=_+'LLS4.blend'+_+'Collection'+_,
+        directory=os.path.join(dir,"LLS4.blend"+_+"Collection"+_),
         filename="LLS",
         active_collection=False)
 
@@ -132,7 +255,8 @@ class AddBSLight(bpy.types.Operator):
 
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
+        return context.scene.LLStudio.initialized
+        # return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
 
     def execute(self, context):
         script_file = os.path.realpath(__file__)
@@ -141,7 +265,7 @@ class AddBSLight(bpy.types.Operator):
         scene = context.scene
         lls_collection, profile_collection, profile, handle = llscol_profilecol_profile_handle(context)
 
-        filepath = os.path.join(dir,"LLS3.blend")
+        filepath = os.path.join(dir,"LLS4.blend")
         # load a single scene we know the name of.
         with bpy.data.libraries.load(filepath) as (data_from, data_to):
             data_to.collections = ["LLS_Light"]
@@ -149,22 +273,45 @@ class AddBSLight(bpy.types.Operator):
         for collection in data_to.collections:
             if collection is not None:
                 profile_collection.children.link(collection)
-                new_objects = collection.objects
+
+                advanced_light_collection = [c for c in collection.children if c.name.startswith('LLS_Advanced')][0]
+                basic_light_collection = [c for c in collection.children if c.name.startswith('LLS_Basic')][0]
+                
+                new_objects = collection.objects[:]
+                # new_objects += [ob for col in collection.children for ob in col.objects]
+                new_objects += advanced_light_collection.objects[:]
+                new_objects += basic_light_collection.objects[:]
                 for ob in new_objects:
                     ob.use_fake_user = True
 
-                llslight = [l for l in new_objects if l.name.startswith('LLS_LIGHT')][0]
+                llslight = [l for l in new_objects if l.name.startswith('LLS_LIGHT.')][0]
                 llslight.parent = profile
 
                 bpy.ops.object.select_all(action='DESELECT')
-                light = [p for p in new_objects if p.name.startswith('LLS_LIGHT_MESH')][0]
-                light.select_set(True)
-                context.view_layer.objects.active = light
-                light.LLStudio.order_index = len(context.scene.LLStudio.light_list)
+                # light = [p for p in new_objects if p.name.startswith('LLS_LIGHT_MESH')][0]
+                # light.select_set(True)
+                # context.view_layer.objects.active = light
+
+                light_handle = [p for p in new_objects if p.name.startswith('LLS_LIGHT_HANDLE')][0]
+                light_handle.LLStudio.order_index = len(context.scene.LLStudio.light_list)
+
+                basic_light_layer = find_view_layer(basic_light_collection, context.view_layer.layer_collection)
+                advanced_light_layer = find_view_layer(advanced_light_collection, context.view_layer.layer_collection)
+                if context.scene.render.engine == "BLENDER_EEVEE":
+                    basic_light_layer.exclude = False
+                    advanced_light_layer.exclude = True
+                else:
+                    basic_light_layer.exclude = True
+                    advanced_light_layer.exclude = False
+
+                light = advanced_light_layer.collection.objects[0]
+                # light.LLStudio.order_index = len(context.scene.LLStudio.light_list)
+
+
 
         #####
 
-        c = light.constraints.new('COPY_LOCATION')
+        c = light_handle.constraints.new('COPY_LOCATION')
         c.target = handle
         c.use_x = True
         c.use_y = True
@@ -184,9 +331,12 @@ class DeleteBSLight(bpy.types.Operator):
     bl_description = "Delete selected light from studio"
     bl_options = {"REGISTER", "UNDO"}
 
+    confirm: BoolProperty(default=True)
     @classmethod
     def poll(cls, context):
         light = context.active_object
+        if not context.area:
+            return True
         return context.area.type == 'VIEW_3D' and \
                context.mode == 'OBJECT' and \
                context.scene.LLStudio.initialized and \
@@ -197,10 +347,13 @@ class DeleteBSLight(bpy.types.Operator):
         scene = context.scene
         light = context.object
 
-        for collection in light.users_collection:
-            if collection.name.startswith('LLS_Light'):
-                bpy.ops.object.delete({"selected_objects": collection.objects}, use_global=True)
-                bpy.data.collections.remove(collection)
+        lls_light = findLightGrp(light)
+        lls_light_collection = lls_light.users_collection[0]
+        col_to_remove = [lls_light_collection,]+ lls_light_collection.children[:]
+        if lls_light_collection.name.startswith('LLS_Light'):
+            bpy.ops.object.delete({"selected_objects": family(lls_light)}, use_global=True)
+            for col in col_to_remove:
+                bpy.data.collections.remove(col)
 
         operators.update()
         light_list.update_light_list_set(context)
@@ -209,7 +362,10 @@ class DeleteBSLight(bpy.types.Operator):
 
     def invoke(self, context, event):
         wm = context.window_manager
-        return wm.invoke_props_dialog(self)
+        if self.confirm:
+            return wm.invoke_props_dialog(self)
+        else:
+            return self.execute(context)
 
     def draw(self, context):
         layout = self.layout
diff --git a/light_profiles.py b/light_profiles.py
index 297bef4..9834734 100644
--- a/light_profiles.py
+++ b/light_profiles.py
@@ -2,6 +2,7 @@ import bpy
 from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProperty, EnumProperty
 import os, sys, subprocess
 from . common import *
+from . light_data import *
 from itertools import chain
 from . operators.modal import close_control_panel
 from . import light_list
@@ -58,8 +59,8 @@ class LIST_OT_NewItem(bpy.types.Operator):
 
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
-        bpy.ops.wm.append(filepath=_+'LLS3.blend'+_+'Object'+_,
-            directory=os.path.join(dir,"LLS3.blend"+_+"Object"+_),
+        bpy.ops.wm.append(filepath=_+'LLS4.blend'+_+'Object'+_,
+            directory=os.path.join(dir,"LLS4.blend"+_+"Object"+_),
             filename="LLS_PROFILE.000",
             active_collection=True)
 
@@ -256,8 +257,8 @@ def update_list_index(self, context):
 import json, time
 script_file = os.path.realpath(__file__)
 dir = os.path.dirname(script_file)
-
-VERSION = 2.01
+VERSION = 3
+from . import light_operators
 def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
     plist = props.profile_list
     for profile in profiles:
@@ -272,12 +273,13 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
         profile_empty = context.scene.objects[plist[-1].empty_name]
 
         if version > 1:
-            handle = getLightHandle(profile_empty)
+            handle = getProfileHandle(profile_empty)
             handle.location.x = profile['handle_position'][0]
             handle.location.y = profile['handle_position'][1]
             handle.location.z = profile['handle_position'][2]
 
         for light in profile["lights"]:
+            '''
             # before
             A = set(profile_empty.children)
 
@@ -290,55 +292,79 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             lgrp = (A ^ B).pop()
 
             actuator = [c for c in family(lgrp) if "LLS_ROTATION" in c.name][0]
-            lmesh = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
-            lmesh.location.x = light['radius']
+            lhandle = [c for c in family(lgrp) if "LLS_LIGHT_HANDLE" in c.name][0]
+            ladvanced_object = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
+            lbasic_object = [c for c in family(lgrp) if "LLS_LIGHT_AREA" in c.name][0]
+
+            lhandle.location.z = light['radius']
+            lhandle.rotation_euler.y = light['rotation']
 
             actuator.rotation_euler.x = light['position'][0]
             actuator.rotation_euler.y = light['position'][1]
             actuator.rotation_euler.z = 0
 
-            lmesh.scale.x = light['scale'][0]
-            lmesh.scale.y = light['scale'][1]
-            lmesh.scale.z = light['scale'][2]
+            # Basic
+            # Set basic area light as visible to change properties. Another way: move area light properties from Light to Object type
+            lhandle.LLStudio.type = 'BASIC'
+            context.view_layer.objects.active = lbasic_object
+            lbasic_object.data.LLStudio.color.r = light['basic']['color'][0]
+            lbasic_object.data.LLStudio.color.g = light['basic']['color'][1]
+            lbasic_object.data.LLStudio.color.b = light['basic']['color'][2]
+            
+            lbasic_object.data.LLStudio.color_saturation = light['basic']['color_saturation']
+            lbasic_object.data.LLStudio.intensity = light['basic']['intensity']
+            lbasic_object.data.size = light['basic']['size']
+            lbasic_object.data.size_y = light['basic']['size_y']
+            
+            lhandle.LLStudio.type = light['type']
+            
+            # Advanced
+            ladvanced_object.scale.x = light['advanced']['scale'][0]
+            ladvanced_object.scale.y = light['advanced']['scale'][1]
+            ladvanced_object.scale.z = light['advanced']['scale'][2]
 
-            lmesh.rotation_euler.x = light['rotation']
 
             if 'light_name' in light:
-                lmesh.LLStudio.light_name = light['light_name']
+                lhandle.LLStudio.light_name = light['light_name']
             if 'order_index' in light:
-                lmesh.LLStudio.order_index = light['order_index']
-
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['Texture Switch']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1] = light['Color Overlay'][1]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2] = light['Color Overlay'][2]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3] = light['Color Overlay'][3]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Color Saturation']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Intensity']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Mask - Gradient Switch']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value = light['Mask - Gradient Type']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value = light['Mask - Gradient Amount']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value = light['Mask - Ring Switch']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value = light['Mask - Ring Inner Radius']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value = light['Mask - Ring Outer Radius']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value = light['Mask - Top to Bottom']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value = light['Mask - Bottom to Top']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value = light['Mask - Left to Right']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value = light['Mask - Right to Left']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value = light['Mask - Diagonal Top Left']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value = light['Mask - Diagonal Top Right']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value = light['Mask - Diagonal Bottom Right']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value = light['Mask - Diagonal Bottom Left']
-
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
-
-            if os.path.isabs(light['tex']):
-                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
+                lhandle.LLStudio.order_index = light['order_index']
+
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['advanced']['Texture Switch']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['advanced']['Color Overlay'][0]
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1] = light['advanced']['Color Overlay'][1]
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2] = light['advanced']['Color Overlay'][2]
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3] = light['advanced']['Color Overlay'][3]
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['advanced']['Color Saturation']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['advanced']['Intensity']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['advanced']['Mask - Gradient Switch']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value = light['advanced']['Mask - Gradient Type']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value = light['advanced']['Mask - Gradient Amount']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value = light['advanced']['Mask - Ring Switch']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value = light['advanced']['Mask - Ring Inner Radius']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value = light['advanced']['Mask - Ring Outer Radius']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value = light['advanced']['Mask - Top to Bottom']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value = light['advanced']['Mask - Bottom to Top']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value = light['advanced']['Mask - Left to Right']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value = light['advanced']['Mask - Right to Left']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value = light['advanced']['Mask - Diagonal Top Left']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value = light['advanced']['Mask - Diagonal Top Right']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value = light['advanced']['Mask - Diagonal Bottom Right']
+            ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value = light['advanced']['Mask - Diagonal Bottom Left']
+
+            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value = light['advanced']['Opacity']
+            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['advanced']['Falloff']
+            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['advanced']['Color Saturation']
+            # ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['advanced']['Half']
+
+            if os.path.isabs(light['advanced']['tex']):
+                ladvanced_object.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = light['advanced']['tex']
             else:
-                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
+                ladvanced_object.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['advanced']['tex'])
+            '''
+            if version < 3:
+                # most of light settings are moved to advanced sub dict. copy whole dict for the simplicity sake
+                light['advanced'] = light.copy()
+            light_operators.light_from_dict(light, profile_empty.users_collection[0])
 
 class ImportProfiles(bpy.types.Operator):
 
@@ -370,6 +396,7 @@ class ImportProfiles(bpy.types.Operator):
         context.window_manager.fileselect_add(self)
         return {'RUNNING_MODAL'}
 
+
 def compose_profile(list_index):
     props = bpy.context.scene.LLStudio
     profile_dict = {}
@@ -377,54 +404,70 @@ def compose_profile(list_index):
     profile_dict['lights']= []
     profile = bpy.data.objects[props.profile_list[list_index].empty_name]
     profile_collection = get_collection(profile)
-    handle = getLightHandle(profile)
+    handle = getProfileHandle(profile)
     profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
     for light_collection in profile_collection.children:
-        lmesh = [ob for ob in light_collection.objects if ob.name.startswith('LLS_LIGHT_MESH')][0]
+        '''
+        # lmesh = [ob for ob in light_collection.objects if ob.name.startswith('LLS_LIGHT_MESH')][0]
+        lhandle = [ob for ob in light_collection.objects if ob.name.startswith('LLS_LIGHT_HANDLE')][0]
+        ladvanced_object = [ob for ob in lhandle.children if ob.name.startswith('LLS_LIGHT_MESH')][0]
+        lbasic_object = [ob for ob in lhandle.children if ob.name.startswith('LLS_LIGHT_AREA')][0]
+        light = {'advanced': {}, 'basic': {}}
+        light_basic = light['basic']
+        light_advanced = light['advanced']
+
         actuator = [ob for ob in light_collection.objects if ob.name.startswith('LLS_ROTATION')][0]
-        light = {}
-        light['light_name'] = lmesh.LLStudio.light_name
-        light['order_index'] = lmesh.LLStudio.order_index
-        light['radius'] = lmesh.location.x
+        light['light_name'] = lhandle.LLStudio.light_name
+        light['order_index'] = lhandle.LLStudio.order_index
+        light['radius'] = lhandle.location.z
         light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
-        light['scale'] = [lmesh.scale.x, lmesh.scale.y, lmesh.scale.z]
-        light['rotation'] = lmesh.rotation_euler.x
-        # view_layer = find_view_layer(light_collection, bpy.context.view_layer.layer_collection)
-        # light['mute'] = view_layer.exclude
-        texpath = lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
-        light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
-
-        light['Texture Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
-        light['Color Overlay'] = [lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0],
-                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1],
-                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2],
-                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3]]
-        light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
-        light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
-        light['Mask - Gradient Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
-        light['Mask - Gradient Type'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value
-        light['Mask - Gradient Amount'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value
-        light['Mask - Ring Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value
-        light['Mask - Ring Inner Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value
-        light['Mask - Ring Outer Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value
-        light['Mask - Top to Bottom'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value
-        light['Mask - Bottom to Top'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value
-        light['Mask - Left to Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value
-        light['Mask - Right to Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value
-        light['Mask - Diagonal Top Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value
-        light['Mask - Diagonal Top Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value
-        light['Mask - Diagonal Bottom Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value
-        light['Mask - Diagonal Bottom Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value
-
-        # light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
-        # light['Opacity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value
-        # light['Falloff'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
-        # light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
-        # light['Half'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
-
-        profile_dict['lights'].append(light)
+        light['rotation'] = lhandle.rotation_euler.y
+        light['type'] = lhandle.LLStudio.type
+
+        # basic_dict = {k: getattr(lbasic_object.data, k) for k in lbasic_object.data.__dir__() if not k.startswith('_') and type(getattr(lbasic_object.data, k))}# in {float, int, bool, str, Color}
+        # print(basic_dict)
+        
+        light_basic['color'] = [lbasic_object.data.LLStudio.color.r, lbasic_object.data.LLStudio.color.g, lbasic_object.data.LLStudio.color.b]
+        light_basic['color_saturation'] = lbasic_object.data.LLStudio.color_saturation
+        light_basic['intensity'] = lbasic_object.data.LLStudio.intensity
+        light_basic['size'] = lbasic_object.data.size
+        light_basic['size_y'] = lbasic_object.data.size_y
+
+
+        # advanced
+        light_advanced['scale'] = [ladvanced_object.scale.x, ladvanced_object.scale.y, ladvanced_object.scale.z]
+        texpath = ladvanced_object.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
+        light_advanced['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
+
+        light_advanced['Texture Switch'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
+        light_advanced['Color Overlay'] = [ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0],
+                                  ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1],
+                                  ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2],
+                                  ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3]]
+        light_advanced['Color Saturation'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
+        light_advanced['Intensity'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
+        light_advanced['Mask - Gradient Switch'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
+        light_advanced['Mask - Gradient Type'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value
+        light_advanced['Mask - Gradient Amount'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value
+        light_advanced['Mask - Ring Switch'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value
+        light_advanced['Mask - Ring Inner Radius'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value
+        light_advanced['Mask - Ring Outer Radius'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value
+        light_advanced['Mask - Top to Bottom'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value
+        light_advanced['Mask - Bottom to Top'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value
+        light_advanced['Mask - Left to Right'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value
+        light_advanced['Mask - Right to Left'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value
+        light_advanced['Mask - Diagonal Top Left'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value
+        light_advanced['Mask - Diagonal Top Right'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value
+        light_advanced['Mask - Diagonal Bottom Right'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value
+        light_advanced['Mask - Diagonal Bottom Left'] = ladvanced_object.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value
+        '''
+
+        light = salvage_data(light_collection)
+        profile_dict['lights'].append(light.dict)
         profile_dict['lights'].sort(key=lambda x: x["order_index"])
-
+        
+        # import json
+        # print(json.dumps(profile_dict, indent=4, separators=(',', ': ')))
     return profile_dict
 
 class ExportProfiles(bpy.types.Operator):
@@ -538,6 +581,7 @@ class CopyProfileToScene(bpy.types.Operator):
         profiles = [compose_profile(index),]
 
         context.window.scene = bpy.data.scenes[self.sceneprop]
+
         context.scene.render.engine = 'CYCLES'
         if not context.scene.LLStudio.initialized:
             bpy.ops.scene.create_leomoon_light_studio()
diff --git a/operators/__init__.py b/operators/__init__.py
index 954e0e4..dc6d7a9 100644
--- a/operators/__init__.py
+++ b/operators/__init__.py
@@ -12,7 +12,7 @@ def update_clear():
     global UPDATED
     UPDATED = False
 
-VERBOSE = False
+VERBOSE = True
 
 from .. common import isFamily
 class LightOperator:
@@ -24,5 +24,5 @@ class LightOperator:
                context.space_data.type == 'VIEW_3D' and \
                context.scene.LLStudio.initialized and \
                object and \
-               object.name.startswith('LLS_LIGHT_MESH') and \
+               object.name.startswith('LLS_LIGHT_') and \
                isFamily(object)
\ No newline at end of file
diff --git a/operators/modal.py b/operators/modal.py
index 240b1ce..6ee2cdd 100644
--- a/operators/modal.py
+++ b/operators/modal.py
@@ -8,7 +8,7 @@ from .. import light_list
 
 from .modal_utils import shader2Dcolor
 from gpu_extras.batch import batch_for_shader
-import time, traceback
+import time, traceback, os
 from mathutils.geometry import intersect_line_line_2d
 from . import VERBOSE, LightOperator
 
@@ -62,9 +62,9 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
         super().invoke(context, event)
 
         if running_modals:
-            self.base_object_rotation = LightImage.selected_object._lls_mesh.rotation_euler.x
+            self.base_object_rotation = LightImage.selected_object._lls_handle.rotation_euler.y
         else:
-            self.base_object_rotation = context.object.rotation_euler.x
+            self.base_object_rotation = context.object.parent.rotation_euler.y
 
         return {"RUNNING_MODAL"}
     
@@ -75,9 +75,9 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
     def _cancel(self, context, event):
         global running_modals
         if running_modals:
-            LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation
+            LightImage.selected_object._lls_handle.rotation_euler.y = self.base_object_rotation
         else:
-            context.object.rotation_euler.x = self.base_object_rotation
+            context.object.parent.rotation_euler.y = self.base_object_rotation
 
         bpy.context.workspace.status_text_set(None)
         #context.area.header_text_set(text=None)
@@ -85,9 +85,9 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
     def _modal(self, context, event):
         global running_modals
         if running_modals:
-            LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
+            LightImage.selected_object._lls_handle.rotation_euler.y = self.base_object_rotation + self.angle()
         else:
-            context.object.rotation_euler.x = self.base_object_rotation + self.angle()
+            context.object.parent.rotation_euler.y = self.base_object_rotation + self.angle()
 
         bpy.context.workspace.status_text_set(f"Rot: {self.angle():.3f}")
         #context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
@@ -96,6 +96,19 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
             return {"RUNNING_MODAL"}
         return {"PASS_THROUGH"}
 
+def get_scale_adapter(light_object):
+    if light_object.type == 'MESH':
+        return light_object.scale.copy()
+    elif light_object.type == 'LIGHT':
+        return Vector((light_object.data.size / 9, light_object.data.size / 9, light_object.data.size_y / 9))
+
+def set_scale_adapter(light_object, new_scale):
+    if light_object.type == 'MESH':
+        light_object.scale = new_scale
+    elif light_object.type == 'LIGHT':
+        light_object.data.size = new_scale.y * 9
+        light_object.data.size_y = new_scale.z * 9
+
 class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
     bl_idname = "light_studio.scale"
     bl_label = "Scale Light"
@@ -121,17 +134,18 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
         super().invoke(context, event)
         
         if running_modals:
-            self.base_object_scale = LightImage.selected_object._lls_mesh.scale.copy()
+            self.base_object_scale = LightImage.selected_object.light_scale.copy()
         else:
-            self.base_object_scale = context.object.scale.copy()
+            self.base_object_scale = get_scale_adapter(context.object)
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
         global running_modals
         if running_modals:
-            LightImage.selected_object._lls_mesh.scale = self.base_object_scale
+            LightImage.selected_object.light_scale = self.base_object_scale
         else:
-            context.object.scale = self.base_object_scale
+            # context.object.scale = self.base_object_scale
+            set_scale_adapter(context.object, self.base_object_scale)
         bpy.context.workspace.status_text_set(None)
         #context.area.header_text_set(text=None)
 
@@ -148,11 +162,11 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
 
         global running_modals
         if running_modals:
-            LightImage.selected_object._lls_mesh.scale = new_scale
+            LightImage.selected_object.light_scale = new_scale
         else:
-            context.object.scale = new_scale
-        bpy.context.workspace.status_text_set(f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
-        #context.area.header_text_set(text=f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
+            set_scale_adapter(context.object, new_scale)
+        bpy.context.workspace.status_text_set(f"Scale X: {new_scale.y:.3f} Y: {new_scale.z:.3f}  [X/Y] Axis, [Shift] Precision mode")
+        #context.area.header_text_set(text=f"Scale X: {new_scale.y:.3f} Y: {new_scale.z:.3f}  [X/Y] Axis, [Shift] Precision mode")
 
         if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
             return {"RUNNING_MODAL"}
@@ -182,32 +196,31 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
         global running_modals
 
         if running_modals:
-            global panel_global
             # override starting mouse position
+            global panel_global
             self.mouse_x = LightImage.selected_object.loc.x
             self.mouse_y = LightImage.selected_object.loc.y
-            self.light_mesh = LightImage.selected_object._lls_mesh
+            self.light_object = LightImage.selected_object._lls_object
             self.light_actuator = LightImage.selected_object._lls_actuator
             self.base_object_rotation = self.light_actuator.rotation_euler.copy()
-            self.base_object_distance = self.light_mesh.location.x
-            global panel_global
+            self.base_object_distance = self.light_object.location.x
             self.canvas_width = panel_global.width
             self.canvas_height = panel_global.height
         else:
             # override starting mouse position
             self.mouse_x = context.area.width/2
             self.mouse_y = context.area.height/2
-            self.light_actuator = context.object.parent
-            self.light_mesh = context.object
-            self.base_object_rotation = context.object.parent.rotation_euler.copy()
-            self.base_object_distance = context.object.location.x
+            self.light_actuator = context.object.parent.parent
+            self.light_object = context.object.parent
+            self.base_object_rotation = context.object.parent.parent.rotation_euler.copy()
+            self.base_object_distance = context.object.parent.location.x
         super().invoke(context, event)
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
         global running_modals
         self.light_actuator.rotation_euler = self.base_object_rotation
-        self.light_mesh.location.x = self.base_object_distance
+        self.light_object.location.x = self.base_object_distance
         
         global GRABBING
         GRABBING = False
@@ -236,9 +249,9 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
             y_factor = .0025 #pi / 250
 
         if self.z_key:
-            self.light_mesh.location.x = max(self.base_object_distance + dv.x * 0.05, 0)
+            self.light_object.location.x = max(self.base_object_distance + dv.x * 0.05, 0)
             import bpy_extras
-            self.z_start_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, self.light_mesh.matrix_world.to_translation().normalized() * context.space_data.clip_end)
+            self.z_start_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, self.light_object.matrix_world.to_translation().normalized() * context.space_data.clip_end)
             self.z_end_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, Vector((0,0,0)))
             if running_modals:
                 global panel_global
@@ -326,7 +339,8 @@ class LLS_OT_control_panel(bpy.types.Operator):
             if hasattr(self, 'handler'):
                 bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
         except (ValueError, AttributeError):
-            if VERBOSE: traceback.print_exc()
+            # if VERBOSE: traceback.print_exc()
+            pass
 
     def _mouse_event(self, context, event):
         area_mouse_x = event.mouse_x - context.area.x
@@ -648,6 +662,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
             return self.panel
         return None
 
+from .. light_data import salvage_data, convert_old_light, light_from_dict
 def update_light_sets(panel, context, always=False):
     lls_collection, profile_collection = llscol_profilecol(context)
     if profile_collection is not None:
@@ -665,10 +680,28 @@ def update_light_sets(panel, context, always=False):
                 try:
                     LightImage(context, panel, col)
                 except:
+                    # Salvage data
+                    objects = [ob for ob in col.objects]
+                    light_root = [ob for ob in objects if ob.name.startswith("LLS_LIGHT.")]
+                    if light_root:
+                        light_root = light_root[0]
+                        # convert_old_light(light_root, profile_collection)
+
+                    family_obs = family(light_root)
+
+
+                    light = salvage_data(col)
+
                     # Some crucial objects are missing. Delete whole light collection
-                    bpy.ops.object.delete({"selected_objects": col.objects}, use_global=True)
+                    # bpy.ops.object.delete({"selected_objects": col.objects}, use_global=True)
+                    bpy.ops.object.delete({"selected_objects": list(family_obs)}, use_global=True)
                     bpy.data.collections.remove(col)
-                    if VERBOSE: traceback.print_exc()
+                    
+                    # override = context.copy()
+                    # override['selected_objects'] = col.objects
+                    # bpy.ops.object.delete_custom(override, use_global=True)
+
+                    light_from_dict(light, profile_collection)
 
             update_clear()
 
diff --git a/operators/modal_utils.py b/operators/modal_utils.py
index df3eb1c..0a792a8 100644
--- a/operators/modal_utils.py
+++ b/operators/modal_utils.py
@@ -35,6 +35,7 @@ fragment_shader = '''
     layout(location = 0) out vec4 fragColor;
     layout(location = 1) out vec4 trash;
 
+    uniform bool advanced = false;
     uniform sampler2D image;
     uniform vec2 panel_point_lt;
     uniform vec2 panel_point_rb;
@@ -62,69 +63,74 @@ fragment_shader = '''
     void main()
     {
         // Trash output - sum all uniforms to prevent compiler from skipping currently unused ones
-        trash = vec4(panel_point_lt.x+panel_point_rb.x+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
+        trash = vec4(panel_point_lt.x+panel_point_rb.x+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom+int(advanced));
 
-        // Texture Switch + Intensity
-        // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
-        fragColor = mix(vec4(1.0f), texture(image, texCoord_interp), texture_switch) * log(1+intensity);
+        if(advanced){
+            // Texture Switch + Intensity
+            // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
+            fragColor = mix(vec4(1.0f), texture(image, texCoord_interp), texture_switch) * log(1+intensity);
 
-        // Color Overlay
-        float gray = clamp(dot(fragColor.rgb, vec3(0.299, 0.587, 0.114)), 0, 1);
-        vec4 colored = color_overlay * gray;
+            // Color Overlay
+            float gray = clamp(dot(fragColor.rgb, vec3(0.299, 0.587, 0.114)), 0, 1);
+            vec4 colored = color_overlay * gray;
 
-        // Color Saturation
-        fragColor = mix(fragColor, colored, color_saturation);
-        fragColor.a = gray;
-        fragColor.rgb *= fragColor.a;
+            // Color Saturation
+            fragColor = mix(fragColor, colored, color_saturation);
+            fragColor.a = gray;
+            fragColor.rgb *= fragColor.a;
 
-        // MASKS //
+            // MASKS //
 
-        // Vertical gradient + mask_gradient_amount
-        float vg = sqrt(texCoord_interp.y);
-        vg = (texCoord_interp.y <= mask_gradient_amount+.05f) ? mix(0, vg, (texCoord_interp.y-mask_gradient_amount)/.05f) : vg;
-        vg = texCoord_interp.y >= mask_gradient_amount ? vg : 0;
+            // Vertical gradient + mask_gradient_amount
+            float vg = sqrt(texCoord_interp.y);
+            vg = (texCoord_interp.y <= mask_gradient_amount+.05f) ? mix(0, vg, (texCoord_interp.y-mask_gradient_amount)/.05f) : vg;
+            vg = texCoord_interp.y >= mask_gradient_amount ? vg : 0;
 
-        // Spherical gradient + mask_gradient_amount
-        float d = distance(texCoord_interp.xy, vec2(0.5f, 0.5f));
-        float m = (1.0f-mask_gradient_amount)*.5f;
-        float sg = 1-pow(d*2, 2.f);
-        sg = (d >= m-.05f) ? mix(0, sg, (m-d)/.05f) : sg;
-        sg = (d <= m) ? sg : 0;
+            // Spherical gradient + mask_gradient_amount
+            float d = distance(texCoord_interp.xy, vec2(0.5f, 0.5f));
+            float m = (1.0f-mask_gradient_amount)*.5f;
+            float sg = 1-pow(d*2, 2.f);
+            sg = (d >= m-.05f) ? mix(0, sg, (m-d)/.05f) : sg;
+            sg = (d <= m) ? sg : 0;
 
-        // Gradient Type
-        float grad = mix(sg, vg, mask_gradient_type);
+            // Gradient Type
+            float grad = mix(sg, vg, mask_gradient_type);
 
-        // Gradient Switch
-        fragColor.a = mix(fragColor.a, grad*fragColor.a, mask_gradient_switch);
+            // Gradient Switch
+            fragColor.a = mix(fragColor.a, grad*fragColor.a, mask_gradient_switch);
 
-        // Gradient Ring Switch
-        float ring = d < (1-mask_ring_outer_radius)*.575f ? 1 : 0;
-        ring = d < (1-mask_ring_inner_radius)*.55f ? 0 : ring;
-        fragColor.a = mix(fragColor.a, fragColor.a*ring, mask_ring_switch);
+            // Gradient Ring Switch
+            float ring = d < (1-mask_ring_outer_radius)*.575f ? 1 : 0;
+            ring = d < (1-mask_ring_inner_radius)*.55f ? 0 : ring;
+            fragColor.a = mix(fragColor.a, fragColor.a*ring, mask_ring_switch);
 
-        // Top-Bottom
-        fragColor.a = texCoord_interp.y < (1-mask_top_to_bottom) ? fragColor.a : 0;
+            // Top-Bottom
+            fragColor.a = texCoord_interp.y < (1-mask_top_to_bottom) ? fragColor.a : 0;
 
-        // Bottom-Top
-        fragColor.a = texCoord_interp.y > mask_bottom_to_top ? fragColor.a : 0;
+            // Bottom-Top
+            fragColor.a = texCoord_interp.y > mask_bottom_to_top ? fragColor.a : 0;
 
-        // Left-Right
-        fragColor.a = texCoord_interp.x > mask_left_to_right ? fragColor.a : 0;
+            // Left-Right
+            fragColor.a = texCoord_interp.x > mask_left_to_right ? fragColor.a : 0;
 
-        // Right-Left
-        fragColor.a = texCoord_interp.x < (1-mask_right_to_left) ? fragColor.a : 0;
+            // Right-Left
+            fragColor.a = texCoord_interp.x < (1-mask_right_to_left) ? fragColor.a : 0;
 
-        // Diagonal Top-Right
-        fragColor.a = 1-(texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_right ? fragColor.a : 0;
+            // Diagonal Top-Right
+            fragColor.a = 1-(texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_right ? fragColor.a : 0;
 
-        // Diagonal Top-Left
-        fragColor.a = 1-(1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_left ? fragColor.a : 0;
+            // Diagonal Top-Left
+            fragColor.a = 1-(1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_left ? fragColor.a : 0;
 
-        // Diagonal Bottom-Right
-        fragColor.a = (1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_right ? fragColor.a : 0;
+            // Diagonal Bottom-Right
+            fragColor.a = (1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_right ? fragColor.a : 0;
 
-        // Diagonal Bottom-Left
-        fragColor.a = (texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_left ? fragColor.a : 0;
+            // Diagonal Bottom-Left
+            fragColor.a = (texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_left ? fragColor.a : 0;
+        }else{
+            //fragColor = vec4(1.0f);
+            fragColor = mix(vec4(1.0f), color_overlay, color_saturation) * log(1+intensity);
+        }
 
         // Panel bound clipping
         if((gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
@@ -171,6 +177,8 @@ lightIconShader.bind()
 border_shader2Dcolor = gpu.types.GPUShader(border_vertex_shader, border_fragment_shader)
 border_shader2Dcolor.bind()
 
+AREA_DEFAULT_SIZE = 8.91651
+
 class Rectangle:
     def __init__(self, start_point, width, height):
         self.point_lt = Vector((
@@ -469,7 +477,6 @@ class Border(Rectangle):
 
         return super().get_verts()
 
-
 class LightImage(Rectangle):
     selected_object = None
     lights = []
@@ -516,39 +523,73 @@ class LightImage(Rectangle):
         self.panel_loc.y = fmod(self._lls_rot.y + pi/2, pi) / (pi)
 
     def update_from_lls(self):
-        if self._lls_mesh.select_get():
+        if not self._lls_object:
+            return False
+        
+        if self._lls_object.select_get():
             LightImage.selected_object = self
 
         updated = False
         if self._lls_rot != self._lls_actuator.rotation_euler:
             updated |= True
             self._lls_rot = self._lls_actuator.rotation_euler.copy()
-        if self.rot != self._lls_mesh.rotation_euler.x:
+        if self.rot != self._lls_handle.rotation_euler.y:
             updated |= True
-            self.rot = self._lls_mesh.rotation_euler.x
-        if self._scale != self._lls_mesh.scale:
+            self.rot = self._lls_handle.rotation_euler.y
+        if self._scale != self.light_scale:
             updated |= True
-            self._scale = self._lls_mesh.scale.copy()
+            self._scale = self.light_scale.copy()
             self.width = LightImage.default_size * self._scale.y
             self.height = LightImage.default_size * self._scale.z
 
         if updated:
             self._update_panel_loc()
 
-        if self._image_path != self._lls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath:
-            updated |= True
-            self.image = self._lls_mesh.active_material.node_tree.nodes["Light Texture"].image
-            self._image_path = self._lls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath
-        # this should run when image changes but sometimes Blender looses images... so it's run every time to be safe
-        if self.image.gl_load():
-            raise Exception
+        if self._lls_object.type == 'MESH':
+            if self._image_path != self._lls_object.active_material.node_tree.nodes["Light Texture"].image.filepath:
+                updated |= True
+                self.image = self._lls_object.active_material.node_tree.nodes["Light Texture"].image
+                self._image_path = self._lls_object.active_material.node_tree.nodes["Light Texture"].image.filepath
+            # this should run when image changes but sometimes Blender looses images... so it's run every time to be safe
+            if self.image.gl_load():
+                raise Exception
 
 
         return updated
 
     def update_lls(self):
         self._lls_actuator.rotation_euler = self._lls_rot
-        self._lls_mesh.rotation_euler.x = self.rot
+        self._lls_handle.rotation_euler.y = self.rot
+
+    @property
+    def _lls_object(self):
+        type = self._lls_handle.LLStudio.type
+        try:
+            if type == 'ADVANCED':
+                return [ob for ob in self._lls_handle.children if ob.name.startswith("LLS_LIGHT_MESH")][0]
+            elif type == 'BASIC':
+                return [ob for ob in self._lls_handle.children if ob.name.startswith("LLS_LIGHT_AREA")][0]
+        except:
+            # override = {'selected_objects': [self._lls_handle,]}
+            # bpy.ops.scene.delete_leomoon_studio_light(override, confirm=False)
+            raise Exception("Malformed light")
+        return None
+
+    @property
+    def light_scale(self):
+        if self._lls_object.type == 'MESH':
+            return self._lls_object.scale
+        else:
+            return Vector((self._lls_object.data.size / AREA_DEFAULT_SIZE, self._lls_object.data.size_y / AREA_DEFAULT_SIZE, 1))
+    
+    @light_scale.setter
+    def light_scale(self, vec):
+        if self._lls_object.type == 'MESH':
+            self._lls_object.scale = vec
+        else:
+            print(vec)
+            self._lls_object.data.size = vec[1] * AREA_DEFAULT_SIZE
+            self._lls_object.data.size_y = vec[2] * AREA_DEFAULT_SIZE
 
     def __init__(self, context, panel, lls_light_collection):
         self.panel = panel
@@ -556,13 +597,22 @@ class LightImage(Rectangle):
 
         # try:
         self._collection = lls_light_collection
-        self._lls_mesh = [m for m in lls_light_collection.objects if m.name.startswith("LLS_LIGHT_MESH")][0]
-        self._lls_actuator = self._lls_mesh.parent
+        self._lls_handle = [m for m in lls_light_collection.objects if m.name.startswith("LLS_LIGHT_HANDLE")][0]
+        self._lls_actuator = self._lls_object.parent.parent
         self._view_layer = find_view_layer(self._collection, context.view_layer.layer_collection)
+
+        self._lls_basic_collection = [m for m in lls_light_collection.children if m.name.startswith("LLS_Basic")][0]
+        self._lls_advanced_collection = [m for m in lls_light_collection.children if m.name.startswith("LLS_Advanced")][0]
+        self._basic_view_layer = find_view_layer(self._lls_basic_collection, context.view_layer.layer_collection)
+        self._advanced_view_layer = find_view_layer(self._lls_advanced_collection, context.view_layer.layer_collection)
         # except Exception:
         #     raise Exception
 
-        self._image_path = ""
+
+        # self._image_path = ""
+        print('__Init__')
+        self.image = self._lls_advanced_collection.objects[0].active_material.node_tree.nodes["Light Texture"].image
+        self._image_path = self._lls_advanced_collection.objects[0].active_material.node_tree.nodes["Light Texture"].image.filepath
         self._lls_rot = None
         self._scale = None
 
@@ -582,8 +632,10 @@ class LightImage(Rectangle):
         return self._view_layer.exclude
 
     @mute.setter
-    def mute(self, value):
-        self._view_layer.exclude = value
+    def mute(self, exclude):
+        self._view_layer.exclude = exclude
+        if not exclude:
+            self._lls_handle.LLStudio.type = self._lls_handle.LLStudio.type
 
     @property
     def panel_loc(self):
@@ -603,8 +655,10 @@ class LightImage(Rectangle):
         if self.mute:
             return
         bpy.ops.object.select_all(action='DESELECT')
-        bpy.context.view_layer.objects.active = self._lls_mesh
-        self._lls_mesh.select_set(True)
+        # if self._lls_object.name in bpy.context.view_layer.objects:
+        self._lls_handle.LLStudio.type = self._lls_handle.LLStudio.type
+        bpy.context.view_layer.objects.active = self._lls_object
+        self._lls_object.select_set(True)
 
     def is_mouse_over(self, mouse_x, mouse_y):
         def rotate(x1, y1, offset):
@@ -641,9 +695,11 @@ class LightImage(Rectangle):
 
     def draw(self):
         try:
-            select = self._lls_mesh.select_get()
+            select = self._lls_object.select_get()
         except ReferenceError:
             return
+        except AttributeError:
+            select = False
 
         # draw something to refresh buffer?
         shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
@@ -666,58 +722,68 @@ class LightImage(Rectangle):
             self.default_border.draw()
 
         lightIconShader.bind()
-        bgl.glActiveTexture(bgl.GL_TEXTURE0)
-        bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
-        lightIconShader.uniform_int("image", 0)
-
         lightIconShader.uniform_float("panel_point_lt", self.panel.point_lt)
         lightIconShader.uniform_float("panel_point_rb", self.panel.point_rb)
+        
+        if self._lls_handle.LLStudio.type == 'ADVANCED':
+            lightIconShader.uniform_bool("advanced", [True,])
+            bgl.glActiveTexture(bgl.GL_TEXTURE0)
+            bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
+            lightIconShader.uniform_int("image", 0)
 
-        try:
-            # material properties
-            lls_node = self._lls_mesh.active_material.node_tree.nodes['Group']
-            intensity = lls_node.inputs['Intensity'].default_value
-
-            texture_switch = lls_node.inputs['Texture Switch'].default_value
-            color_overlay = lls_node.inputs['Color Overlay'].default_value
-            color_saturation = lls_node.inputs['Color Saturation'].default_value
-
-            lightIconShader.uniform_float("intensity", intensity)
-            lightIconShader.uniform_float("texture_switch", texture_switch)
-            lightIconShader.uniform_float("color_overlay", color_overlay)
-            lightIconShader.uniform_float("color_saturation", color_saturation)
-
-            mask_bottom_to_top = lls_node.inputs['Mask - Bottom to Top'].default_value
-            mask_diagonal_bottom_left = lls_node.inputs['Mask - Diagonal Bottom Left'].default_value
-            mask_diagonal_bottom_right = lls_node.inputs['Mask - Diagonal Bottom Right'].default_value
-            mask_diagonal_top_left = lls_node.inputs['Mask - Diagonal Top Left'].default_value
-            mask_diagonal_top_right = lls_node.inputs['Mask - Diagonal Top Right'].default_value
-            mask_gradient_amount = lls_node.inputs['Mask - Gradient Amount'].default_value
-            mask_gradient_switch = lls_node.inputs['Mask - Gradient Switch'].default_value
-            mask_gradient_type = lls_node.inputs['Mask - Gradient Type'].default_value
-            mask_left_to_right = lls_node.inputs['Mask - Left to Right'].default_value
-            mask_right_to_left = lls_node.inputs['Mask - Right to Left'].default_value
-            mask_ring_inner_radius = lls_node.inputs['Mask - Ring Inner Radius'].default_value
-            mask_ring_outer_radius = lls_node.inputs['Mask - Ring Outer Radius'].default_value
-            mask_ring_switch = lls_node.inputs['Mask - Ring Switch'].default_value
-            mask_top_to_bottom = lls_node.inputs['Mask - Top to Bottom'].default_value
-
-            lightIconShader.uniform_float("mask_bottom_to_top", mask_bottom_to_top)
-            lightIconShader.uniform_float("mask_diagonal_bottom_left", mask_diagonal_bottom_left)
-            lightIconShader.uniform_float("mask_diagonal_bottom_right", mask_diagonal_bottom_right)
-            lightIconShader.uniform_float("mask_diagonal_top_left", mask_diagonal_top_left)
-            lightIconShader.uniform_float("mask_diagonal_top_right", mask_diagonal_top_right)
-            lightIconShader.uniform_float("mask_gradient_amount", mask_gradient_amount)
-            lightIconShader.uniform_float("mask_gradient_switch", mask_gradient_switch)
-            lightIconShader.uniform_float("mask_gradient_type", mask_gradient_type)
-            lightIconShader.uniform_float("mask_left_to_right", mask_left_to_right)
-            lightIconShader.uniform_float("mask_right_to_left", mask_right_to_left)
-            lightIconShader.uniform_float("mask_ring_inner_radius", mask_ring_inner_radius)
-            lightIconShader.uniform_float("mask_ring_outer_radius", mask_ring_outer_radius)
-            lightIconShader.uniform_float("mask_ring_switch", mask_ring_switch)
-            lightIconShader.uniform_float("mask_top_to_bottom", mask_top_to_bottom)
-        except:
-            pass
+            try:
+                # material properties
+                lls_node = self._lls_object.active_material.node_tree.nodes['Group']
+                intensity = lls_node.inputs['Intensity'].default_value
+
+                texture_switch = lls_node.inputs['Texture Switch'].default_value
+                color_overlay = lls_node.inputs['Color Overlay'].default_value
+                color_saturation = lls_node.inputs['Color Saturation'].default_value
+
+                lightIconShader.uniform_float("intensity", intensity)
+                lightIconShader.uniform_float("texture_switch", texture_switch)
+                lightIconShader.uniform_float("color_overlay", color_overlay)
+                lightIconShader.uniform_float("color_saturation", color_saturation)
+
+                mask_bottom_to_top = lls_node.inputs['Mask - Bottom to Top'].default_value
+                mask_diagonal_bottom_left = lls_node.inputs['Mask - Diagonal Bottom Left'].default_value
+                mask_diagonal_bottom_right = lls_node.inputs['Mask - Diagonal Bottom Right'].default_value
+                mask_diagonal_top_left = lls_node.inputs['Mask - Diagonal Top Left'].default_value
+                mask_diagonal_top_right = lls_node.inputs['Mask - Diagonal Top Right'].default_value
+                mask_gradient_amount = lls_node.inputs['Mask - Gradient Amount'].default_value
+                mask_gradient_switch = lls_node.inputs['Mask - Gradient Switch'].default_value
+                mask_gradient_type = lls_node.inputs['Mask - Gradient Type'].default_value
+                mask_left_to_right = lls_node.inputs['Mask - Left to Right'].default_value
+                mask_right_to_left = lls_node.inputs['Mask - Right to Left'].default_value
+                mask_ring_inner_radius = lls_node.inputs['Mask - Ring Inner Radius'].default_value
+                mask_ring_outer_radius = lls_node.inputs['Mask - Ring Outer Radius'].default_value
+                mask_ring_switch = lls_node.inputs['Mask - Ring Switch'].default_value
+                mask_top_to_bottom = lls_node.inputs['Mask - Top to Bottom'].default_value
+
+                lightIconShader.uniform_float("mask_bottom_to_top", mask_bottom_to_top)
+                lightIconShader.uniform_float("mask_diagonal_bottom_left", mask_diagonal_bottom_left)
+                lightIconShader.uniform_float("mask_diagonal_bottom_right", mask_diagonal_bottom_right)
+                lightIconShader.uniform_float("mask_diagonal_top_left", mask_diagonal_top_left)
+                lightIconShader.uniform_float("mask_diagonal_top_right", mask_diagonal_top_right)
+                lightIconShader.uniform_float("mask_gradient_amount", mask_gradient_amount)
+                lightIconShader.uniform_float("mask_gradient_switch", mask_gradient_switch)
+                lightIconShader.uniform_float("mask_gradient_type", mask_gradient_type)
+                lightIconShader.uniform_float("mask_left_to_right", mask_left_to_right)
+                lightIconShader.uniform_float("mask_right_to_left", mask_right_to_left)
+                lightIconShader.uniform_float("mask_ring_inner_radius", mask_ring_inner_radius)
+                lightIconShader.uniform_float("mask_ring_outer_radius", mask_ring_outer_radius)
+                lightIconShader.uniform_float("mask_ring_switch", mask_ring_switch)
+                lightIconShader.uniform_float("mask_top_to_bottom", mask_top_to_bottom)
+            except:
+                pass
+        else:
+            lightIconShader.uniform_bool("advanced", [False,])
+            lightIconShader.uniform_float("intensity", self._lls_object.data.LLStudio.intensity)
+            lightIconShader.uniform_float("color_saturation", self._lls_object.data.LLStudio.color_saturation)
+            lightIconShader.uniform_float("color_overlay", Vector((self._lls_object.data.LLStudio.color[:]+(1,))))
+
+
+        
         bgl.glEnable(bgl.GL_BLEND)
 
         if lleft < bleft:

commit 78740097f2b14f1a5d12003bf229a8330fcc47c4
Merge: 7f975f3 99d884a
Author: StyriamMZ <47333958+StyriamMZ@users.noreply.github.com>
Date:   Fri Nov 6 21:45:59 2020 +0100

    Merge pull request #5 from leomoon-studios/master
    
    Merge

commit 99d884a116b3976fd035a282b78fb72bc6a4ef26
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Oct 19 22:39:40 2020 -0700

    changes readme

diff --git a/README.md b/README.md
index 88652ec..9f70906 100644
--- a/README.md
+++ b/README.md
@@ -35,13 +35,6 @@ LeoMoon LightStudio uses mesh lights and currently, EEVEE does not support mesh
 ## Background HDR vs Manual Lighting
 Why not use the other background HDR light plugins? That's because template based light plugins are predictable and limited. For product renders, you want lots of options and control, NOT templates! However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
 
-## Why Are You Selling This "Free" Plugin?
-Me and some generous donors, we've been funding LightStudio so far. This plugin is getting harder to develop and we need your help.
-
-If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
-
-Thank you.
-
 ## Changelog
 ### 2.6.2 2020-10-07:
 * Added custom hotkeys to addon preferences

commit 04ff8642dd6260103d0e8e06ab1122583c117600
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Oct 19 17:39:48 2020 -0700

    re-arranged files

diff --git a/.gitignore b/.gitignore
index 34ea7d0..894a44c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,7 +7,6 @@ __pycache__/
 *.so
 
 # Distribution / packaging
-skrypt/
 .Python
 build/
 develop-eggs/
diff --git a/src/LLS3.blend b/LLS3.blend
similarity index 100%
rename from src/LLS3.blend
rename to LLS3.blend
diff --git a/src/__init__.py b/__init__.py
similarity index 100%
rename from src/__init__.py
rename to __init__.py
diff --git a/src/auto_load.py b/auto_load.py
similarity index 100%
rename from src/auto_load.py
rename to auto_load.py
diff --git a/src/common.py b/common.py
similarity index 100%
rename from src/common.py
rename to common.py
diff --git a/src/deleteOperator.py b/deleteOperator.py
similarity index 100%
rename from src/deleteOperator.py
rename to deleteOperator.py
diff --git a/src/gui.py b/gui.py
similarity index 100%
rename from src/gui.py
rename to gui.py
diff --git a/src/light_brush.py b/light_brush.py
similarity index 100%
rename from src/light_brush.py
rename to light_brush.py
diff --git a/src/light_list.py b/light_list.py
similarity index 100%
rename from src/light_list.py
rename to light_list.py
diff --git a/src/light_operators.py b/light_operators.py
similarity index 100%
rename from src/light_operators.py
rename to light_operators.py
diff --git a/src/light_preview_list.py b/light_preview_list.py
similarity index 100%
rename from src/light_preview_list.py
rename to light_preview_list.py
diff --git a/src/light_profiles.py b/light_profiles.py
similarity index 100%
rename from src/light_profiles.py
rename to light_profiles.py
diff --git a/src/operators/__init__.py b/operators/__init__.py
similarity index 100%
rename from src/operators/__init__.py
rename to operators/__init__.py
diff --git a/src/operators/modal.py b/operators/modal.py
similarity index 100%
rename from src/operators/modal.py
rename to operators/modal.py
diff --git a/src/operators/modal_utils.py b/operators/modal_utils.py
similarity index 100%
rename from src/operators/modal_utils.py
rename to operators/modal_utils.py
diff --git a/src/textures_real_lights/Camera Flash 5600K.exr b/textures_real_lights/Camera Flash 5600K.exr
similarity index 100%
rename from src/textures_real_lights/Camera Flash 5600K.exr
rename to textures_real_lights/Camera Flash 5600K.exr
diff --git a/src/textures_real_lights/Fluorescent Tube A.hdr b/textures_real_lights/Fluorescent Tube A.hdr
similarity index 100%
rename from src/textures_real_lights/Fluorescent Tube A.hdr
rename to textures_real_lights/Fluorescent Tube A.hdr
diff --git a/src/textures_real_lights/Fluorescent Tube B.exr b/textures_real_lights/Fluorescent Tube B.exr
similarity index 100%
rename from src/textures_real_lights/Fluorescent Tube B.exr
rename to textures_real_lights/Fluorescent Tube B.exr
diff --git a/src/textures_real_lights/Soft Box A.exr b/textures_real_lights/Soft Box A.exr
similarity index 100%
rename from src/textures_real_lights/Soft Box A.exr
rename to textures_real_lights/Soft Box A.exr
diff --git a/src/textures_real_lights/Synthetic Area A.exr b/textures_real_lights/Synthetic Area A.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Area A.exr
rename to textures_real_lights/Synthetic Area A.exr
diff --git a/src/textures_real_lights/Synthetic Area B.exr b/textures_real_lights/Synthetic Area B.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Area B.exr
rename to textures_real_lights/Synthetic Area B.exr
diff --git a/src/textures_real_lights/Synthetic Area C.exr b/textures_real_lights/Synthetic Area C.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Area C.exr
rename to textures_real_lights/Synthetic Area C.exr
diff --git a/src/textures_real_lights/Synthetic Area D.exr b/textures_real_lights/Synthetic Area D.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Area D.exr
rename to textures_real_lights/Synthetic Area D.exr
diff --git a/src/textures_real_lights/Synthetic Disc A.exr b/textures_real_lights/Synthetic Disc A.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Disc A.exr
rename to textures_real_lights/Synthetic Disc A.exr
diff --git a/src/textures_real_lights/Synthetic Octagon A.exr b/textures_real_lights/Synthetic Octagon A.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Octagon A.exr
rename to textures_real_lights/Synthetic Octagon A.exr
diff --git a/src/textures_real_lights/Synthetic Ring A.exr b/textures_real_lights/Synthetic Ring A.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Ring A.exr
rename to textures_real_lights/Synthetic Ring A.exr
diff --git a/src/textures_real_lights/Synthetic Ring B.exr b/textures_real_lights/Synthetic Ring B.exr
similarity index 100%
rename from src/textures_real_lights/Synthetic Ring B.exr
rename to textures_real_lights/Synthetic Ring B.exr
diff --git a/src/textures_real_lights/Television A.exr b/textures_real_lights/Television A.exr
similarity index 100%
rename from src/textures_real_lights/Television A.exr
rename to textures_real_lights/Television A.exr
diff --git a/src/textures_real_lights/Umbrella A.exr b/textures_real_lights/Umbrella A.exr
similarity index 100%
rename from src/textures_real_lights/Umbrella A.exr
rename to textures_real_lights/Umbrella A.exr
diff --git a/src/textures_real_lights/Window A.exr b/textures_real_lights/Window A.exr
similarity index 100%
rename from src/textures_real_lights/Window A.exr
rename to textures_real_lights/Window A.exr

commit 1a9e4abbbdff486b6ca0341b5bf5e1a6ea0d9f2b
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Oct 9 18:25:18 2020 -0700

    improves button padding

diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 6e71e1a..df3eb1c 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -288,12 +288,12 @@ class Panel(Rectangle):
 
         self.button_send_to_bottom.loc = Vector((
             self.point_lt.x + self.button_send_to_bottom.dimensions[0]/2 + 5,
-            self.point_rb.y - self.button_exit.dimensions[1]/2 - 10,
+            self.point_rb.y - self.button_exit.dimensions[1]/2 - 13,
         ))
 
         self.button_fast_3d_edit.loc = Vector((
             self.point_lt.x + self.button_send_to_bottom.dimensions[0] + self.button_fast_3d_edit.dimensions[0]/2 + 23,
-            self.point_rb.y - self.button_exit.dimensions[1]/2 - 10,
+            self.point_rb.y - self.button_exit.dimensions[1]/2 - 13,
         ))
 
     def draw(self):
@@ -323,7 +323,7 @@ class Button(Rectangle):
         self.dimensions = blf.dimensions(self.font_id, text)
         self.function = lambda args : None
 
-        super().__init__(loc, self.dimensions[0]+10, size+3)
+        super().__init__(loc, self.dimensions[0]+10, size+10)
         Button.buttons.append(self)
 
     def draw(self, mouse_x, mouse_y):
@@ -337,7 +337,7 @@ class Button(Rectangle):
             shader2Dcolor.uniform_float("color", self.bg_color)
         batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
         blf.size(self.font_id, self.font_size, 72)
-        blf.position(self.font_id, self.point_lt.x + 5, self.point_rb.y + 4, 0)
+        blf.position(self.font_id, self.point_lt.x + 5, self.point_rb.y + 7, 0)
         blf.color(self.font_id, *self.font_color)
         blf.draw(self.font_id, self.text)
 

commit 43bc187bf821697d3f7ae608c094daabb34743bb
Author: Amin Persia <leomoon@gmail.com>
Date:   Thu Oct 8 00:45:23 2020 -0700

    improves padding for UI buttons

diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 763c77c..6e71e1a 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -268,33 +268,33 @@ from .. light_brush import OT_LLSFast3DEdit
 class Panel(Rectangle):
     def __init__(self, loc, width, height):
         super().__init__(loc, width, height)
-        self.button_exit = Button(Vector((0,0)), 'x', 30)
+        self.button_exit = Button(Vector((0,0)), 'X')
         self.button_exit.function = lambda x: "FINISHED"
 
         self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
         self.button_send_to_bottom.function = send_light_to_bottom
 
-        # km, kmi = get_user_keymap_item('Object Mode', OT_LLSFast3DEdit.bl_idname)
-        # self.button_fast_3d_edit = Button(Vector((0,0)), f'Light Brush [{kmi.type}]')
-        # self.button_fast_3d_edit.function = fast_3d_edit
+        km, kmi = get_user_keymap_item('Object Mode', OT_LLSFast3DEdit.bl_idname)
+        self.button_fast_3d_edit = Button(Vector((0,0)), f'Light Brush [{kmi.type}]')
+        self.button_fast_3d_edit.function = fast_3d_edit
 
         self._move_buttons()
 
     def _move_buttons(self):
         self.button_exit.loc = Vector((
             self.point_rb.x - self.button_exit.dimensions[0]/4,
-            self.point_lt.y - self.button_exit.dimensions[1]/4,
+            self.point_lt.y - self.button_exit.dimensions[1]/4+3,
         ))
 
         self.button_send_to_bottom.loc = Vector((
-            self.point_lt.x + self.button_send_to_bottom.dimensions[0]/2,
-            self.point_rb.y - self.button_exit.dimensions[1]/2,
+            self.point_lt.x + self.button_send_to_bottom.dimensions[0]/2 + 5,
+            self.point_rb.y - self.button_exit.dimensions[1]/2 - 10,
         ))
 
-        # self.button_fast_3d_edit.loc = Vector((
-        #     self.point_lt.x + self.button_send_to_bottom.dimensions[0] + self.button_fast_3d_edit.dimensions[0]/2 + 15,
-        #     self.point_rb.y - self.button_exit.dimensions[1]/2,
-        # ))
+        self.button_fast_3d_edit.loc = Vector((
+            self.point_lt.x + self.button_send_to_bottom.dimensions[0] + self.button_fast_3d_edit.dimensions[0]/2 + 23,
+            self.point_rb.y - self.button_exit.dimensions[1]/2 - 10,
+        ))
 
     def draw(self):
         shader2Dcolor.uniform_float("color", (0.05, 0.05, 0.05, 1))
@@ -312,7 +312,7 @@ class Button(Rectangle):
     buttons = []
     def __init__(self, loc, text, size=15):
         self.font_size = size
-        self.font_color = (.25, .25, .25, 1)
+        self.font_color = (0, 0, 0, 1)
         self.bg_color = (.5, .5, .5, 1)
         self.bg_color_selected = (.7, .7, .7, 1)
         self.font_id = len(Button.buttons)
@@ -323,7 +323,7 @@ class Button(Rectangle):
         self.dimensions = blf.dimensions(self.font_id, text)
         self.function = lambda args : None
 
-        super().__init__(loc, self.dimensions[0]+5, self.dimensions[1]+5)
+        super().__init__(loc, self.dimensions[0]+10, size+3)
         Button.buttons.append(self)
 
     def draw(self, mouse_x, mouse_y):
@@ -337,7 +337,8 @@ class Button(Rectangle):
             shader2Dcolor.uniform_float("color", self.bg_color)
         batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
         blf.size(self.font_id, self.font_size, 72)
-        blf.position(self.font_id, self.point_lt.x + 2.5, self.point_rb.y + 2.5, 0)
+        blf.position(self.font_id, self.point_lt.x + 5, self.point_rb.y + 4, 0)
+        blf.color(self.font_id, *self.font_color)
         blf.draw(self.font_id, self.text)
 
     def click(self, args=None):

commit 343bb78253711c7a7c02aa8d8cbaebeaab7610ad
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 21:37:00 2020 -0700

    changes readme.md

diff --git a/README.md b/README.md
index 604f259..88652ec 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # LeoMoon LightStudio
 ## Important Notice
-LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)**. You can **[download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)** and use it without any limitations.
+LeoMoon LightStudio (formerly known as Blender Light Studio) is 100% free and open-source. You can download and use it from here without any limitations.
 
 ## Development Fund
 If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**. This will help to fix bugs, improve user interface and add new features.

commit 9715debdc09d961ebbe91fb06baf3ee387c42429
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 21:35:04 2020 -0700

    fixes typos in readme.md

diff --git a/README.md b/README.md
index fcc862b..604f259 100644
--- a/README.md
+++ b/README.md
@@ -62,7 +62,7 @@ Thank you.
 * Lights can be renamed in the light list
 * Lights can be toggled in the light list
 * Lights can be isolated in the light list
-* Light selection is syncronized with the LightPanel
+* Light selection is synchronized with the LightPanel
 
 ### 2.5.2 2020-07-10:
 * Fixed light going outside of LightPanel
@@ -78,7 +78,7 @@ Thank you.
 ### 2.5.0 2020-03-23:
 * Fixed LightStudio error when opening Bledner 2.8x
 * Fixed LightStudio error when deleting studio
-* Fixed strange behaviour when clicking LightStudio Control Panel multiple times
+* Fixed strange behavior when clicking LightStudio Control Panel multiple times
 * Fixed the ordering of LightStudio side panel
 * Improved the light node
 * Added all the light effect previews to the LightStudio Control Panel

commit 16ad40556d1a6ab5fa689d6c3655871f1eea8662
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 15:21:08 2020 -0700

    hides LightPanel's Light Brush button

diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index f9a62f4..763c77c 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -274,9 +274,9 @@ class Panel(Rectangle):
         self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
         self.button_send_to_bottom.function = send_light_to_bottom
 
-        km, kmi = get_user_keymap_item('Object Mode', OT_LLSFast3DEdit.bl_idname)
-        self.button_fast_3d_edit = Button(Vector((0,0)), f'Light Brush [{kmi.type}]')
-        self.button_fast_3d_edit.function = fast_3d_edit
+        # km, kmi = get_user_keymap_item('Object Mode', OT_LLSFast3DEdit.bl_idname)
+        # self.button_fast_3d_edit = Button(Vector((0,0)), f'Light Brush [{kmi.type}]')
+        # self.button_fast_3d_edit.function = fast_3d_edit
 
         self._move_buttons()
 
@@ -291,10 +291,10 @@ class Panel(Rectangle):
             self.point_rb.y - self.button_exit.dimensions[1]/2,
         ))
 
-        self.button_fast_3d_edit.loc = Vector((
-            self.point_lt.x + self.button_send_to_bottom.dimensions[0] + self.button_fast_3d_edit.dimensions[0]/2 + 15,
-            self.point_rb.y - self.button_exit.dimensions[1]/2,
-        ))
+        # self.button_fast_3d_edit.loc = Vector((
+        #     self.point_lt.x + self.button_send_to_bottom.dimensions[0] + self.button_fast_3d_edit.dimensions[0]/2 + 15,
+        #     self.point_rb.y - self.button_exit.dimensions[1]/2,
+        # ))
 
     def draw(self):
         shader2Dcolor.uniform_float("color", (0.05, 0.05, 0.05, 1))

commit 2412d977bccb3090722b35c88cd1dd7ae0905cd8
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 15:13:36 2020 -0700

    updates readme.md

diff --git a/README.md b/README.md
index 600795a..fcc862b 100644
--- a/README.md
+++ b/README.md
@@ -43,6 +43,13 @@ If you think this plugin speeds up your workflow, consider funding the developme
 Thank you.
 
 ## Changelog
+### 2.6.2 2020-10-07:
+* Added custom hotkeys to addon preferences
+* Major improvements added to Light Brush with F hotkey (3D Edit)
+* Added G hotkey to move lights in the light panel and 3D view
+* R and S hotkeys can now rotate and scale lights in the 3D view also
+* Improved undo
+
 ### 2.6.1 2020-08-21:
 * Added "Up" and "Down" buttons to sort lights in the light list
 * Added button to copy a light in the light list

commit b2fc2ee238196e5f7e17729d57e5dbd835c0af3b
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 15:03:56 2020 -0700

    Changes Fast 3D Edit to Light Brush

diff --git a/src/light_brush.py b/src/light_brush.py
index 8f27082..6faae50 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -7,7 +7,7 @@ from bpy.props import *
 from . common import isFamily, family, findLightGrp, getLightMesh, getLightController, get_user_keymap_item
 from . operators import LightOperator
 
-           
+
 def raycast(context, event, diff):
     """Run this function on left mouse, execute the ray cast"""
     # get the context arguments
@@ -18,16 +18,16 @@ def raycast(context, event, diff):
     # get the ray from the viewport and mouse
     view_vector = view3d_utils.region_2d_to_vector_3d(region, rv3d, coord)
     ray_origin = view3d_utils.region_2d_to_origin_3d(region, rv3d, coord)
-    
+
     ray_target = ray_origin + view_vector
-    
+
     def visible_objects_and_duplis():
         """Loop over (object, matrix) pairs (mesh only)"""
 
         for obj in context.visible_objects:
             if isFamily(obj):
                 continue
-            
+
             if obj.type == 'MESH':
                 yield (obj, obj.matrix_world.copy())
 
@@ -54,7 +54,7 @@ def raycast(context, event, diff):
             return location, normal, face_index
         else:
             return None, None, None
-    
+
     # cast rays and find the closest object
     best_length_squared = -1.0
     best_obj = None
@@ -72,17 +72,17 @@ def raycast(context, event, diff):
                     best_obj = obj
                     normal = hit_normal # local space
                     location = hit_world
-                    
+
 
     if best_obj is None:
         return {'RUNNING_MODAL'}
-    
+
     # convert normal from local space to global
     matrix = best_obj.matrix_world
     matrix_new = matrix.to_3x3().inverted().transposed()
     normal = matrix_new @ normal
     normal.normalize()
-    
+
     #####
     profile = findLightGrp(context.active_object).parent
     handle = [ob for ob in profile.children if ob.name.startswith('LLS_HANDLE')][0]
@@ -95,15 +95,15 @@ def raycast(context, event, diff):
         lightmesh.location.x,
         False,
         )[0]
-    
-    
+
+
     if not position:
         return {'RUNNING_MODAL'}
-   
+
     # ctrl x
     x,y,z = position
     actuator.rotation_euler.x = atan2(x, -y)
-    
+
     # ctrl y
     deg = copysign(degrees(Vector.angle(Vector((x,y,z)), Vector((x,y,0)))), z)
     actuator.rotation_euler.y = copysign(Vector.angle(Vector((x,y,z)), Vector((x,y,0))), z)
@@ -113,7 +113,7 @@ class LLSLightBrush(bpy.types.Operator, LightOperator):
     bl_idname = "lls.light_brush"
     bl_label = "Light Brush"
     bl_options = {"UNDO"}
-    
+
     aux: BoolProperty(default=False) # is aux operator working
     normal_type: BoolProperty(default=False)
 
@@ -123,9 +123,9 @@ class LLSLightBrush(bpy.types.Operator, LightOperator):
             if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
                 self.aux = False
             return {'RUNNING_MODAL'}
-        
+
         context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
-        
+
         if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'Z', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
             # allow navigation
             return {'PASS_THROUGH'}
@@ -164,12 +164,12 @@ key_released = False
 class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
     """Point on object to position light and reflection"""
     bl_idname = "light_studio.fast_3d_edit"
-    bl_label = "Fast 3D Edit"
+    bl_label = "Light Brush"
     bl_options = {"UNDO"}
-    
+
     continuous: BoolProperty(default=False, name="Hold to use", description="Button behaviour.\n ON: Hold button to use. Release button to stop.\n OFF: Hold LMB to use, release LMB to stop.")
     normal_type: BoolProperty(default=False, name="Light along normal", description="Default reflection type.\n ON: Light along normal\n OFF: surface reflection (what you are looking for in most cases)")
-    
+
     def modal(self, context, event):
         screens = [window.screen for window in context.window_manager.windows]
         regions3d = [(area.spaces[0].region_3d, region) for screen in screens for area in screen.areas if area.type == context.area.type for region in area.regions if region.type == context.region.type]
@@ -193,7 +193,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
         override_event.mouse_region_x = event.mouse_x - active_region.x
         override_event.mouse_region_y = event.mouse_y - active_region.y
 
-        
+
         global key_released
         context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
         # print(event.type, event.value)
@@ -253,15 +253,15 @@ addon_keymaps = []
 def add_shortkeys():
     wm = bpy.context.window_manager
     addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type="EMPTY")
-    
+
     addon_kmi = addon_km.keymap_items.new(OT_LLSFast3DEdit.bl_idname, 'F', 'PRESS')
     addon_kmi.properties.continuous = False
-    
+
     addon_keymaps.append((addon_km, addon_kmi))
 
 def remove_shortkeys():
     wm = bpy.context.window_manager
     for km, kmi in addon_keymaps:
         km.keymap_items.remove(kmi)
-        
+
     addon_keymaps.clear()
\ No newline at end of file
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 7ab41b4..f9a62f4 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -63,15 +63,15 @@ fragment_shader = '''
     {
         // Trash output - sum all uniforms to prevent compiler from skipping currently unused ones
         trash = vec4(panel_point_lt.x+panel_point_rb.x+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
-        
+
         // Texture Switch + Intensity
         // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
         fragColor = mix(vec4(1.0f), texture(image, texCoord_interp), texture_switch) * log(1+intensity);
-        
+
         // Color Overlay
         float gray = clamp(dot(fragColor.rgb, vec3(0.299, 0.587, 0.114)), 0, 1);
         vec4 colored = color_overlay * gray;
-        
+
         // Color Saturation
         fragColor = mix(fragColor, colored, color_saturation);
         fragColor.a = gray;
@@ -101,25 +101,25 @@ fragment_shader = '''
         float ring = d < (1-mask_ring_outer_radius)*.575f ? 1 : 0;
         ring = d < (1-mask_ring_inner_radius)*.55f ? 0 : ring;
         fragColor.a = mix(fragColor.a, fragColor.a*ring, mask_ring_switch);
-        
+
         // Top-Bottom
         fragColor.a = texCoord_interp.y < (1-mask_top_to_bottom) ? fragColor.a : 0;
-        
+
         // Bottom-Top
         fragColor.a = texCoord_interp.y > mask_bottom_to_top ? fragColor.a : 0;
 
         // Left-Right
         fragColor.a = texCoord_interp.x > mask_left_to_right ? fragColor.a : 0;
-        
+
         // Right-Left
         fragColor.a = texCoord_interp.x < (1-mask_right_to_left) ? fragColor.a : 0;
 
         // Diagonal Top-Right
         fragColor.a = 1-(texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_right ? fragColor.a : 0;
-        
+
         // Diagonal Top-Left
         fragColor.a = 1-(1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_left ? fragColor.a : 0;
-        
+
         // Diagonal Bottom-Right
         fragColor.a = (1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_right ? fragColor.a : 0;
 
@@ -193,7 +193,7 @@ class Rectangle:
         d = loc - self.loc
         self.point_lt += d
         self.point_rb += d
-    
+
     @property
     def width(self):
         return self.point_rb.x - self.point_lt.x
@@ -223,7 +223,7 @@ class Rectangle:
             x2 += offset.x
             y2 += offset.y
             return [x2, y2]
-        
+
         loc = self.loc # prevent property from recomputing
         return (
             rotate(self.point_lt.x, self.point_lt.y, loc),
@@ -275,7 +275,7 @@ class Panel(Rectangle):
         self.button_send_to_bottom.function = send_light_to_bottom
 
         km, kmi = get_user_keymap_item('Object Mode', OT_LLSFast3DEdit.bl_idname)
-        self.button_fast_3d_edit = Button(Vector((0,0)), f'Fast 3D Edit [{kmi.type}]')
+        self.button_fast_3d_edit = Button(Vector((0,0)), f'Light Brush [{kmi.type}]')
         self.button_fast_3d_edit.function = fast_3d_edit
 
         self._move_buttons()
@@ -305,7 +305,7 @@ class Panel(Rectangle):
 
         for l in LightImage.lights:
             l.update_visual_location()
-        
+
         self._move_buttons()
 
 class Button(Rectangle):
@@ -399,7 +399,7 @@ class Border(Rectangle):
             [verts[3][0]+rot_translate_ort.x, verts[3][1]+rot_translate_ort.y],
             verts[3]
         ]
-        
+
         border_shader2Dcolor.bind()
         bgl.glEnable(bgl.GL_BLEND)
         border_shader2Dcolor.uniform_float("color", self.color)
@@ -413,11 +413,11 @@ class Border(Rectangle):
             right_verts2 = deepcopy(right_verts)
             for v in right_verts2:
                 v[0] += self.light_image.panel.width
-            
+
             top_verts2 = deepcopy(top_verts)
             for v in top_verts2:
                 v[0] += self.light_image.panel.width
-            
+
             bottom_verts2 = deepcopy(bottom_verts)
             for v in bottom_verts2:
                 v[0] += self.light_image.panel.width
@@ -434,11 +434,11 @@ class Border(Rectangle):
             right_verts2 = deepcopy(right_verts)
             for v in right_verts2:
                 v[0] -= self.light_image.panel.width
-            
+
             top_verts2 = deepcopy(top_verts)
             for v in top_verts2:
                 v[0] -= self.light_image.panel.width
-            
+
             bottom_verts2 = deepcopy(bottom_verts)
             for v in bottom_verts2:
                 v[0] -= self.light_image.panel.width
@@ -447,7 +447,7 @@ class Border(Rectangle):
             batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(border_shader2Dcolor)
             batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(border_shader2Dcolor)
             batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(border_shader2Dcolor)
-        
+
         batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(border_shader2Dcolor)
         batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(border_shader2Dcolor)
         batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(border_shader2Dcolor)
@@ -463,7 +463,7 @@ class Border(Rectangle):
 
         self.point_rb.x += self.weight
         self.point_rb.y -= self.weight
-        
+
         self.rot = self.light_image.rot
 
         return super().get_verts()
@@ -484,7 +484,7 @@ class LightImage(Rectangle):
 
     def delete(self):
         del LightImage.lights[LightImage.lights.index(self)]
-    
+
     @classmethod
     def refresh(cls):
         props = bpy.context.scene.LLStudio
@@ -496,8 +496,8 @@ class LightImage(Rectangle):
                     l.update_visual_location()
             except ReferenceError:
                 l.delete()
-            
-    
+
+
     default_size = 100
     @classmethod
     def change_default_size(cls, value):
@@ -505,11 +505,11 @@ class LightImage(Rectangle):
         for l in cls.lights:
             l.width = value * l._scale.y
             l.height = value * l._scale.z
-        
+
     def panel_loc_to_area_px_lt(self):
         panel_px_loc = Vector((self.panel.width * self.panel_loc.x, -self.panel.height * (1-self.panel_loc.y)))
         return panel_px_loc + self.panel.point_lt - Vector((LightImage.default_size*self._scale.y/2, LightImage.default_size*self._scale.z/2))
-    
+
     def _update_panel_loc(self):
         self.panel_loc.x = (self._lls_rot.x + pi) % (2*pi) / (2*pi)
         self.panel_loc.y = fmod(self._lls_rot.y + pi/2, pi) / (pi)
@@ -530,7 +530,7 @@ class LightImage(Rectangle):
             self._scale = self._lls_mesh.scale.copy()
             self.width = LightImage.default_size * self._scale.y
             self.height = LightImage.default_size * self._scale.z
-        
+
         if updated:
             self._update_panel_loc()
 
@@ -541,7 +541,7 @@ class LightImage(Rectangle):
         # this should run when image changes but sometimes Blender looses images... so it's run every time to be safe
         if self.image.gl_load():
             raise Exception
-        
+
 
         return updated
 
@@ -560,7 +560,7 @@ class LightImage(Rectangle):
         self._view_layer = find_view_layer(self._collection, context.view_layer.layer_collection)
         # except Exception:
         #     raise Exception
-        
+
         self._image_path = ""
         self._lls_rot = None
         self._scale = None
@@ -568,18 +568,18 @@ class LightImage(Rectangle):
         super().__init__(Vector((0,0)), LightImage.default_size, LightImage.default_size)
         self.update_from_lls()
         self.update_visual_location()
-        
+
         LightImage.lights.append(self)
 
         self.default_border = Border(self, (.2, .35, .2, 1))
         self.mute_border = Border(self, (.7, 0, 0, 1))
         self.select_border = Border(self, (.2, .9, .2, 1))
         #self.select_border.weight = 2
-    
+
     @property
     def mute(self):
         return self._view_layer.exclude
-    
+
     @mute.setter
     def mute(self, value):
         self._view_layer.exclude = value
@@ -587,7 +587,7 @@ class LightImage(Rectangle):
     @property
     def panel_loc(self):
         return self.__panel_loc
-    
+
     @panel_loc.setter
     def panel_loc(self, pos):
         self.__panel_loc = pos
@@ -614,7 +614,7 @@ class LightImage(Rectangle):
             x2 += offset.x
             y2 += offset.y
             return [x2, y2]
-        
+
         bleft = self.panel.point_lt[0]
         bright = self.panel.point_rb[0]
 
@@ -625,7 +625,7 @@ class LightImage(Rectangle):
         if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
             (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
             return True
-        
+
         tmouse_x, tmouse_y = rotate(bleft-(bright-mouse_x), mouse_y, self.loc)
         if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
             (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
@@ -643,17 +643,17 @@ class LightImage(Rectangle):
             select = self._lls_mesh.select_get()
         except ReferenceError:
             return
-        
+
         # draw something to refresh buffer?
         shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
         batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
 
         bleft = self.panel.point_lt[0]
         bright = self.panel.point_rb[0]
-        
+
         verts = self.get_verts()
         uv_coords = self.get_tex_coords()
-        
+
         lleft = min(verts, key=lambda v: v[0])[0]
         lright = max(verts, key=lambda v: v[0])[0]
 
@@ -792,14 +792,14 @@ class ClickManager:
     def __init__(self):
         self.times = [0, 0, 0]
         self.objects = [None, None, None]
-    
+
     def click(self, object):
         self.times.append(time.time())
         self.objects.append(object)
         if len(self.times) > 3:
             del self.times[0]
             del self.objects[0]
-        
+
         if self.objects[0] == self.objects[1] == self.objects[2]:
             if self.times[2] - self.times[0] <= .5:
                 return "TRIPLE"
@@ -810,7 +810,7 @@ class ClickManager:
 class MouseWidget:
     mouse_x: bpy.props.IntProperty()
     mouse_y: bpy.props.IntProperty()
-    
+
     def __init__(self):
         self._start_position = None
         self._end_position = Vector((0, 0))
@@ -876,7 +876,7 @@ class MouseWidget:
         self.mouse_x = event.mouse_x - context.area.x
         self.mouse_y = event.mouse_y - context.area.y
         self._end_position = Vector((self.mouse_x, self.mouse_y))
-        
+
         if self.allow_xy_keys:
             if event.value == "PRESS":
                 if event.type == "X":
@@ -909,16 +909,16 @@ class MouseWidget:
             bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
         except (ValueError, AttributeError):
             pass
-    
+
     def length(self):
         return (self._start_position - self._reference_end_position - self.delta_vector()).length
-    
+
     def delta_vector(self):
         precision_factor_inv = 1 - self.precision_factor
         if self.precision_mode:
             return self._precision_mode_mid_stop - self._reference_end_position - self.precision_offset * precision_factor_inv + (self._end_position - self._precision_mode_mid_stop) * self.precision_factor
         return self._end_position - self._reference_end_position - self.precision_offset * precision_factor_inv
-    
+
     def delta_length_factor(self):
         return self.length() / ((self._start_position - self._reference_end_position).length)
 
@@ -930,7 +930,7 @@ class MouseWidget:
         # first draw to reset buffer
         shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
         batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0,0), (0,0))}).draw(shader2Dcolor)
-        
+
         if self.draw_guide:
             shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
             batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position[:]), (self._end_position[:]))}).draw(shader2Dcolor)

commit 447da5b496807e1ccde5f3dd27ea41c8836f4e49
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 14:51:50 2020 -0700

    updates gui with the upcoming basic and advanced light setup

diff --git a/GUI b/GUI
index 198a7d3..64801f7 100644
--- a/GUI
+++ b/GUI
@@ -1,7 +1,6 @@
 * BUTTON ICONS GUIDE:
     [+] = Add light (icon: ADD)
     [-] = Delete light (icon: REMOVE)
-    [L] = Lock light (icon: UNLOCKED, LOCKED)
     [V] = Show/hide light (icon: HIDE_OFF, HIDE_ON)
     [S] = Solo selected light (icon: SOLO_OFF, SOLO_ON)
     [C] = Copy menu (icon: DUPLICATE)
@@ -17,19 +16,22 @@ After adding LightStudio:
     [          Show LightStudio Panel           ]
  Lights
     --------------------------------------- [+]
-    | Light 1                      [L][V][S]| [-]
-    | Light 2                      [L][V][S]| [c]
+    | Light 1                         [V][S]| [-]
+    | Light 2                         [V][S]| [c]
     |                                       |
     |                                       | []
     |                                       | []
     ---------------------------------------
-    [                  3D Edit                  ]
-    -------------------------------------------
-    |              -------------              |
-    |              |             |              |
-    |              |             |              |
-    |              |             |              |
-    |              |             |              |
+ Selected Light
+    Light Type      [ Advanced (Cycles Only)  ]     Light Type      [ Basic (EEVEE and Cycles)  ]
+                    | Basic (EEVEE and Cycles) |                     | Advanced (Cycles Only)     |
+                    ----------------------------                     ----------------------------
+    -------------------------------------------    Color Overlay:                      [       ]
+    |              -------------              |    -------------------------------------------
+    |              |             |              |    |  Color Saturation:               0.000  |
+    |              |             |              |    |  Intensity:                      2.000  |
+    |              |             |              |    |  Location:                      30.000  |
+    |              |             |              |    -------------------------------------------
     |              |             |              |
     |              -------------              |
     | Soft Box A                                |
@@ -37,7 +39,7 @@ After adding LightStudio:
     -------------------------------------------
     Color Overlay:                      [       ]
     -------------------------------------------
-    |  Color Saturation:               0.300  |
+    |  Color Saturation:               0.000  |
     |  Intensity:                      2.000  |
     |  Mask - Gradient Switch:         0.000  |
     |  Mask - Gradient Type:           0.000  |
@@ -68,4 +70,8 @@ After adding LightStudio:
     [            Export All Profiles            ]
     [              Import Profiles              ]
  Misc
-    [            Find Missing Textures          ]
\ No newline at end of file
+    [            Find Missing Textures          ]
+    [            Open Textures Folder           ]
+    [           LightStudio Keying Set          ]
+ Hotkeys
+...
\ No newline at end of file

commit aa460f6ecb290be9901bff43c994e3e2c5850e83
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 14:30:16 2020 -0700

    comments out the 3D Edit button in the Selected Light menu

diff --git a/src/gui.py b/src/gui.py
index faf841d..be92642 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -42,7 +42,7 @@ class LLS_PT_Lights(bpy.types.Panel):
         layout = self.layout
         col = layout.column(align=True)
         row = col.row(align=True)
-        
+
         props = context.scene.LLStudio
 
         row = layout.row()
@@ -77,7 +77,7 @@ class LLS_PT_Selected(bpy.types.Panel):
             wm = context.window_manager
 
             col = layout.column(align=True)
-            col.operator('lls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
+            # col.operator('lls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
 
             box = layout.box()
             col = box.column()
@@ -268,7 +268,7 @@ class LLSPreferences(bpy.types.AddonPreferences):
                 keymap_modified = True
         if keymap_modified:
             col.operator("preferences.keymap_restore", text="Restore")
-        
+
         col.separator()
         box = layout.box()
         box.label(text="Internal object.delete operator wrappers to handle deleting of Light Studio objects.")

commit bc0f3cd878e7d9762481fe376add24e0f8ade98a
Merge: d632d33 7f975f3
Author: Amin Persia <leomoon@gmail.com>
Date:   Wed Oct 7 13:58:58 2020 -0700

    Merge pull request #29 from StyriamMZ/master
    
    2.6.2

commit 7f975f31772f7a57cd155f8da4518e92ef2b0967
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Oct 7 22:12:50 2020 +0200

    2.6.2

diff --git a/src/light_brush.py b/src/light_brush.py
index 92a43fe..8f27082 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -4,7 +4,7 @@ from math import *
 from mathutils.geometry import intersect_line_sphere
 from mathutils import Vector
 from bpy.props import *
-from . common import isFamily, family, findLightGrp, getLightMesh, getLightController
+from . common import isFamily, family, findLightGrp, getLightMesh, getLightController, get_user_keymap_item
 from . operators import LightOperator
 
            
@@ -192,7 +192,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
         override_event = OverrideEvent()
         override_event.mouse_region_x = event.mouse_x - active_region.x
         override_event.mouse_region_y = event.mouse_y - active_region.y
-        
+
         
         global key_released
         context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
@@ -232,7 +232,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
             elif event.type == 'LEFTMOUSE' and event.value == 'RELEASE' and key_released:
                 context.area.header_text_set(text=None)
                 return {'FINISHED'}
-            elif event.type in {'F', 'LEFTMOUSE'} and event.value == 'RELEASE':
+            elif event.type in {self.keymap_key, 'LEFTMOUSE'} and event.value == 'RELEASE':
                 key_released = True
                 return {'PASS_THROUGH'}
 
@@ -241,6 +241,8 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
 
     def invoke(self, context, event):
         context.window_manager.modal_handler_add(self)
+        km, kmi = get_user_keymap_item('Object Mode', self.__class__.bl_idname)
+        self.keymap_key = kmi.type if kmi else 'F'
         global key_released
         key_released = False
         if self.continuous:

commit b428210c0022d62b880e481fc6cce5f9bf3b4134
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Oct 7 21:39:31 2020 +0200

    2.6.2

diff --git a/src/gui.py b/src/gui.py
index 447e049..faf841d 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -257,11 +257,17 @@ class LLSPreferences(bpy.types.AddonPreferences):
 
         col = layout.column()
         kc = bpy.context.window_manager.keyconfigs.user
+        keymap_modified = False
         for km, kmi in light_brush.addon_keymaps + modal.addon_keymaps:
             km = km.active()
             col.context_pointer_set("keymap", km)
             user_km, user_kmi = get_user_keymap_item(km.name, kmi.idname)
-            rna_keymap_ui.draw_kmi(["ADDON", "USER", "DEFAULT"], kc, user_km, user_kmi, col, 0)
+            if user_kmi:
+                rna_keymap_ui.draw_kmi(["ADDON", "USER", "DEFAULT"], kc, user_km, user_kmi, col, 0)
+            else:
+                keymap_modified = True
+        if keymap_modified:
+            col.operator("preferences.keymap_restore", text="Restore")
         
         col.separator()
         box = layout.box()
diff --git a/src/operators/__init__.py b/src/operators/__init__.py
index ba9abc1..954e0e4 100644
--- a/src/operators/__init__.py
+++ b/src/operators/__init__.py
@@ -12,7 +12,7 @@ def update_clear():
     global UPDATED
     UPDATED = False
 
-VERBOSE = True
+VERBOSE = False
 
 from .. common import isFamily
 class LightOperator:
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 443f163..240b1ce 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -475,23 +475,6 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     self.modifier_key = True
                 if event.type in {"LEFT_CTRL"}:
                     self.ctrl = True
-                # elif event.type in {"G"} and not self.modifier_key:
-                #     active_object = LightImage.selected_object
-                #     if active_object:
-                #         bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
-                #         return {"RUNNING_MODAL"}
-                # elif event.type in {"R"} and not self.modifier_key:
-                #     active_object = LightImage.selected_object
-                    
-                #     if active_object:
-                #         bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
-                #         return {'RUNNING_MODAL'}
-                # elif event.type in {"S"} and not self.modifier_key:
-                #     active_object = LightImage.selected_object
-                    
-                #     if active_object:
-                #         bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
-                #         return {'RUNNING_MODAL'}
 
                 elif event.type == "RIGHTMOUSE":
                     dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)

commit d53101b511545c19bf6e300f22896f67f502bd58
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Oct 7 09:49:52 2020 +0200

    2.6.2

diff --git a/src/gui.py b/src/gui.py
index 0c0491f..447e049 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -294,4 +294,4 @@ def register():
                 traceback.print_exc()
             bpy.app.timers.register(functools.partial(read_keymaps, counter-1), first_interval=0.1)
 
-    read_keymaps(10)
\ No newline at end of file
+    bpy.app.timers.register(functools.partial(read_keymaps, 10), first_interval=0.1)
\ No newline at end of file
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 30abbac..443f163 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -51,7 +51,11 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
 
     def invoke(self, context, event):
         global running_modals
-        if not running_modals:
+        if running_modals:
+            active_object = LightImage.selected_object
+            self.mouse_x=active_object.loc.x
+            self.mouse_y=active_object.loc.y
+        else:
             # override starting mouse position
             self.mouse_x = context.area.width/2
             self.mouse_y = context.area.height/2
@@ -106,7 +110,11 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
 
     def invoke(self, context, event):
         global running_modals
-        if not running_modals:
+        if running_modals:
+            active_object = LightImage.selected_object
+            self.mouse_x=active_object.loc.x
+            self.mouse_y=active_object.loc.y
+        else:
             # override starting mouse position
             self.mouse_x = context.area.width/2
             self.mouse_y = context.area.height/2
@@ -156,8 +164,6 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
     bl_label = "Grab Light"
     bl_options = {"UNDO", "GRAB_CURSOR", "BLOCKING", "INTERNAL"}
 
-    canvas_width: bpy.props.FloatProperty()
-    canvas_height: bpy.props.FloatProperty()
 
     def __init__(self):
         super().__init__()
@@ -168,26 +174,34 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
         self.draw_guide = False
         self.allow_precision_mode = True
         self.precision_factor = 0.05
+        self.canvas_width = 1
+        self.canvas_height = 1
 
 
     def invoke(self, context, event):
         global running_modals
-        if not running_modals:
-            # override starting mouse position
-            self.mouse_x = context.area.width/2
-            self.mouse_y = context.area.height/2
-        super().invoke(context, event)
-        
+
         if running_modals:
+            global panel_global
+            # override starting mouse position
+            self.mouse_x = LightImage.selected_object.loc.x
+            self.mouse_y = LightImage.selected_object.loc.y
             self.light_mesh = LightImage.selected_object._lls_mesh
             self.light_actuator = LightImage.selected_object._lls_actuator
             self.base_object_rotation = self.light_actuator.rotation_euler.copy()
             self.base_object_distance = self.light_mesh.location.x
+            global panel_global
+            self.canvas_width = panel_global.width
+            self.canvas_height = panel_global.height
         else:
+            # override starting mouse position
+            self.mouse_x = context.area.width/2
+            self.mouse_y = context.area.height/2
             self.light_actuator = context.object.parent
             self.light_mesh = context.object
             self.base_object_rotation = context.object.parent.rotation_euler.copy()
             self.base_object_distance = context.object.location.x
+        super().invoke(context, event)
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
@@ -294,7 +308,6 @@ class LLS_OT_control_panel(bpy.types.Operator):
         self.panel = None
         self.panel_moving = False
         self.clicked_object = None
-        self.profile_collection = None
         self.click_manager = ClickManager()
         self.active_feature = None
         self.precision_mode = False
@@ -450,7 +463,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     else:
                         active_object = LightImage.selected_object
                         if active_object and not GRABBING:
-                            bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
+                            bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
                             self.panel_moving = False                    
                     
                     return {"RUNNING_MODAL"}
@@ -462,23 +475,23 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     self.modifier_key = True
                 if event.type in {"LEFT_CTRL"}:
                     self.ctrl = True
-                elif event.type in {"G"} and not self.modifier_key:
-                    active_object = LightImage.selected_object
-                    if active_object:
-                        bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
-                        return {"RUNNING_MODAL"}
-                elif event.type in {"R"} and not self.modifier_key:
-                    active_object = LightImage.selected_object
+                # elif event.type in {"G"} and not self.modifier_key:
+                #     active_object = LightImage.selected_object
+                #     if active_object:
+                #         bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
+                #         return {"RUNNING_MODAL"}
+                # elif event.type in {"R"} and not self.modifier_key:
+                #     active_object = LightImage.selected_object
                     
-                    if active_object:
-                        bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
-                        return {'RUNNING_MODAL'}
-                elif event.type in {"S"} and not self.modifier_key:
-                    active_object = LightImage.selected_object
+                #     if active_object:
+                #         bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
+                #         return {'RUNNING_MODAL'}
+                # elif event.type in {"S"} and not self.modifier_key:
+                #     active_object = LightImage.selected_object
                     
-                    if active_object:
-                        bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
-                        return {'RUNNING_MODAL'}
+                #     if active_object:
+                #         bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
+                #         return {'RUNNING_MODAL'}
 
                 elif event.type == "RIGHTMOUSE":
                     dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)

commit 8a4f625edb6c385798eb67934c11fd4b105e1a0f
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Oct 7 08:48:58 2020 +0200

    2.6.2

diff --git a/src/gui.py b/src/gui.py
index b46f32d..0c0491f 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -278,11 +278,20 @@ class LLSPreferences(bpy.types.AddonPreferences):
             user_keymap_items |= new_set
 
 def register():
-    try:
-        km, kmi = get_user_keymap_item('Object Mode', 'light_studio.scale')
-        LLS_PT_Hotkeys.scale_kmi_type = f'EVENT_{kmi.type}'
-        km, kmi = get_user_keymap_item('Object Mode', 'light_studio.rotate')
-        LLS_PT_Hotkeys.rotate_kmi_type = f'EVENT_{kmi.type}'
-    except Exception:
-        if operators.VERBOSE:
-            traceback.print_exc()
\ No newline at end of file
+    import functools
+    def read_keymaps(counter):
+        if counter == 0:
+            print("Keymaps not read.")
+            return
+
+        try:
+            km, kmi = get_user_keymap_item('Object Mode', 'light_studio.scale')
+            LLS_PT_Hotkeys.scale_kmi_type = f'EVENT_{kmi.type}'
+            km, kmi = get_user_keymap_item('Object Mode', 'light_studio.rotate')
+            LLS_PT_Hotkeys.rotate_kmi_type = f'EVENT_{kmi.type}'
+        except Exception:
+            if operators.VERBOSE:
+                traceback.print_exc()
+            bpy.app.timers.register(functools.partial(read_keymaps, counter-1), first_interval=0.1)
+
+    read_keymaps(10)
\ No newline at end of file

commit 2db3c8d5dd541b1ef786f10660eb2aaae1be5dbd
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Oct 7 08:31:37 2020 +0200

    2.6.2

diff --git a/src/gui.py b/src/gui.py
index 845258f..b46f32d 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -3,6 +3,7 @@ import os
 from . common import getLightMesh
 from . auto_load import force_register
 from . import operators
+import traceback
 
 @force_register
 class LLS_PT_Studio(bpy.types.Panel):
@@ -94,8 +95,8 @@ class LLS_PT_Selected(bpy.types.Panel):
                         col.prop(input, 'default_value', text=input.name)
             except:
                 col.label(text="LLS_light material is not valid.")
-                #import traceback
-                #traceback.print_exc()
+                if operators.VERBOSE:
+                    traceback.print_exc()
             col.prop(getLightMesh(), 'location', index=0) #light radius
 
 @force_register
@@ -241,15 +242,6 @@ class LLS_PT_Hotkeys(bpy.types.Panel):
 
         box.label(text="(numpad) Icon scale down", icon='REMOVE')
 
-def get_user_keymap_item(keymap_name, keymap_item_idname, multiple_entries=False):
-    wm = bpy.context.window_manager
-    kc = wm.keyconfigs.user
-
-    km = kc.keymaps.get(keymap_name)
-    if multiple_entries:
-        return km, [i[1] for i in km.keymap_items.items() if i[0] == keymap_item_idname]
-    else:
-        return km, km.keymap_items.get(keymap_item_idname)
 
 import rna_keymap_ui
 from . common import get_user_keymap_item
@@ -291,6 +283,6 @@ def register():
         LLS_PT_Hotkeys.scale_kmi_type = f'EVENT_{kmi.type}'
         km, kmi = get_user_keymap_item('Object Mode', 'light_studio.rotate')
         LLS_PT_Hotkeys.rotate_kmi_type = f'EVENT_{kmi.type}'
-    except Exception as e:
+    except Exception:
         if operators.VERBOSE:
-            print(e)
\ No newline at end of file
+            traceback.print_exc()
\ No newline at end of file

commit 0adc000b449f00faa8d0dd4870f1e89ad3074133
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Oct 7 07:48:58 2020 +0200

    2.6.2

diff --git a/src/deleteOperator.py b/src/deleteOperator.py
index 261f40d..1e07f9e 100644
--- a/src/deleteOperator.py
+++ b/src/deleteOperator.py
@@ -1,7 +1,8 @@
 import bpy
 from bpy.props import BoolProperty
-from . common import findLightGrp
+from . common import findLightGrp, isFamily
 from . import light_list
+from . operators import modal
 
 class DeleteOperator(bpy.types.Operator):
     """ Custom delete """
@@ -27,11 +28,19 @@ class DeleteOperator(bpy.types.Operator):
             if 'CANCELLED' in ret:
                 self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
         
-        bpy.ops.object.delete('INVOKE_DEFAULT', use_global=self.use_global, confirm=self.confirm)
+        bpy.ops.object.delete('INVOKE_DEFAULT', use_global=self.use_global, confirm=False)
 
         light_list.update_light_list_set(context)
 
         return {'FINISHED'}
+    
+    def invoke(self, context, event):
+        if self.confirm:
+            if not modal.running_modals:
+                return context.window_manager.invoke_confirm(self, event)
+            if modal.running_modals and not isFamily(context.object):
+                return context.window_manager.invoke_confirm(self, event)
+        return self.execute(context)
 
 
 
diff --git a/src/gui.py b/src/gui.py
index 2f723d0..845258f 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -2,6 +2,7 @@ import bpy
 import os
 from . common import getLightMesh
 from . auto_load import force_register
+from . import operators
 
 @force_register
 class LLS_PT_Studio(bpy.types.Panel):
@@ -203,6 +204,10 @@ class LLS_PT_Hotkeys(bpy.types.Panel):
     #def poll(cls, context):
     #    return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.LLStudio.initialized
 
+    scale_kmi_type = 'X'
+    rotate_kmi_type = 'X'
+
+
     def draw(self, context):
         layout = self.layout
         scene = context.scene
@@ -214,10 +219,10 @@ class LLS_PT_Hotkeys(bpy.types.Panel):
         box.label(text="Move light", icon='MOUSE_LMB')
         row = box.row(align=True)
 
-        row.label(text="Scale light", icon='EVENT_S')
+        row.label(text="Scale light", icon=self.__class__.scale_kmi_type)
         row = box.row(align=True)
 
-        row.label(text="Rotate light", icon='EVENT_R')
+        row.label(text="Rotate light", icon=self.__class__.rotate_kmi_type)
         row = box.row(align=True)
 
         row.label(text="Precision mode", icon='EVENT_SHIFT')
@@ -279,3 +284,13 @@ class LLSPreferences(bpy.types.AddonPreferences):
             for new_item in new_set:
                 rna_keymap_ui.draw_kmi(["ADDON", "USER", "DEFAULT"], kc, user_km, new_item, box, 0)
             user_keymap_items |= new_set
+
+def register():
+    try:
+        km, kmi = get_user_keymap_item('Object Mode', 'light_studio.scale')
+        LLS_PT_Hotkeys.scale_kmi_type = f'EVENT_{kmi.type}'
+        km, kmi = get_user_keymap_item('Object Mode', 'light_studio.rotate')
+        LLS_PT_Hotkeys.rotate_kmi_type = f'EVENT_{kmi.type}'
+    except Exception as e:
+        if operators.VERBOSE:
+            print(e)
\ No newline at end of file
diff --git a/src/light_brush.py b/src/light_brush.py
index c70b29d..92a43fe 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -11,7 +11,6 @@ from . operators import LightOperator
 def raycast(context, event, diff):
     """Run this function on left mouse, execute the ray cast"""
     # get the context arguments
-    scene = context.scene
     region = context.region
     rv3d = context.region_data
     coord = event.mouse_region_x, event.mouse_region_y
@@ -157,6 +156,10 @@ class LLSLightBrush(bpy.types.Operator, LightOperator):
             self.report({'WARNING'}, "Active space must be a View3d")
             return {'CANCELLED'}
 
+class OverrideContext:
+    pass
+class OverrideEvent:
+    pass
 key_released = False
 class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
     """Point on object to position light and reflection"""
@@ -168,10 +171,32 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
     normal_type: BoolProperty(default=False, name="Light along normal", description="Default reflection type.\n ON: Light along normal\n OFF: surface reflection (what you are looking for in most cases)")
     
     def modal(self, context, event):
+        screens = [window.screen for window in context.window_manager.windows]
+        regions3d = [(area.spaces[0].region_3d, region) for screen in screens for area in screen.areas if area.type == context.area.type for region in area.regions if region.type == context.region.type]
+        active_region = context.region
+        active_region_data = context.region_data
+        for region_data, region in regions3d:
+            if event.mouse_x >= region.x and event.mouse_x <= region.x + region.width and \
+                event.mouse_y >= region.y and event.mouse_y <= region.y + region.height:
+                active_region = region
+                active_region_data = region_data
+                break
+
+        override_context = OverrideContext()
+        override_context.region = active_region
+        override_context.region_data = active_region_data
+        override_context.visible_objects = context.visible_objects
+        override_context.active_object = context.active_object
+        if hasattr(context, 'depsgraph'):
+            override_context.depsgraph = context.depsgraph
+        override_event = OverrideEvent()
+        override_event.mouse_region_x = event.mouse_x - active_region.x
+        override_event.mouse_region_y = event.mouse_y - active_region.y
+        
+        
         global key_released
         context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
         # print(event.type, event.value)
-        
         if self.continuous:
             if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
                 # allow navigation
@@ -183,7 +208,7 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
                 self.normal_type = not self.normal_type
                 return {'RUNNING_MODAL'}
             elif event.type == 'MOUSEMOVE':
-                raycast(context, event, self.normal_type)
+                raycast(override_context, override_event, self.normal_type)
                 return {'PASS_THROUGH'}
             elif event.value == 'RELEASE' and not event.type in {'MOUSEMOVE', 'INBETWEEN_MOUSEMOVE', 'N'}:
                 context.area.header_text_set(text=None)
@@ -201,8 +226,8 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
             elif event.type == 'N' and event.value == 'PRESS':
                 self.normal_type = not self.normal_type
                 return {'RUNNING_MODAL'}
-            elif event.type == 'MOUSEMOVE' and event.value == 'PRESS' and key_released:
-                raycast(context, event, self.normal_type)
+            elif event.type in {'MOUSEMOVE', 'LEFTMOUSE'} and event.value == 'PRESS' and key_released:
+                raycast(override_context, override_event, self.normal_type)
                 return {'PASS_THROUGH'}
             elif event.type == 'LEFTMOUSE' and event.value == 'RELEASE' and key_released:
                 context.area.header_text_set(text=None)
@@ -218,6 +243,8 @@ class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
         context.window_manager.modal_handler_add(self)
         global key_released
         key_released = False
+        if self.continuous:
+            raycast(context, event, self.normal_type)
         return {'RUNNING_MODAL'}
 
 addon_keymaps = []

commit b7142d666f75a2f7dee7a073718d453f79aefe33
Merge: baba6a3 52af142
Author: StyriamMZ <styriam@o2.pl>
Date:   Tue Oct 6 23:59:32 2020 +0200

    Merge branch 'master' of https://github.com/StyriamMZ/leomoon-lightstudio-1

commit baba6a37eecff5e443463889038f7dd902dc8cd3
Author: StyriamMZ <styriam@o2.pl>
Date:   Tue Oct 6 23:58:46 2020 +0200

    2.6.2

diff --git a/src/LLS3.blend b/src/LLS3.blend
index 1ec5e5c..f0e1cc8 100644
Binary files a/src/LLS3.blend and b/src/LLS3.blend differ
diff --git a/src/__init__.py b/src/__init__.py
index fc8d892..ea52a14 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -1,10 +1,10 @@
-#Created by Striam Sp. z o.o.
+#Created by Styriam sp. z o.o.
 
 bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 6, 1),
+    "version": (2, 6, 2),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
@@ -25,7 +25,8 @@ auto_load.init()
 ################################## 
 
 from . light_operators import LeoMoon_Light_Studio_Properties, LeoMoon_Light_Studio_Object_Properties
-from . import deleteOperator
+from . import deleteOperator, light_brush
+from . operators import modal
 
 def register():
     auto_load.register()
@@ -33,8 +34,16 @@ def register():
     bpy.types.Scene.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Properties", type = LeoMoon_Light_Studio_Properties)
     bpy.types.Object.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Object Properties", type = LeoMoon_Light_Studio_Object_Properties)
     deleteOperator.add_shortkeys()
+    light_brush.add_shortkeys()
+    modal.add_shortkeys()
+    bpy.app.handlers.load_post.append(modal.load_handler)
+    bpy.app.handlers.frame_change_pre.append(modal.frame_change_handler)
     
 
 def unregister():
     deleteOperator.remove_shortkeys()
+    light_brush.remove_shortkeys()
+    modal.remove_shortkeys()
     auto_load.unregister()
+    bpy.app.handlers.load_post.remove(modal.load_handler)
+    bpy.app.handlers.frame_change_pre.remove(modal.frame_change_handler)
diff --git a/src/common.py b/src/common.py
index 6fe8693..49ef486 100644
--- a/src/common.py
+++ b/src/common.py
@@ -1,5 +1,15 @@
 import bpy
 
+def get_user_keymap_item(keymap_name, keymap_item_idname, multiple_entries=False):
+    wm = bpy.context.window_manager
+    kc = wm.keyconfigs.user
+
+    km = kc.keymaps.get(keymap_name)
+    if multiple_entries:
+        return km, [i[1] for i in km.keymap_items.items() if i[0] == keymap_item_idname]
+    else:
+        return km, km.keymap_items.get(keymap_item_idname)
+
 def replace_link(object, collection_name):
     if isinstance(object, bpy.types.Collection):
         bpy.context.scene.collection.children.unlink(bpy.context.scene.collection.children[object.name])
diff --git a/src/deleteOperator.py b/src/deleteOperator.py
index c4998d3..261f40d 100644
--- a/src/deleteOperator.py
+++ b/src/deleteOperator.py
@@ -9,7 +9,8 @@ class DeleteOperator(bpy.types.Operator):
     bl_label = "Custom Delete"
     bl_options = {'REGISTER', 'UNDO'}
 
-    use_global: BoolProperty(default = False)
+    use_global: BoolProperty(default = False, name="Delete Globally")
+    confirm: BoolProperty(default = True, name="Confirm")
 
     @classmethod
     def poll(cls, context):
@@ -26,40 +27,50 @@ class DeleteOperator(bpy.types.Operator):
             if 'CANCELLED' in ret:
                 self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
         
-        bpy.ops.object.delete(use_global=self.use_global)
+        bpy.ops.object.delete('INVOKE_DEFAULT', use_global=self.use_global, confirm=self.confirm)
 
         light_list.update_light_list_set(context)
 
         return {'FINISHED'}
 
-    # def invoke(self, context, event):
-    #     wm = context.window_manager
-    #     return wm.invoke_confirm(self, event)
-        
+
+
+def register_keymaps():
+    kc = bpy.context.window_manager.keyconfigs
+    areas = 'Window', 'Text', 'Object Mode', '3D View'
+
+    if not all(i in kc.active.keymaps for i in areas):
+        bpy.app.timers.register(register_keymaps, first_interval=0.1)
+    else:
+        # can now proceed with checking default kmis
+        km, kmis =  get_user_keymap_item('Object Mode', 'object.delete', multiple_entries=True)
+        wm = bpy.context.window_manager
+        addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
+        for default_kmi in kmis:
+            addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, default_kmi.type, default_kmi.value)
+            addon_kmi.map_type = default_kmi.map_type
+            addon_kmi.repeat = default_kmi.repeat
+            addon_kmi.any = default_kmi.any
+            addon_kmi.shift = default_kmi.shift
+            addon_kmi.ctrl = default_kmi.ctrl
+            addon_kmi.alt = default_kmi.alt
+            addon_kmi.oskey = default_kmi.oskey
+            addon_kmi.key_modifier = default_kmi.key_modifier
+            addon_kmi.properties.use_global = default_kmi.properties.use_global
+            addon_kmi.properties.confirm = default_kmi.properties.confirm
+            
+            addon_keymaps.append((addon_km, addon_kmi))
+
+
+from . common import get_user_keymap_item
 addon_keymaps = []
-def add_shortkeys():       
-    wm = bpy.context.window_manager
-    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
-    addon_kmi.properties.use_global = False
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
-    addon_kmi.shift = True
-    addon_kmi.properties.use_global = True
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
-    addon_kmi.properties.use_global = False
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
-    addon_kmi.shift = True
-    addon_kmi.properties.use_global = True
-    
-    addon_keymaps.append(addon_km)
+def add_shortkeys():
+    # overcome load-addons-before-keyconfigs issue
+    register_keymaps()
 
 def remove_shortkeys():
     wm = bpy.context.window_manager
-    for km in addon_keymaps:
-        wm.keyconfigs.addon.keymaps.remove(km)
+    for km, kmi in addon_keymaps:
+        km.keymap_items.remove(kmi)
         
-    addon_keymaps.clear()
+    addon_keymaps.clear()
\ No newline at end of file
diff --git a/src/gui.py b/src/gui.py
index f00d3bb..2f723d0 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -235,3 +235,47 @@ class LLS_PT_Hotkeys(bpy.types.Panel):
         box.label(text="(numpad) Icon scale up", icon='ADD')
 
         box.label(text="(numpad) Icon scale down", icon='REMOVE')
+
+def get_user_keymap_item(keymap_name, keymap_item_idname, multiple_entries=False):
+    wm = bpy.context.window_manager
+    kc = wm.keyconfigs.user
+
+    km = kc.keymaps.get(keymap_name)
+    if multiple_entries:
+        return km, [i[1] for i in km.keymap_items.items() if i[0] == keymap_item_idname]
+    else:
+        return km, km.keymap_items.get(keymap_item_idname)
+
+import rna_keymap_ui
+from . common import get_user_keymap_item
+from . import light_brush, deleteOperator
+from . operators import modal
+class LLSPreferences(bpy.types.AddonPreferences):
+    # this must match the addon name, use '__package__'
+    # when defining this in a submodule of a python package.
+    bl_idname = __package__
+
+    def draw(self, context):
+        layout = self.layout
+
+        col = layout.column()
+        kc = bpy.context.window_manager.keyconfigs.user
+        for km, kmi in light_brush.addon_keymaps + modal.addon_keymaps:
+            km = km.active()
+            col.context_pointer_set("keymap", km)
+            user_km, user_kmi = get_user_keymap_item(km.name, kmi.idname)
+            rna_keymap_ui.draw_kmi(["ADDON", "USER", "DEFAULT"], kc, user_km, user_kmi, col, 0)
+        
+        col.separator()
+        box = layout.box()
+        box.label(text="Internal object.delete operator wrappers to handle deleting of Light Studio objects.")
+        box.label(text="Wrapper operators copy their counterparts's settings during addon start.")
+        user_keymap_items = set()
+        for km, kmi in deleteOperator.addon_keymaps:
+            km = km.active()
+            box.context_pointer_set("keymap", km)
+            user_km, user_kmis = get_user_keymap_item(km.name, kmi.idname, multiple_entries=True)
+            new_set = set(user_kmis) - user_keymap_items
+            for new_item in new_set:
+                rna_keymap_ui.draw_kmi(["ADDON", "USER", "DEFAULT"], kc, user_km, new_item, box, 0)
+            user_keymap_items |= new_set
diff --git a/src/light_brush.py b/src/light_brush.py
index 0b3cc7f..c70b29d 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -5,7 +5,7 @@ from mathutils.geometry import intersect_line_sphere
 from mathutils import Vector
 from bpy.props import *
 from . common import isFamily, family, findLightGrp, getLightMesh, getLightController
-
+from . operators import LightOperator
 
            
 def raycast(context, event, diff):
@@ -109,33 +109,23 @@ def raycast(context, event, diff):
     deg = copysign(degrees(Vector.angle(Vector((x,y,z)), Vector((x,y,0)))), z)
     actuator.rotation_euler.y = copysign(Vector.angle(Vector((x,y,z)), Vector((x,y,0))), z)
 
-class LLSLightBrush(bpy.types.Operator):
+class LLSLightBrush(bpy.types.Operator, LightOperator):
     """Click on object to position light and reflection"""
     bl_idname = "lls.light_brush"
     bl_label = "Light Brush"
     bl_options = {"UNDO"}
     
     aux: BoolProperty(default=False) # is aux operator working
-    diffuse_type: BoolProperty(default=False)
-    
-    @classmethod
-    def poll(cls, context):
-        light = context.active_object
-        return context.area.type == 'VIEW_3D' and \
-               context.mode == 'OBJECT' and \
-               context.scene.LLStudio.initialized and \
-               light and \
-               isFamily(light) and \
-               not (light.name.startswith('LLS_PANEL') or light.name.startswith('LLS_PROFILE') or light.name.startswith('LLS_LIGHT_GRP'))
+    normal_type: BoolProperty(default=False)
 
     def modal(self, context, event):
-        print(event.type, event.value)
+        # print(event.type, event.value)
         if self.aux:
             if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
                 self.aux = False
             return {'RUNNING_MODAL'}
         
-        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.diffuse_type else '[Reflection] | Normal'}")
+        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
         
         if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'Z', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
             # allow navigation
@@ -145,16 +135,16 @@ class LLSLightBrush(bpy.types.Operator):
             return {'FINISHED'}
         elif event.type == 'LEFTMOUSE':
             if event.value == 'PRESS':
-                raycast(context, event, self.diffuse_type)
+                raycast(context, event, self.normal_type)
                 return {'RUNNING_MODAL'}
             elif event.value == 'RELEASE':
                 return {'PASS_THROUGH'}
         elif event.type == 'MOUSEMOVE':
             if event.value == 'PRESS':
-                raycast(context, event, self.diffuse_type)
+                raycast(context, event, self.normal_type)
                 return {'PASS_THROUGH'}
         elif event.type == 'N' and event.value == 'PRESS':
-            self.diffuse_type = not self.diffuse_type
+            self.normal_type = not self.normal_type
 
         #return {'PASS_THROUGH'}
         return {'RUNNING_MODAL'}
@@ -165,4 +155,84 @@ class LLSLightBrush(bpy.types.Operator):
             return {'RUNNING_MODAL'}
         else:
             self.report({'WARNING'}, "Active space must be a View3d")
-            return {'CANCELLED'}
\ No newline at end of file
+            return {'CANCELLED'}
+
+key_released = False
+class OT_LLSFast3DEdit(bpy.types.Operator, LightOperator):
+    """Point on object to position light and reflection"""
+    bl_idname = "light_studio.fast_3d_edit"
+    bl_label = "Fast 3D Edit"
+    bl_options = {"UNDO"}
+    
+    continuous: BoolProperty(default=False, name="Hold to use", description="Button behaviour.\n ON: Hold button to use. Release button to stop.\n OFF: Hold LMB to use, release LMB to stop.")
+    normal_type: BoolProperty(default=False, name="Light along normal", description="Default reflection type.\n ON: Light along normal\n OFF: surface reflection (what you are looking for in most cases)")
+    
+    def modal(self, context, event):
+        global key_released
+        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.normal_type else '[Reflection] | Normal'}")
+        # print(event.type, event.value)
+        
+        if self.continuous:
+            if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
+                # allow navigation
+                return {'PASS_THROUGH'}
+            elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
+                context.area.header_text_set(text=None)
+                return {'FINISHED'}
+            elif event.type == 'N' and event.value == 'PRESS':
+                self.normal_type = not self.normal_type
+                return {'RUNNING_MODAL'}
+            elif event.type == 'MOUSEMOVE':
+                raycast(context, event, self.normal_type)
+                return {'PASS_THROUGH'}
+            elif event.value == 'RELEASE' and not event.type in {'MOUSEMOVE', 'INBETWEEN_MOUSEMOVE', 'N'}:
+                context.area.header_text_set(text=None)
+                return {'FINISHED'}
+            elif event.value == 'RELEASE':
+                key_released = True
+                return {'PASS_THROUGH'}
+        else:
+            if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
+                # allow navigation
+                return {'PASS_THROUGH'}
+            elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
+                context.area.header_text_set(text=None)
+                return {'FINISHED'}
+            elif event.type == 'N' and event.value == 'PRESS':
+                self.normal_type = not self.normal_type
+                return {'RUNNING_MODAL'}
+            elif event.type == 'MOUSEMOVE' and event.value == 'PRESS' and key_released:
+                raycast(context, event, self.normal_type)
+                return {'PASS_THROUGH'}
+            elif event.type == 'LEFTMOUSE' and event.value == 'RELEASE' and key_released:
+                context.area.header_text_set(text=None)
+                return {'FINISHED'}
+            elif event.type in {'F', 'LEFTMOUSE'} and event.value == 'RELEASE':
+                key_released = True
+                return {'PASS_THROUGH'}
+
+        #return {'PASS_THROUGH'}
+        return {'RUNNING_MODAL'}
+
+    def invoke(self, context, event):
+        context.window_manager.modal_handler_add(self)
+        global key_released
+        key_released = False
+        return {'RUNNING_MODAL'}
+
+addon_keymaps = []
+def add_shortkeys():
+    wm = bpy.context.window_manager
+    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type="EMPTY")
+    
+    addon_kmi = addon_km.keymap_items.new(OT_LLSFast3DEdit.bl_idname, 'F', 'PRESS')
+    addon_kmi.properties.continuous = False
+    
+    addon_keymaps.append((addon_km, addon_kmi))
+
+def remove_shortkeys():
+    wm = bpy.context.window_manager
+    for km, kmi in addon_keymaps:
+        km.keymap_items.remove(kmi)
+        
+    addon_keymaps.clear()
\ No newline at end of file
diff --git a/src/light_list.py b/src/light_list.py
index 7079e21..cbd8b0b 100644
--- a/src/light_list.py
+++ b/src/light_list.py
@@ -12,7 +12,11 @@ _ = os.sep
 class LightListItem(bpy.types.PropertyGroup):
     """ Group of properties representing an item in the list """
     def update_name(self, context):
-        bpy.data.objects[self.mesh_name].LLStudio.light_name = self.name
+        name = self.name
+        if self.name == '':
+            name = self.mesh_name
+            self.name = name
+        bpy.data.objects[self.mesh_name].LLStudio.light_name = name
 
     name: StringProperty(
             name="Profile Name",
@@ -73,7 +77,7 @@ def set_list_index(self, index):
         bpy.context.view_layer.objects.active = ob
         ob.select_set(True)
 
-    if modal.panel_global:
+    if modal.running_modals:
         light_icon = [l for l in LightImage.lights if l._lls_mesh == ob][0]
         send_light_to_top(light_icon)
 
diff --git a/src/operators/__init__.py b/src/operators/__init__.py
index e71d203..ba9abc1 100644
--- a/src/operators/__init__.py
+++ b/src/operators/__init__.py
@@ -1,6 +1,3 @@
-# class UpdateChecker:
-#     def __init__(self):
-#         self.updated
 UPDATED = True
 
 def is_updated():
@@ -13,4 +10,19 @@ def update():
 
 def update_clear():
     global UPDATED
-    UPDATED = False
\ No newline at end of file
+    UPDATED = False
+
+VERBOSE = True
+
+from .. common import isFamily
+class LightOperator:
+    @classmethod
+    def poll(cls, context):
+        object = context.active_object
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.space_data.type == 'VIEW_3D' and \
+               context.scene.LLStudio.initialized and \
+               object and \
+               object.name.startswith('LLS_LIGHT_MESH') and \
+               isFamily(object)
\ No newline at end of file
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 819244a..30abbac 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -8,7 +8,9 @@ from .. import light_list
 
 from .modal_utils import shader2Dcolor
 from gpu_extras.batch import batch_for_shader
-import time
+import time, traceback
+from mathutils.geometry import intersect_line_line_2d
+from . import VERBOSE, LightOperator
 
 #textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale | [Ctrl+Click] Loop overlapping"
 
@@ -25,21 +27,41 @@ def draw(self, area):
         b.draw(self.mouse_x, self.mouse_y)
     for l in LightImage.lights:
         l.draw()
+    
+    if VERBOSE:
+        font_size = 14
+        blf.size(0, font_size, 72)
+        excluded = {'click_manager', 'panel', 'handler'}
+        for i, kv in enumerate([(k, v) for k, v in self.__dict__.items() if not k in excluded]):
+            k, v = kv[:]
+            blf.position(0, 55, area.height-115 - (font_size+5)*i, 0)
+            blf.draw(0, f'{k}: {v}')
+
 
-class LLS_OT_Rotate(bpy.types.Operator, MouseWidget):
+class LLS_OT_Rotate(bpy.types.Operator, MouseWidget, LightOperator):
     bl_idname = "light_studio.rotate"
     bl_label = "Rotate Light"
     bl_options = {"REGISTER", "UNDO", "INTERNAL"}
 
     def __init__(self):
         super().__init__()
-        self.pivot = Vector((self.mouse_x, self.mouse_y))
+        # self.pivot = Vector((self.mouse_x, self.mouse_y))
         self.base_object_rotation = 0
         self.allow_precision_mode = True
 
     def invoke(self, context, event):
+        global running_modals
+        if not running_modals:
+            # override starting mouse position
+            self.mouse_x = context.area.width/2
+            self.mouse_y = context.area.height/2
         super().invoke(context, event)
-        self.base_object_rotation = LightImage.selected_object._lls_mesh.rotation_euler.x
+
+        if running_modals:
+            self.base_object_rotation = LightImage.selected_object._lls_mesh.rotation_euler.x
+        else:
+            self.base_object_rotation = context.object.rotation_euler.x
+
         return {"RUNNING_MODAL"}
     
     def _finish(self, context, event):
@@ -47,12 +69,22 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget):
         #context.area.header_text_set(text=None)
 
     def _cancel(self, context, event):
-        LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation
+        global running_modals
+        if running_modals:
+            LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation
+        else:
+            context.object.rotation_euler.x = self.base_object_rotation
+
         bpy.context.workspace.status_text_set(None)
         #context.area.header_text_set(text=None)
 
     def _modal(self, context, event):
-        LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
+        global running_modals
+        if running_modals:
+            LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
+        else:
+            context.object.rotation_euler.x = self.base_object_rotation + self.angle()
+
         bpy.context.workspace.status_text_set(f"Rot: {self.angle():.3f}")
         #context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
 
@@ -60,7 +92,7 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget):
             return {"RUNNING_MODAL"}
         return {"PASS_THROUGH"}
 
-class LLS_OT_Scale(bpy.types.Operator, MouseWidget):
+class LLS_OT_Scale(bpy.types.Operator, MouseWidget, LightOperator):
     bl_idname = "light_studio.scale"
     bl_label = "Scale Light"
     bl_options = {"GRAB_CURSOR", "BLOCKING", "REGISTER", "UNDO", "INTERNAL"}
@@ -73,12 +105,25 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget):
         self.allow_precision_mode = True
 
     def invoke(self, context, event):
+        global running_modals
+        if not running_modals:
+            # override starting mouse position
+            self.mouse_x = context.area.width/2
+            self.mouse_y = context.area.height/2
         super().invoke(context, event)
-        self.base_object_scale = LightImage.selected_object._lls_mesh.scale.copy()
+        
+        if running_modals:
+            self.base_object_scale = LightImage.selected_object._lls_mesh.scale.copy()
+        else:
+            self.base_object_scale = context.object.scale.copy()
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
-        LightImage.selected_object._lls_mesh.scale = self.base_object_scale
+        global running_modals
+        if running_modals:
+            LightImage.selected_object._lls_mesh.scale = self.base_object_scale
+        else:
+            context.object.scale = self.base_object_scale
         bpy.context.workspace.status_text_set(None)
         #context.area.header_text_set(text=None)
 
@@ -93,7 +138,11 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget):
         if self.y_key:
             new_scale.y = self.base_object_scale.y
 
-        LightImage.selected_object._lls_mesh.scale = new_scale
+        global running_modals
+        if running_modals:
+            LightImage.selected_object._lls_mesh.scale = new_scale
+        else:
+            context.object.scale = new_scale
         bpy.context.workspace.status_text_set(f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
         #context.area.header_text_set(text=f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
 
@@ -102,10 +151,10 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget):
         return {"PASS_THROUGH"}
 
 GRABBING = False
-class LLS_OT_Grab(bpy.types.Operator, MouseWidget):
+class LLS_OT_Grab(bpy.types.Operator, MouseWidget, LightOperator):
     bl_idname = "light_studio.grab"
     bl_label = "Grab Light"
-    bl_options = {"GRAB_CURSOR", "BLOCKING", "INTERNAL"}
+    bl_options = {"UNDO", "GRAB_CURSOR", "BLOCKING", "INTERNAL"}
 
     canvas_width: bpy.props.FloatProperty()
     canvas_height: bpy.props.FloatProperty()
@@ -118,14 +167,34 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget):
         self.continous = True
         self.draw_guide = False
         self.allow_precision_mode = True
+        self.precision_factor = 0.05
+
 
     def invoke(self, context, event):
+        global running_modals
+        if not running_modals:
+            # override starting mouse position
+            self.mouse_x = context.area.width/2
+            self.mouse_y = context.area.height/2
         super().invoke(context, event)
-        self.base_object_rotation = LightImage.selected_object._lls_actuator.rotation_euler.copy()
+        
+        if running_modals:
+            self.light_mesh = LightImage.selected_object._lls_mesh
+            self.light_actuator = LightImage.selected_object._lls_actuator
+            self.base_object_rotation = self.light_actuator.rotation_euler.copy()
+            self.base_object_distance = self.light_mesh.location.x
+        else:
+            self.light_actuator = context.object.parent
+            self.light_mesh = context.object
+            self.base_object_rotation = context.object.parent.rotation_euler.copy()
+            self.base_object_distance = context.object.location.x
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
-        LightImage.selected_object._lls_actuator.rotation_euler = self.base_object_rotation
+        global running_modals
+        self.light_actuator.rotation_euler = self.base_object_rotation
+        self.light_mesh.location.x = self.base_object_distance
+        
         global GRABBING
         GRABBING = False
         bpy.context.workspace.status_text_set(None)
@@ -141,23 +210,67 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget):
         dv = self.delta_vector()
         if self.x_key:
             dv.y = 0
-        if self.y_key:
+        elif self.y_key:
             dv.x = 0
 
-        x_factor = 2*pi / self.canvas_width
-        y_factor = pi / self.canvas_height
+        global running_modals
+        if running_modals:
+            x_factor = 2*pi / self.canvas_width
+            y_factor = pi / self.canvas_height
+        else:
+            x_factor = .0025 #2*pi / 500
+            y_factor = .0025 #pi / 250
+
+        if self.z_key:
+            self.light_mesh.location.x = max(self.base_object_distance + dv.x * 0.05, 0)
+            import bpy_extras
+            self.z_start_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, self.light_mesh.matrix_world.to_translation().normalized() * context.space_data.clip_end)
+            self.z_end_position = bpy_extras.view3d_utils.location_3d_to_region_2d(context.region, context.space_data.region_3d, Vector((0,0,0)))
+            if running_modals:
+                global panel_global
+                v1 = panel_global.point_lt
+                v2 = Vector((panel_global.point_rb.x, panel_global.point_lt.y))
+                v3 = panel_global.point_rb
+                v4 = Vector((panel_global.point_lt.x, panel_global.point_rb.y))
+                lines = [(v1, v2), (v2, v3), (v3, v4), (v1, v4)]
+                shortest = None
+                for v1, v2 in lines:
+                    intersection = intersect_line_line_2d(self.z_start_position, self.z_end_position, v1, v2)
+                    if intersection:
+                        length = (self.z_start_position - intersection).length
+                        if not shortest or length < shortest:
+                            shortest = length
+                            self.z_end_position = intersection
+
+        else:
+            self.light_actuator.rotation_euler = self.base_object_rotation.copy()
+            self.light_actuator.rotation_euler.x += dv.x * x_factor
+            self.light_actuator.rotation_euler.y += dv.y * y_factor
+            self.light_actuator.rotation_euler.y = clamp(-pi/2 + 0.000001, self.light_actuator.rotation_euler.y, pi/2 - 0.000001)
 
-        LightImage.selected_object._lls_actuator.rotation_euler = self.base_object_rotation.copy()
-        LightImage.selected_object._lls_actuator.rotation_euler.x += dv.x * x_factor
-        LightImage.selected_object._lls_actuator.rotation_euler.y += dv.y * y_factor
-        LightImage.selected_object._lls_actuator.rotation_euler.y = clamp(-pi/2 + 0.000001, LightImage.selected_object._lls_actuator.rotation_euler.y, pi/2 - 0.000001)
-        bpy.context.workspace.status_text_set(f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
+        bpy.context.workspace.status_text_set(f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis  [Z] Distance  [Shift] Precision Mode")
         #context.area.header_text_set(text=f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
 
         if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
             return {"RUNNING_MODAL"}
         return {"PASS_THROUGH"}
 
+from bpy.app.handlers import persistent
+@persistent
+def load_handler(dummy):
+    global running_modals
+    running_modals = 0
+
+scene_before_frame_change = None
+@persistent
+def frame_change_handler(scene):
+    global panel_global
+    global running_modals
+    global scene_before_frame_change
+    if running_modals and panel_global and scene.name != scene_before_frame_change:
+        update_light_sets(panel_global, bpy.context, always=True)
+        scene_before_frame_change = scene.name
+
 panel_global = None
 running_modals = 0
 W_LEFT = 1
@@ -186,17 +299,21 @@ class LLS_OT_control_panel(bpy.types.Operator):
         self.active_feature = None
         self.precision_mode = False
         self.border_touch = 0
+        self.modifier_key = False
+        self.ctrl = False
 
     def __del__(self):
+        if VERBOSE: print("Panel __del__")
         self._unregister_handler()
 
     def _unregister_handler(self):
         global running_modals
         running_modals = max(0, running_modals-1)
         try:
-            bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
+            if hasattr(self, 'handler'):
+                bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
         except (ValueError, AttributeError):
-            pass
+            if VERBOSE: traceback.print_exc()
 
     def _mouse_event(self, context, event):
         area_mouse_x = event.mouse_x - context.area.x
@@ -328,36 +445,36 @@ class LLS_OT_control_panel(bpy.types.Operator):
                 if self.clicked_object and self.panel_moving:
                     if isinstance(self.clicked_object, Panel):
                         self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
+                    elif isinstance(self.clicked_object, Button):
+                        pass
                     else:
-                        active_object = None
-                        if LightImage.selected_object:
-                            active_object = LightImage.selected_object
+                        active_object = LightImage.selected_object
                         if active_object and not GRABBING:
                             bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
-                            self.panel_moving = False
+                            self.panel_moving = False                    
                     
                     return {"RUNNING_MODAL"}
 
                 return {"PASS_THROUGH"}
             
             if event.value == "PRESS":
-                if event.type in {"LEFT_CTRL"}:
-                    self.ctrl = True
                 if event.type in {"LEFT_CTRL", "RIGHT_CTRL", "LEFT_SHIFT", "RIGHT_SHIFT", "LEFT_ALT", "RIGHT_ALT"}:
                     self.modifier_key = True
-                
-                if event.type in {"R"} and not self.modifier_key:
-                    active_object = None
-                    if LightImage.selected_object:
-                        active_object = LightImage.selected_object
+                if event.type in {"LEFT_CTRL"}:
+                    self.ctrl = True
+                elif event.type in {"G"} and not self.modifier_key:
+                    active_object = LightImage.selected_object
+                    if active_object:
+                        bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
+                        return {"RUNNING_MODAL"}
+                elif event.type in {"R"} and not self.modifier_key:
+                    active_object = LightImage.selected_object
                     
                     if active_object:
                         bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
                         return {'RUNNING_MODAL'}
                 elif event.type in {"S"} and not self.modifier_key:
-                    active_object = None
-                    if LightImage.selected_object:
-                        active_object = LightImage.selected_object
+                    active_object = LightImage.selected_object
                     
                     if active_object:
                         bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
@@ -441,14 +558,16 @@ class LLS_OT_control_panel(bpy.types.Operator):
                         try:
                             self.clicked_object.select()
                         except RuntimeError:
-                            print("Stale panel context. Panel closed.")
-                            close_control_panel()
-
-                        if self.ctrl and len(overlapped)>1:
-                            send_light_to_bottom(self.clicked_object)
-                            self.find_clicked(area_mouse_x, area_mouse_y).select()
+                            print("Stale panel context. Reloaded.")
+                            # close_control_panel()
+                            update_light_sets(self.panel, context, always=True)
+                            if VERBOSE: traceback.print_exc()
                         else:
-                            send_light_to_top(self.clicked_object)
+                            if self.ctrl and len(overlapped)>1:
+                                send_light_to_bottom(self.clicked_object)
+                                self.find_clicked(area_mouse_x, area_mouse_y).select()
+                            else:
+                                send_light_to_top(self.clicked_object)
 
 
                     if hasattr(self.clicked_object, 'click'):
@@ -484,22 +603,21 @@ class LLS_OT_control_panel(bpy.types.Operator):
             if event.value == "RELEASE":
                 #bpy.context.workspace.status_text_set(textinfo)
                 #context.area.header_text_set(text=textinfo)
+                if event.type in {"LEFT_CTRL", "RIGHT_CTRL", "LEFT_SHIFT", "RIGHT_SHIFT", "LEFT_ALT", "RIGHT_ALT"}:
+                    self.modifier_key = False
                 if event.type == "LEFTMOUSE":
                     self.panel_moving = False
                     self.border_touch = 0
                 elif event.type == "LEFT_SHIFT":
                     self.precision_mode = False
                     return {'RUNNING_MODAL'}
-                if event.type in {"LEFT_CTRL", "RIGHT_CTRL", "LEFT_SHIFT", "RIGHT_SHIFT", "LEFT_ALT", "RIGHT_ALT"}:
-                    self.modifier_key = False
             elif event.value == "CLICK":
                 # Left mouse button clicked
                 if event.type == "LEFTMOUSE":
                     return {"PASS_THROUGH"}
         except:
             self._unregister_handler()
-            import traceback
-            traceback.print_exc()
+            if VERBOSE: traceback.print_exc()
             return {"CANCELLED"}
         
         return {"PASS_THROUGH"}
@@ -554,10 +672,31 @@ def update_light_sets(panel, context, always=False):
                     # Some crucial objects are missing. Delete whole light collection
                     bpy.ops.object.delete({"selected_objects": col.objects}, use_global=True)
                     bpy.data.collections.remove(col)
+                    if VERBOSE: traceback.print_exc()
 
             update_clear()
 
 def close_control_panel():
     global running_modals
     running_modals = 0
-    
\ No newline at end of file
+
+addon_keymaps = []
+def add_shortkeys():
+    wm = bpy.context.window_manager
+    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type="EMPTY")
+
+    addon_kmi = addon_km.keymap_items.new(LLS_OT_Grab.bl_idname, 'G', 'PRESS')
+    addon_keymaps.append((addon_km, addon_kmi))
+
+    addon_kmi = addon_km.keymap_items.new(LLS_OT_Scale.bl_idname, 'S', 'PRESS')
+    addon_keymaps.append((addon_km, addon_kmi))
+
+    addon_kmi = addon_km.keymap_items.new(LLS_OT_Rotate.bl_idname, 'R', 'PRESS')
+    addon_keymaps.append((addon_km, addon_kmi))
+
+def remove_shortkeys():
+    wm = bpy.context.window_manager
+    for km, kmi in addon_keymaps:
+        km.keymap_items.remove(kmi)
+        
+    addon_keymaps.clear()
\ No newline at end of file
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index e37126d..7ab41b4 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -257,6 +257,14 @@ def send_light_to_top(light=None):
     lights = LightImage.lights
     lights.append(lights.pop(lights.index(light)))
 
+def fast_3d_edit(light=None):
+    try:
+        bpy.ops.light_studio.fast_3d_edit('INVOKE_DEFAULT', continuous=False)
+    except:
+        pass
+
+from .. common import get_user_keymap_item
+from .. light_brush import OT_LLSFast3DEdit
 class Panel(Rectangle):
     def __init__(self, loc, width, height):
         super().__init__(loc, width, height)
@@ -266,6 +274,10 @@ class Panel(Rectangle):
         self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
         self.button_send_to_bottom.function = send_light_to_bottom
 
+        km, kmi = get_user_keymap_item('Object Mode', OT_LLSFast3DEdit.bl_idname)
+        self.button_fast_3d_edit = Button(Vector((0,0)), f'Fast 3D Edit [{kmi.type}]')
+        self.button_fast_3d_edit.function = fast_3d_edit
+
         self._move_buttons()
 
     def _move_buttons(self):
@@ -279,6 +291,11 @@ class Panel(Rectangle):
             self.point_rb.y - self.button_exit.dimensions[1]/2,
         ))
 
+        self.button_fast_3d_edit.loc = Vector((
+            self.point_lt.x + self.button_send_to_bottom.dimensions[0] + self.button_fast_3d_edit.dimensions[0]/2 + 15,
+            self.point_rb.y - self.button_exit.dimensions[1]/2,
+        ))
+
     def draw(self):
         shader2Dcolor.uniform_float("color", (0.05, 0.05, 0.05, 1))
         batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
@@ -384,7 +401,7 @@ class Border(Rectangle):
         ]
         
         border_shader2Dcolor.bind()
-        bgl.glEnable(bgl.GL_BLEND);
+        bgl.glEnable(bgl.GL_BLEND)
         border_shader2Dcolor.uniform_float("color", self.color)
         border_shader2Dcolor.uniform_float("panel_point_lt", self.light_image.panel.point_lt)
         border_shader2Dcolor.uniform_float("panel_point_rb", self.light_image.panel.point_rb)
@@ -435,7 +452,7 @@ class Border(Rectangle):
         batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(border_shader2Dcolor)
         batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(border_shader2Dcolor)
         batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(border_shader2Dcolor)
-        bgl.glDisable(bgl.GL_BLEND);
+        bgl.glDisable(bgl.GL_BLEND)
 
     def get_verts(self):
         self.point_lt = self.light_image.point_lt.copy()
@@ -700,7 +717,7 @@ class LightImage(Rectangle):
             lightIconShader.uniform_float("mask_top_to_bottom", mask_top_to_bottom)
         except:
             pass
-        bgl.glEnable(bgl.GL_BLEND);
+        bgl.glEnable(bgl.GL_BLEND)
 
         if lleft < bleft:
             verts2 = deepcopy(verts)
@@ -750,7 +767,7 @@ class LightImage(Rectangle):
                     "texCoord": self.get_tex_coords(),
                 }
             ).draw(lightIconShader)
-        bgl.glDisable(bgl.GL_BLEND);
+        bgl.glDisable(bgl.GL_BLEND)
 
     def update_visual_location(self):
         self.loc = self.panel_loc_to_area_px_lt() + Vector((self.width/2, self.height/2))
@@ -795,7 +812,7 @@ class MouseWidget:
     mouse_y: bpy.props.IntProperty()
     
     def __init__(self):
-        self._start_position = Vector((0, 0))
+        self._start_position = None
         self._end_position = Vector((0, 0))
         self._reference_end_position = Vector((0, 0))
         self._base_rotation = 0
@@ -806,12 +823,17 @@ class MouseWidget:
         self.allow_xy_keys = False
         self.x_key = False
         self.y_key = False
+        self.z_key = False
 
         self.continous = False
 
         self.allow_precision_mode = False
         self.precision_mode = False
         self.precision_offset = Vector((0,0))
+        self.precision_factor = 0.1
+
+        self.z_start_position = Vector((0,0))
+        self.z_end_position = Vector((0,0))
 
     def invoke(self, context, event):
         mouse_x = event.mouse_x - context.area.x
@@ -860,9 +882,15 @@ class MouseWidget:
                 if event.type == "X":
                     self.x_key = not self.x_key
                     self.y_key = False
+                    self.z_key = False
                 if event.type == "Y":
                     self.y_key = not self.y_key
                     self.x_key = False
+                    self.z_key = False
+                if event.type == "Z":
+                    self.z_key = not self.z_key
+                    self.x_key = False
+                    self.y_key = False
 
         if self.allow_precision_mode and event.value == "PRESS" and event.type == "LEFT_SHIFT":
             self.precision_mode = True
@@ -886,15 +914,16 @@ class MouseWidget:
         return (self._start_position - self._reference_end_position - self.delta_vector()).length
     
     def delta_vector(self):
+        precision_factor_inv = 1 - self.precision_factor
         if self.precision_mode:
-            return self._precision_mode_mid_stop - self._reference_end_position - self.precision_offset*.9 + (self._end_position - self._precision_mode_mid_stop) * .1
-        return self._end_position - self._reference_end_position - self.precision_offset*.9
+            return self._precision_mode_mid_stop - self._reference_end_position - self.precision_offset * precision_factor_inv + (self._end_position - self._precision_mode_mid_stop) * self.precision_factor
+        return self._end_position - self._reference_end_position - self.precision_offset * precision_factor_inv
     
     def delta_length_factor(self):
         return self.length() / ((self._start_position - self._reference_end_position).length)
 
     def angle(self):
-        vec = self._reference_end_position - self._start_position + self.delta_vector() + self.precision_offset*.9
+        vec = self._reference_end_position - self._start_position + self.delta_vector() + self.precision_offset * (1 - self.precision_factor)
         return atan2(vec.y, vec.x) - self._base_rotation
 
     def _draw(self, context, event):
@@ -912,4 +941,7 @@ class MouseWidget:
                 batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0, self._start_position.y), (context.area.width, self._start_position.y))}).draw(shader2Dcolor)
             elif self.y_key:
                 shader2Dcolor.uniform_float("color", (0, 1, 0, .5))
-                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position.x, 0), (self._start_position.x, context.area.height))}).draw(shader2Dcolor)
\ No newline at end of file
+                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position.x, 0), (self._start_position.x, context.area.height))}).draw(shader2Dcolor)
+            elif self.z_key:
+                shader2Dcolor.uniform_float("color", (0, 0, 1, .5))
+                batch_for_shader(shader2Dcolor, 'LINES', {"pos": (self.z_start_position, self.z_end_position)}).draw(shader2Dcolor)
\ No newline at end of file

commit 52af1421e7c84ab1b268152e43eb07bb22d13a48
Merge: ff01679 d632d33
Author: StyriamMZ <47333958+StyriamMZ@users.noreply.github.com>
Date:   Tue Oct 6 23:54:20 2020 +0200

    Merge pull request #4 from leomoon-studios/master
    
    Merge

commit d632d338d94591cbaa60306d71e6022eaf7be308
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Aug 21 12:13:17 2020 -0700

    readme change

diff --git a/README.md b/README.md
index d9ab609..600795a 100644
--- a/README.md
+++ b/README.md
@@ -46,7 +46,7 @@ Thank you.
 ### 2.6.1 2020-08-21:
 * Added "Up" and "Down" buttons to sort lights in the light list
 * Added button to copy a light in the light list
-* Selected in the light list will bring that light to top in the LightPanel
+* Selecting a light in the light list will bring that light to top in the LightPanel
 * Lights in copied profiles do not have shared materials any more
 * Constrained clickable area of the control panel by 3D viewport properties area
 

commit ba3258570b371f5efb2173389667f3a7046ed3fb
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Aug 21 12:10:21 2020 -0700

    readme change

diff --git a/README.md b/README.md
index c94153f..d9ab609 100644
--- a/README.md
+++ b/README.md
@@ -45,8 +45,8 @@ Thank you.
 ## Changelog
 ### 2.6.1 2020-08-21:
 * Added "Up" and "Down" buttons to sort lights in the light list
-* Added button to copy light in the light list
-* Send light to top in the LightPanel when selected in the light list
+* Added button to copy a light in the light list
+* Selected in the light list will bring that light to top in the LightPanel
 * Lights in copied profiles do not have shared materials any more
 * Constrained clickable area of the control panel by 3D viewport properties area
 

commit 711d1c124444c524959cf9f1b5ea65716179ff2c
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Aug 21 11:16:24 2020 -0700

    readme 2.6.1 change

diff --git a/README.md b/README.md
index f54df44..c94153f 100644
--- a/README.md
+++ b/README.md
@@ -43,6 +43,13 @@ If you think this plugin speeds up your workflow, consider funding the developme
 Thank you.
 
 ## Changelog
+### 2.6.1 2020-08-21:
+* Added "Up" and "Down" buttons to sort lights in the light list
+* Added button to copy light in the light list
+* Send light to top in the LightPanel when selected in the light list
+* Lights in copied profiles do not have shared materials any more
+* Constrained clickable area of the control panel by 3D viewport properties area
+
 ### 2.6.0 2020-07-31:
 * Replaced Add Light and Delete Light buttons with a light list
 * Lights can be renamed in the light list

commit f3be8f283d9330c73644bedcf45da1c2ee3ca224
Merge: c3a74d9 ff01679
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Aug 21 10:51:56 2020 -0700

    Merge pull request #28 from StyriamMZ/master
    
    2.6.1

commit ff01679961b353a29bccf2351c9a849d30ae9f09
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Aug 21 17:14:26 2020 +0200

    2.6.1

diff --git a/src/extensions_framework/util.py b/src/extensions_framework/util.py
deleted file mode 100644
index 2ad450b..0000000
--- a/src/extensions_framework/util.py
+++ /dev/null
@@ -1,270 +0,0 @@
-# -*- coding: utf-8 -*-
-#
-# ***** BEGIN GPL LICENSE BLOCK *****
-#
-# --------------------------------------------------------------------------
-# Blender 2.5 Extensions Framework
-# --------------------------------------------------------------------------
-#
-# Authors:
-# Doug Hammond
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-#
-# ***** END GPL LICENCE BLOCK *****
-#
-import configparser
-import datetime
-import os
-import tempfile
-import threading
-
-import bpy
-
-"""List of possibly appropriate paths to load/save addon config from/to"""
-config_paths = []
-if bpy.utils.user_resource('CONFIG', '') != "": config_paths.append(bpy.utils.user_resource('CONFIG', '', create=True))
-if bpy.utils.user_resource('SCRIPTS', '') != "": config_paths.append(bpy.utils.user_resource('SCRIPTS', '', create=True))
-# want to scan other script paths in reverse order, since the user path comes last
-sp = [p for p in bpy.utils.script_paths() if p != '']
-sp.reverse()
-config_paths.extend(sp)
-
-"""This path is set at the start of export, so that calls to
-path_relative_to_export() can make all exported paths relative to
-this one.
-"""
-export_path = '';
-
-def path_relative_to_export(p):
-    """Return a path that is relative to the export path"""
-    global export_path
-    p = filesystem_path(p)
-    ep = os.path.dirname(export_path)
-
-    if os.sys.platform[:3] == "win":
-        # Prevent an error whereby python thinks C: and c: are different drives
-        if p[1] == ':': p = p[0].lower() + p[1:]
-        if ep[1] == ':': ep = ep[0].lower() + ep[1:]
-
-    try:
-        relp = os.path.relpath(p, ep)
-    except ValueError: # path on different drive on windows
-        relp = p
-
-    return relp.replace('\\', '/')
-
-def filesystem_path(p):
-    """Resolve a relative Blender path to a real filesystem path"""
-    if p.startswith('//'):
-        pout = bpy.path.abspath(p)
-    else:
-        pout = os.path.realpath(p)
-
-    return pout.replace('\\', '/')
-
-# TODO: - somehow specify TYPES to get/set from config
-
-def find_config_value(module, section, key, default):
-    """Attempt to find the configuration value specified by string key
-    in the specified section of module's configuration file. If it is
-    not found, return default.
-
-    """
-    global config_paths
-    fc = []
-    for p in config_paths:
-        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
-            fc.append( '/'.join([p, '%s.cfg' % module]))
-
-    if len(fc) < 1:
-        print('Cannot find %s config file path' % module)
-        return default
-
-    cp = configparser.SafeConfigParser()
-
-    cfg_files = cp.read(fc)
-    if len(cfg_files) > 0:
-        try:
-            val = cp.get(section, key)
-            if val == 'true':
-                return True
-            elif val == 'false':
-                return False
-            else:
-                return val
-        except:
-            return default
-    else:
-        return default
-
-def write_config_value(module, section, key, value):
-    """Attempt to write the configuration value specified by string key
-    in the specified section of module's configuration file.
-
-    """
-    global config_paths
-    fc = []
-    for p in config_paths:
-        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
-            fc.append( '/'.join([p, '%s.cfg' % module]))
-
-    if len(fc) < 1:
-        raise Exception('Cannot find a writable path to store %s config file' %
-            module)
-
-    cp = configparser.SafeConfigParser()
-
-    cfg_files = cp.read(fc)
-
-    if not cp.has_section(section):
-        cp.add_section(section)
-
-    if value == True:
-        cp.set(section, key, 'true')
-    elif value == False:
-        cp.set(section, key, 'false')
-    else:
-        cp.set(section, key, value)
-
-    if len(cfg_files) < 1:
-        cfg_files = fc
-
-    fh=open(cfg_files[0],'w')
-    cp.write(fh)
-    fh.close()
-
-    return True
-
-def scene_filename():
-    """Construct a safe scene filename, using 'untitled' instead of ''"""
-    filename = os.path.splitext(os.path.basename(bpy.data.filepath))[0]
-    if filename == '':
-        filename = 'untitled'
-    return bpy.path.clean_name(filename)
-
-def temp_directory():
-    """Return the system temp directory"""
-    return tempfile.gettempdir()
-
-def temp_file(ext='tmp'):
-    """Get a temporary filename with the given extension. This function
-    will actually attempt to create the file."""
-    tf, fn = tempfile.mkstemp(suffix='.%s'%ext)
-    os.close(tf)
-    return fn
-
-class TimerThread(threading.Thread):
-    """Periodically call self.kick(). The period of time in seconds
-    between calling is given by self.KICK_PERIOD, and the first call
-    may be delayed by setting self.STARTUP_DELAY, also in seconds.
-    self.kick() will continue to be called at regular intervals until
-    self.stop() is called. Since this is a thread, calling self.join()
-    may be wise after calling self.stop() if self.kick() is performing
-    a task necessary for the continuation of the program.
-    The object that creates this TimerThread may pass into it data
-    needed during self.kick() as a dict LocalStorage in __init__().
-
-    """
-    STARTUP_DELAY = 0
-    KICK_PERIOD = 8
-
-    active = True
-    timer = None
-
-    LocalStorage = None
-
-    def __init__(self, LocalStorage=dict()):
-        threading.Thread.__init__(self)
-        self.LocalStorage = LocalStorage
-
-    def set_kick_period(self, period):
-        """Adjust the KICK_PERIOD between __init__() and start()"""
-        self.KICK_PERIOD = period + self.STARTUP_DELAY
-
-    def stop(self):
-        """Stop this timer. This method does not join()"""
-        self.active = False
-        if self.timer is not None:
-            self.timer.cancel()
-
-    def run(self):
-        """Timed Thread loop"""
-        while self.active:
-            self.timer = threading.Timer(self.KICK_PERIOD, self.kick_caller)
-            self.timer.start()
-            if self.timer.isAlive(): self.timer.join()
-
-    def kick_caller(self):
-        """Intermediary between the kick-wait-loop and kick to allow
-        adjustment of the first KICK_PERIOD by STARTUP_DELAY
-
-        """
-        if self.STARTUP_DELAY > 0:
-            self.KICK_PERIOD -= self.STARTUP_DELAY
-            self.STARTUP_DELAY = 0
-
-        self.kick()
-
-    def kick(self):
-        """Sub-classes do their work here"""
-        pass
-
-def format_elapsed_time(t):
-    """Format a duration in seconds as an HH:MM:SS format time"""
-
-    td = datetime.timedelta(seconds=t)
-    min = td.days*1440  + td.seconds/60.0
-    hrs = td.days*24    + td.seconds/3600.0
-
-    return '%i:%02i:%02i' % (hrs, min%60, td.seconds%60)
-
-def getSequenceTexturePath(it, f):
-    import bpy.path
-    import os.path
-    import string
-    fd = it.image_user.frame_duration
-    fs = it.image_user.frame_start
-    fo = it.image_user.frame_offset
-    cyclic = it.image_user.use_cyclic
-    ext = os.path.splitext(it.image.filepath)[-1]
-    fb = bpy.path.display_name_from_filepath(it.image.filepath)
-    dn = os.path.dirname(it.image.filepath)
-    rf = fb[::-1]
-    nl = 0
-    for i in range (len(fb)):
-        if rf[i] in string.digits:
-            nl += 1
-        else:
-            break
-    head = fb[:len(fb)-nl]
-    fnum = f
-    if fs != 1:
-        if f != fs:
-            fnum -= (fs-1)
-        elif f == fs:
-            fnum = 1
-    if fnum <= 0:
-        if cyclic:
-            fnum = fd - abs(fnum) % fd
-        else:
-            fnum = 1
-    elif fnum > fd:
-        if cyclic:
-            fnum = fnum % fd
-        else:
-            fnum = fd
-    fnum += fo
-    return dn + "/" + head + str(fnum).rjust(nl, "0") + ext
diff --git a/src/light_operators.py b/src/light_operators.py
index 1864a57..7d190ca 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -8,7 +8,6 @@ from . import light_list
 
 _ = os.sep
 
-from . extensions_framework import util as efutil
 from . import bl_info
 
 class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 6036dbd..297bef4 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -362,6 +362,7 @@ class ImportProfiles(bpy.types.Operator):
 
         file = json.loads(file)
         parse_profile(context, props, file["profiles"], float(file["version"]))
+        light_list.update_light_list_set(context)
 
         return{'FINISHED'}
 

commit 52d70ded45cea69c9bfe59239e7cc1203d6543e0
Merge: 9f8006c 5273bc4
Author: StyriamMZ <styriam@o2.pl>
Date:   Thu Aug 20 19:35:11 2020 +0200

    Merge branch 'master' of https://github.com/StyriamMZ/leomoon-lightstudio-1

commit 9f8006c2ba0d72e851d70ce0034ad3dcf0c8f6df
Author: StyriamMZ <styriam@o2.pl>
Date:   Thu Aug 20 19:33:47 2020 +0200

    2.6.1

diff --git a/src/__init__.py b/src/__init__.py
index 2e79945..fc8d892 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -4,7 +4,7 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 6, 0),
+    "version": (2, 6, 1),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
diff --git a/src/common.py b/src/common.py
index 4a7bafd..6fe8693 100644
--- a/src/common.py
+++ b/src/common.py
@@ -126,4 +126,86 @@ def refreshMaterials():
     for cntrl in controllers:
         mat = [m for m in cntrl.data.materials if m.name.startswith('LLS_icon_ctrl')][0]
         mixNode = mat.node_tree.nodes['Mix Shader'].inputs['Fac']
-        mixNode.default_value = mixNode.default_value
\ No newline at end of file
+        mixNode.default_value = mixNode.default_value
+
+def duplicate_collection(collection, parent_collection):
+    new_collection = bpy.data.collections.new(collection.name)
+
+    new_names = {}
+    matrix_data = {}
+
+    for obj in collection.objects:
+        new_obj = obj.copy()
+
+        new_names[obj.name] = new_obj
+        matrix_data[new_obj.name] = {
+            "matrix_basis": obj.matrix_basis.copy(),
+            "matrix_local": obj.matrix_local.copy(),
+            "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
+            "matrix_world": obj.matrix_world.copy()
+            }
+
+        if new_obj.data:
+            new_obj.data = obj.data.copy()
+        for slot in new_obj.material_slots:
+            slot.material = slot.material.copy()
+        new_obj.parent = obj.parent
+        new_collection.objects.link(new_obj)
+
+    for obj in new_collection.objects:
+        if obj.parent:
+            if obj.parent.name in new_names:
+                obj.parent = new_names[obj.parent.name]
+            obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
+            #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
+            obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
+            #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
+
+
+    if parent_collection:
+        parent_collection.children.link(new_collection)
+
+    iter_list = [collection.children]
+    parent_collection = new_collection
+
+    while len(iter_list) > 0:
+        new_iter_list = []
+
+        for iter in iter_list:
+            for collection in iter:
+
+                new_collection = bpy.data.collections.new(collection.name)
+
+                for obj in collection.objects:
+                    new_obj = obj.copy()
+
+                    new_names[obj.name] = new_obj
+                    matrix_data[new_obj.name] = {
+                        "matrix_basis": obj.matrix_basis.copy(),
+                        "matrix_local": obj.matrix_local.copy(),
+                        "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
+                        "matrix_world": obj.matrix_world.copy()
+                        }
+
+                    if new_obj.data:
+                        new_obj.data = obj.data.copy()
+                    for slot in new_obj.material_slots:
+                        slot.material = slot.material.copy()
+                    new_obj.parent = obj.parent
+                    new_collection.objects.link(new_obj)
+
+                for obj in new_collection.objects:
+                    if obj.parent:
+                        obj.parent = new_names[obj.parent.name]
+                        obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
+                        #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
+                        obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
+                        #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
+
+                parent_collection.children.link(new_collection)
+
+                if len(collection.children) > 0:
+                    new_iter_list.append(collection.children)
+
+        iter_list = new_iter_list
+    return parent_collection
\ No newline at end of file
diff --git a/src/gui.py b/src/gui.py
index 8193322..f00d3bb 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -48,8 +48,13 @@ class LLS_PT_Lights(bpy.types.Panel):
         col.template_list("LLS_UL_LightList", "Light_List", props, "light_list", props, "light_list_index", rows=5)
 
         col = row.column(align=True)
-        col.operator('scene.add_leomoon_studio_light', icon='PLUS', text="")
-        col.operator('scene.delete_leomoon_studio_light', icon='TRASH', text="")
+        col.operator('scene.add_leomoon_studio_light', icon='ADD', text="")
+        col.operator('scene.delete_leomoon_studio_light', icon='REMOVE', text="")
+        col.operator('lls_list.copy_light', icon='DUPLICATE', text="")
+
+        col.separator()
+        col.operator('lls_list.move_light', text='', icon="TRIA_UP").direction = 'UP'
+        col.operator('lls_list.move_light', text='', icon="TRIA_DOWN").direction = 'DOWN'
 
 
 @force_register
@@ -115,8 +120,8 @@ class LLS_PT_ProfileList(bpy.types.Panel):
         col.template_list("UI_UL_list", "Profile_List", props, "profile_list", props, "list_index", rows=5)
 
         col = row.column(align=True)
-        col.operator('lls_list.new_profile', icon='PLUS', text="")
-        col.operator('lls_list.delete_profile', icon='TRASH', text="")
+        col.operator('lls_list.new_profile', icon='ADD', text="")
+        col.operator('lls_list.delete_profile', icon='REMOVE', text="")
         col.operator('lls_list.copy_profile_menu', icon='DUPLICATE', text="")
 
         col.separator()
diff --git a/src/light_list.py b/src/light_list.py
index 7bc28fb..7079e21 100644
--- a/src/light_list.py
+++ b/src/light_list.py
@@ -3,7 +3,9 @@ from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProper
 import os, sys, subprocess
 from . common import *
 from itertools import chain
-from . operators.modal import close_control_panel
+from . operators import modal
+from . operators.modal import close_control_panel, update_light_sets
+from . operators.modal_utils import send_light_to_top, LightImage
 
 _ = os.sep
 
@@ -67,8 +69,13 @@ def set_list_index(self, index):
     selected_light = self.light_list[index]
     ob = bpy.context.scene.objects[selected_light.mesh_name]       # Get the object
     bpy.ops.object.select_all(action='DESELECT') # Deselect all objects
-    bpy.context.view_layer.objects.active = ob   # Make the cube the active object 
-    ob.select_set(True)
+    if ob.name in bpy.context.view_layer.objects:
+        bpy.context.view_layer.objects.active = ob
+        ob.select_set(True)
+
+    if modal.panel_global:
+        light_icon = [l for l in LightImage.lights if l._lls_mesh == ob][0]
+        send_light_to_top(light_icon)
 
 def update_light_list_set(context):
     '''Update light list set. Use when the light list needs to be synced with real object hierarchy. '''
@@ -76,16 +83,13 @@ def update_light_list_set(context):
     lls_collection, profile_collection = llscol_profilecol(context)
     if profile_collection is not None:
         props.light_list.clear()
+
         lls_lights = set(profile_collection.children)
-        for col in lls_lights:
+        lights = [m for col in lls_lights for m in col.objects if m.name.startswith("LLS_LIGHT_MESH")]
+        lights.sort(key= lambda m: m.LLStudio.order_index)
+        for i, lls_mesh in enumerate(lights):
+            lls_mesh.LLStudio.order_index = i
             ll = props.light_list.add()
-            lls_mesh = [m for m in col.objects if m.name.startswith("LLS_LIGHT_MESH")]
-            if not lls_mesh:
-                bpy.ops.object.delete({"selected_objects": col.objects}, use_global=True)
-                bpy.data.collections.remove(col)
-                return update_light_list_set(context)
-
-            lls_mesh = lls_mesh[0]
             ll.mesh_name = lls_mesh.name
             ll.name = lls_mesh.LLStudio.light_name if lls_mesh.LLStudio.light_name else lls_mesh.name
 
@@ -146,4 +150,85 @@ class LLS_OT_Isolate(bpy.types.Operator):
                 v.exclude = True
             view_layer.exclude = False
 
-        return {"FINISHED"}
\ No newline at end of file
+        return {"FINISHED"}
+
+class LLS_OT_LightListMoveItem(bpy.types.Operator):
+    bl_idname = "lls_list.move_light"
+    bl_label = "Move Light"
+    bl_options = {"INTERNAL"}
+
+    direction: bpy.props.EnumProperty(
+                items=(
+                    ('UP', 'Up', ""),
+                    ('DOWN', 'Down', ""),))
+
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list. """
+        return len(context.scene.LLStudio.light_list)
+
+    def execute(self, context):
+        props = context.scene.LLStudio
+        list = props.light_list
+        index = props.light_list_index
+
+        if self.direction == 'DOWN':
+            neighbor = index + 1
+            list.move(index,neighbor)
+        elif self.direction == 'UP':
+            neighbor = index - 1
+            list.move(neighbor, index)
+        else:
+            return{'CANCELLED'}
+
+        for i, e in enumerate(list):
+            if e.mesh_name in bpy.data.objects:
+                bpy.data.objects[e.mesh_name].LLStudio.order_index = i
+
+        return{'FINISHED'}
+
+class LIST_OT_LightListCopyItem(bpy.types.Operator):
+
+    bl_idname = "lls_list.copy_light"
+    bl_label = "Copy Light"
+    bl_options = {"REGISTER", "UNDO"}
+
+    @classmethod
+    def poll(cls, context):
+        light = context.active_object
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.LLStudio.initialized and \
+               light and \
+               light.name.startswith('LLS_LIGHT')
+
+    def execute(self, context):
+        props = context.scene.LLStudio
+        list = props.profile_list
+
+
+        lls_collection, profile_collection = llscol_profilecol(context)
+        lls_mesh = context.object
+        lcol = [c for c in lls_mesh.users_collection if c.name.startswith('LLS_Light')]
+        
+        if not lcol:
+            return{'CANCELLED'}
+        
+        lcol = lcol[0]
+        light_copy = duplicate_collection(lcol, profile_collection)
+        lls_mesh_copy = [lm for lm in light_copy.objects if lm.name.startswith('LLS_LIGHT_MESH')][0] # original light mesh exists so no checks necessary
+        lls_mesh_copy.LLStudio.light_name += " Copy"
+        lls_mesh_copy.LLStudio.order_index += 1
+
+        # place copied profile next to source profile
+        for e in props.light_list[lls_mesh.LLStudio.order_index + 1 : ]:
+            bpy.data.objects[e.mesh_name].LLStudio.order_index += 1
+
+        update_light_list_set(context)
+
+        if modal.panel_global:
+            update_light_sets(modal.panel_global, context, always=True)
+            light_icon = [l for l in LightImage.lights if l._lls_mesh == lls_mesh][0]
+            send_light_to_top(light_icon)
+
+        return{'FINISHED'}
\ No newline at end of file
diff --git a/src/light_operators.py b/src/light_operators.py
index 6e5cb03..1864a57 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -23,7 +23,8 @@ class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
     light_list_index: IntProperty(name = "Index for light_list", default = 0, get=light_list.get_list_index, set=light_list.set_list_index)
 
 class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
-    light_name: bpy.props.StringProperty()
+    light_name: StringProperty()
+    order_index: IntProperty()
 
 class CreateBlenderLightStudio(bpy.types.Operator):
     bl_idname = "scene.create_leomoon_light_studio"
@@ -160,6 +161,7 @@ class AddBSLight(bpy.types.Operator):
                 light = [p for p in new_objects if p.name.startswith('LLS_LIGHT_MESH')][0]
                 light.select_set(True)
                 context.view_layer.objects.active = light
+                light.LLStudio.order_index = len(context.scene.LLStudio.light_list)
 
         #####
 
@@ -190,8 +192,7 @@ class DeleteBSLight(bpy.types.Operator):
                context.mode == 'OBJECT' and \
                context.scene.LLStudio.initialized and \
                light and \
-               light.name.startswith('LLS_LIGHT') and \
-               not light.name.startswith('LLS_PROFILE')
+               light.name.startswith('LLS_LIGHT')
 
     def execute(self, context):
         scene = context.scene
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 4881872..6036dbd 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -135,84 +135,6 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
 
         return{'FINISHED'}
 
-def duplicate_collection(collection, parent_collection):
-    new_collection = bpy.data.collections.new(collection.name)
-
-    new_names = {}
-    matrix_data = {}
-
-    for obj in collection.objects:
-        new_obj = obj.copy()
-
-        new_names[obj.name] = new_obj
-        matrix_data[new_obj.name] = {
-            "matrix_basis": obj.matrix_basis.copy(),
-            "matrix_local": obj.matrix_local.copy(),
-            "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
-            "matrix_world": obj.matrix_world.copy()
-            }
-
-        if new_obj.data:
-            new_obj.data = obj.data.copy()
-        new_obj.parent = obj.parent
-        new_collection.objects.link(new_obj)
-
-    for obj in new_collection.objects:
-        if obj.parent:
-            if obj.parent.name in new_names:
-                obj.parent = new_names[obj.parent.name]
-            obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
-            #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
-            obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
-            #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
-
-
-    if parent_collection:
-        parent_collection.children.link(new_collection)
-
-    iter_list = [collection.children]
-    parent_collection = new_collection
-
-    while len(iter_list) > 0:
-        new_iter_list = []
-
-        for iter in iter_list:
-            for collection in iter:
-
-                new_collection = bpy.data.collections.new(collection.name)
-
-                for obj in collection.objects:
-                    new_obj = obj.copy()
-
-                    new_names[obj.name] = new_obj
-                    matrix_data[new_obj.name] = {
-                        "matrix_basis": obj.matrix_basis.copy(),
-                        "matrix_local": obj.matrix_local.copy(),
-                        "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
-                        "matrix_world": obj.matrix_world.copy()
-                        }
-
-                    if new_obj.data:
-                        new_obj.data = obj.data.copy()
-                    new_obj.parent = obj.parent
-                    new_collection.objects.link(new_obj)
-
-                for obj in new_collection.objects:
-                    if obj.parent:
-                        obj.parent = new_names[obj.parent.name]
-                        obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
-                        #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
-                        obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
-                        #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
-
-                parent_collection.children.link(new_collection)
-
-                if len(collection.children) > 0:
-                    new_iter_list.append(collection.children)
-
-        iter_list = new_iter_list
-    return parent_collection
-
 class LIST_OT_CopyItem(bpy.types.Operator):
 
     bl_idname = "lls_list.copy_profile"
@@ -227,9 +149,6 @@ class LIST_OT_CopyItem(bpy.types.Operator):
     def execute(self, context):
         props = context.scene.LLStudio
         list = props.profile_list
-        index = props.list_index
-
-        scene = context.scene
 
         lls_collection, profile_collection = llscol_profilecol(context)
 
@@ -386,6 +305,8 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
 
             if 'light_name' in light:
                 lmesh.LLStudio.light_name = light['light_name']
+            if 'order_index' in light:
+                lmesh.LLStudio.order_index = light['order_index']
 
             lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['Texture Switch']
             lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
@@ -462,6 +383,7 @@ def compose_profile(list_index):
         actuator = [ob for ob in light_collection.objects if ob.name.startswith('LLS_ROTATION')][0]
         light = {}
         light['light_name'] = lmesh.LLStudio.light_name
+        light['order_index'] = lmesh.LLStudio.order_index
         light['radius'] = lmesh.location.x
         light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
         light['scale'] = [lmesh.scale.x, lmesh.scale.y, lmesh.scale.z]
@@ -500,6 +422,7 @@ def compose_profile(list_index):
         # light['Half'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
 
         profile_dict['lights'].append(light)
+        profile_dict['lights'].sort(key=lambda x: x["order_index"])
 
     return profile_dict
 
diff --git a/src/operators/modal.py b/src/operators/modal.py
index c9b5054..819244a 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -164,7 +164,6 @@ W_LEFT = 1
 W_RIGHT = 2
 W_TOP = 4
 W_BOTTOM = 8
-# CTRL, SHIFT, ALT = False
 class LLS_OT_control_panel(bpy.types.Operator):
     bl_idname = "light_studio.control_panel"
     bl_label = "LightStudio Control Panel"
@@ -247,6 +246,16 @@ class LLS_OT_control_panel(bpy.types.Operator):
         touch_point = 0
         treshold = 5
 
+        # decrease clickable size by UI tools region
+        r_ui = [r for r in context.area.regions if r.type == 'UI'][0]
+        if r_ui.alignment=='RIGHT':
+            if area_mouse_x >= context.area.width - r_ui.width - 2:
+                return touch_point
+        else:
+            if area_mouse_x <= r_ui.width + 2:
+                return touch_point
+
+
         for b in Button.buttons:
             if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
                 context.window.cursor_set('DEFAULT')
@@ -496,6 +505,16 @@ class LLS_OT_control_panel(bpy.types.Operator):
         return {"PASS_THROUGH"}
 
     def find_clicked(self, area_mouse_x, area_mouse_y, overlapping=False):
+        # decrease clickable size by UI tools region
+        r_ui = [r for r in bpy.context.area.regions if r.type == 'UI'][0]
+        if r_ui.alignment=='RIGHT':
+            if area_mouse_x >= bpy.context.area.width - r_ui.width - 2:
+                return None
+        else:
+            if area_mouse_x <= r_ui.width + 2:
+                return None
+
+        
         overlapped = []
         for l in reversed(LightImage.lights):
             if l.is_mouse_over(area_mouse_x, area_mouse_y):
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index a364584..e37126d 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -243,14 +243,14 @@ class Rectangle:
         new_loc.y = clamp(rect.point_rb.y, new_loc.y, rect.point_lt.y)
         self.loc = new_loc
 
-def send_light_to_bottom(light):
+def send_light_to_bottom(light=None):
     light = LightImage.selected_object if not light else light
     if not light:
         return
     lights = LightImage.lights
     lights.insert(0, lights.pop(lights.index(light)))
 
-def send_light_to_top(light):
+def send_light_to_top(light=None):
     light = LightImage.selected_object if not light else light
     if not light:
         return

commit 5273bc4d66a389d70ced12068a2af0c172cf7f60
Merge: 6a168a5 c3a74d9
Author: StyriamMZ <47333958+StyriamMZ@users.noreply.github.com>
Date:   Thu Aug 20 19:14:24 2020 +0200

    Merge pull request #3 from leomoon-studios/master
    
    Merge

commit c3a74d9756745e8edba91332c1bcb8db540bdea2
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jul 31 14:14:46 2020 -0700

    readme update

diff --git a/README.md b/README.md
index 291d893..f54df44 100644
--- a/README.md
+++ b/README.md
@@ -43,6 +43,13 @@ If you think this plugin speeds up your workflow, consider funding the developme
 Thank you.
 
 ## Changelog
+### 2.6.0 2020-07-31:
+* Replaced Add Light and Delete Light buttons with a light list
+* Lights can be renamed in the light list
+* Lights can be toggled in the light list
+* Lights can be isolated in the light list
+* Light selection is syncronized with the LightPanel
+
 ### 2.5.2 2020-07-10:
 * Fixed light going outside of LightPanel
 * Added resizing to LighPanel

commit aee555ba8c03860fdef4d030d24cc0fe9143bd15
Merge: 2e03caa 6a168a5
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jul 31 13:09:04 2020 -0700

    Merge pull request #27 from StyriamMZ/master
    
    2.6.0

commit 6a168a5477f2bbefece9094b68088fb9e8661e42
Merge: 9f99a78 2e03caa
Author: StyriamMZ <47333958+StyriamMZ@users.noreply.github.com>
Date:   Fri Jul 31 22:02:03 2020 +0200

    Merge branch 'master' into master

commit 9f99a784056acba54352fc791fcdac70dd706613
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Jul 31 18:39:52 2020 +0200

    2.6.0

diff --git a/src/light_list.py b/src/light_list.py
index 01b19c7..7bc28fb 100644
--- a/src/light_list.py
+++ b/src/light_list.py
@@ -71,6 +71,7 @@ def set_list_index(self, index):
     ob.select_set(True)
 
 def update_light_list_set(context):
+    '''Update light list set. Use when the light list needs to be synced with real object hierarchy. '''
     props = context.scene.LLStudio
     lls_collection, profile_collection = llscol_profilecol(context)
     if profile_collection is not None:
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 861d661..c9b5054 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -285,8 +285,8 @@ class LLS_OT_control_panel(bpy.types.Operator):
             context.area.tag_redraw()
             return {"FINISHED"}
 
-        if event.type != "MOUSEMOVE":
-            print(event.type, event.value)
+        # if event.type != "MOUSEMOVE":
+        #     print(event.type, event.value)
 
         if not context.area or (context.object and not context.object.mode == 'OBJECT'):
             self._unregister_handler()

commit b440ecf6ab593d5537e7bb4ac248151dfa01935d
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Jul 29 23:08:57 2020 +0200

    2.6.0

diff --git a/src/light_operators.py b/src/light_operators.py
index a445d4d..6e5cb03 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -23,7 +23,6 @@ class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
     light_list_index: IntProperty(name = "Index for light_list", default = 0, get=light_list.get_list_index, set=light_list.set_list_index)
 
 class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
-    # protected: bpy.props.BoolProperty(name = 'protected', default = False)
     light_name: bpy.props.StringProperty()
 
 class CreateBlenderLightStudio(bpy.types.Operator):
diff --git a/src/operators/modal.py b/src/operators/modal.py
index ce17986..861d661 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -252,18 +252,21 @@ class LLS_OT_control_panel(bpy.types.Operator):
                 context.window.cursor_set('DEFAULT')
                 return 0
 
-        if area_mouse_x < self.panel.point_lt.x+treshold and area_mouse_x >= self.panel.point_lt.x-treshold:
-            touch_point |= W_LEFT
-            context.window.cursor_set('MOVE_X')
-        elif area_mouse_x > self.panel.point_rb.x-treshold and area_mouse_x <= self.panel.point_rb.x+treshold:
-            touch_point |= W_RIGHT
-            context.window.cursor_set('MOVE_X')
-        if area_mouse_y > self.panel.point_lt.y-treshold and area_mouse_y <= self.panel.point_lt.y+treshold:
-            touch_point |= W_TOP
-            context.window.cursor_set('MOVE_Y')
-        elif area_mouse_y < self.panel.point_rb.y+treshold and area_mouse_y >= self.panel.point_rb.y-treshold:
-            touch_point |= W_BOTTOM
-            context.window.cursor_set('MOVE_Y')
+        if area_mouse_y >= self.panel.point_rb.y-treshold and area_mouse_y <= self.panel.point_lt.y+treshold:
+            if area_mouse_x < self.panel.point_lt.x+treshold and area_mouse_x >= self.panel.point_lt.x-treshold:
+                touch_point |= W_LEFT
+                context.window.cursor_set('MOVE_X')
+            elif area_mouse_x > self.panel.point_rb.x-treshold and area_mouse_x <= self.panel.point_rb.x+treshold:
+                touch_point |= W_RIGHT
+                context.window.cursor_set('MOVE_X')
+        
+        if area_mouse_x >= self.panel.point_lt.x-treshold and area_mouse_x <= self.panel.point_rb.x+treshold:
+            if area_mouse_y > self.panel.point_lt.y-treshold and area_mouse_y <= self.panel.point_lt.y+treshold:
+                touch_point |= W_TOP
+                context.window.cursor_set('MOVE_Y')
+            elif area_mouse_y < self.panel.point_rb.y+treshold and area_mouse_y >= self.panel.point_rb.y-treshold:
+                touch_point |= W_BOTTOM
+                context.window.cursor_set('MOVE_Y')
 
         if touch_point == W_LEFT | W_TOP\
             or touch_point == W_LEFT | W_BOTTOM\

commit 0b345657eb8501de55b0017643c41027c19df3de
Author: StyriamMZ <styriam@o2.pl>
Date:   Tue Jul 28 23:03:11 2020 +0200

    2.6.0

diff --git a/src/__init__.py b/src/__init__.py
index 8810b66..2e79945 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -4,7 +4,7 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 5, 2),
+    "version": (2, 6, 0),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
@@ -24,14 +24,14 @@ auto_load.init()
 # register
 ################################## 
 
-from . light_operators import LeoMoon_Light_Studio_Properties
+from . light_operators import LeoMoon_Light_Studio_Properties, LeoMoon_Light_Studio_Object_Properties
 from . import deleteOperator
 
 def register():
     auto_load.register()
-
-    bpy.types.Scene.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Properties", type = LeoMoon_Light_Studio_Properties)
     bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
+    bpy.types.Scene.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Properties", type = LeoMoon_Light_Studio_Properties)
+    bpy.types.Object.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Object Properties", type = LeoMoon_Light_Studio_Object_Properties)
     deleteOperator.add_shortkeys()
     
 
diff --git a/src/common.py b/src/common.py
index f3d0e0a..4a7bafd 100644
--- a/src/common.py
+++ b/src/common.py
@@ -47,7 +47,9 @@ def get_view_layers(layer_collection):
             
 def isFamily(ob=None):
     if not ob:
-        ob = bpy.context.scene.objects.active
+        ob = bpy.context.view_layer.objects.active
+        if not ob:
+            return False
 
     if ob.name.startswith('LEOMOON_LIGHT_STUDIO'): return True
     if not ob.name.startswith('LLS_'): return False
diff --git a/src/deleteOperator.py b/src/deleteOperator.py
index 3d32825..c4998d3 100644
--- a/src/deleteOperator.py
+++ b/src/deleteOperator.py
@@ -1,6 +1,7 @@
 import bpy
 from bpy.props import BoolProperty
 from . common import findLightGrp
+from . import light_list
 
 class DeleteOperator(bpy.types.Operator):
     """ Custom delete """
@@ -15,7 +16,6 @@ class DeleteOperator(bpy.types.Operator):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
     
     def execute(self, context):
-        protected_groups = [findLightGrp(ob) for ob in context.selected_objects if ob.protected]
         protected_objects = (ob for ob in context.selected_objects if ob.protected)
         
         for obj in protected_objects:
@@ -28,6 +28,8 @@ class DeleteOperator(bpy.types.Operator):
         
         bpy.ops.object.delete(use_global=self.use_global)
 
+        light_list.update_light_list_set(context)
+
         return {'FINISHED'}
 
     # def invoke(self, context, event):
diff --git a/src/gui.py b/src/gui.py
index 364e7fc..8193322 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -40,8 +40,17 @@ class LLS_PT_Lights(bpy.types.Panel):
         layout = self.layout
         col = layout.column(align=True)
         row = col.row(align=True)
-        row.operator('scene.add_leomoon_studio_light', text='Add Light')
-        row.operator('scene.delete_leomoon_studio_light', text='Delete Light')
+        
+        props = context.scene.LLStudio
+
+        row = layout.row()
+        col = row.column()
+        col.template_list("LLS_UL_LightList", "Light_List", props, "light_list", props, "light_list_index", rows=5)
+
+        col = row.column(align=True)
+        col.operator('scene.add_leomoon_studio_light', icon='PLUS', text="")
+        col.operator('scene.delete_leomoon_studio_light', icon='TRASH', text="")
+
 
 @force_register
 class LLS_PT_Selected(bpy.types.Panel):
@@ -103,7 +112,7 @@ class LLS_PT_ProfileList(bpy.types.Panel):
 
         row = layout.row()
         col = row.column()
-        col.template_list("LLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
+        col.template_list("UI_UL_list", "Profile_List", props, "profile_list", props, "list_index", rows=5)
 
         col = row.column(align=True)
         col.operator('lls_list.new_profile', icon='PLUS', text="")
diff --git a/src/light_list.py b/src/light_list.py
new file mode 100644
index 0000000..01b19c7
--- /dev/null
+++ b/src/light_list.py
@@ -0,0 +1,148 @@
+import bpy
+from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProperty, EnumProperty, IntProperty
+import os, sys, subprocess
+from . common import *
+from itertools import chain
+from . operators.modal import close_control_panel
+
+_ = os.sep
+
+class LightListItem(bpy.types.PropertyGroup):
+    """ Group of properties representing an item in the list """
+    def update_name(self, context):
+        bpy.data.objects[self.mesh_name].LLStudio.light_name = self.name
+
+    name: StringProperty(
+            name="Profile Name",
+            default="Untitled",
+            update=update_name)
+
+    mesh_name: StringProperty(
+            description="",
+            default="")
+
+class LLS_UL_LightList(bpy.types.UIList):
+    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
+        custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.LLStudio.list_index else 'LIGHT'
+
+        if item.mesh_name in context.scene.objects:
+            # Make sure your code supports all 3 layout types
+            if self.layout_type in {'DEFAULT', 'COMPACT'}:
+                layout.prop(item, 'name', text='', emboss=False, translate=False)
+
+                mesh_object = context.scene.objects[item.mesh_name]
+                mesh_collection = get_collection(mesh_object)
+
+                view_layer = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+                icon = 'LIGHT' if view_layer.exclude else 'OUTLINER_OB_LIGHT'
+                layout.operator('light_studio.mute_toggle', emboss=False, icon=icon, text="").index = index
+
+                
+                props = context.scene.LLStudio
+                excluded=0
+                for li in props.light_list:
+                    if not li.mesh_name in context.scene.objects:
+                        continue
+                    mesh_object = context.scene.objects[li.mesh_name]
+                    mesh_collection = get_collection(mesh_object)
+                    vl = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+                    excluded += vl.exclude
+                
+                icon = 'SOLO_ON' if excluded == len(props.light_list)-1 and not view_layer.exclude else 'SOLO_OFF'
+                layout.operator('light_studio.isolate', emboss=False, icon=icon, text="").index = index
+
+            elif self.layout_type in {'GRID'}:
+                layout.alignment = 'CENTER'
+                layout.label("", icon = custom_icon)
+
+def get_list_index(self):
+    ob = bpy.context.view_layer.objects.active
+    if isFamily(ob):
+        for i, li in enumerate(self.light_list):
+            if li.mesh_name == ob.name:
+                return i
+    return -1
+
+def set_list_index(self, index):
+    selected_light = self.light_list[index]
+    ob = bpy.context.scene.objects[selected_light.mesh_name]       # Get the object
+    bpy.ops.object.select_all(action='DESELECT') # Deselect all objects
+    bpy.context.view_layer.objects.active = ob   # Make the cube the active object 
+    ob.select_set(True)
+
+def update_light_list_set(context):
+    props = context.scene.LLStudio
+    lls_collection, profile_collection = llscol_profilecol(context)
+    if profile_collection is not None:
+        props.light_list.clear()
+        lls_lights = set(profile_collection.children)
+        for col in lls_lights:
+            ll = props.light_list.add()
+            lls_mesh = [m for m in col.objects if m.name.startswith("LLS_LIGHT_MESH")]
+            if not lls_mesh:
+                bpy.ops.object.delete({"selected_objects": col.objects}, use_global=True)
+                bpy.data.collections.remove(col)
+                return update_light_list_set(context)
+
+            lls_mesh = lls_mesh[0]
+            ll.mesh_name = lls_mesh.name
+            ll.name = lls_mesh.LLStudio.light_name if lls_mesh.LLStudio.light_name else lls_mesh.name
+
+class LLS_OT_MuteToggle(bpy.types.Operator):
+    bl_idname = "light_studio.mute_toggle"
+    bl_label = "Mute Light"
+    bl_options = {"REGISTER", "UNDO", "INTERNAL"}
+
+    index: IntProperty(default=-1)
+
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
+
+    def execute(self, context):
+        props = context.scene.LLStudio
+        mesh_name = props.light_list[self.index].mesh_name
+        mesh_object = context.scene.objects[mesh_name]
+        mesh_collection = get_collection(mesh_object)
+
+        view_layer = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+        view_layer.exclude = not view_layer.exclude
+        return {"FINISHED"}
+
+class LLS_OT_Isolate(bpy.types.Operator):
+    bl_idname = "light_studio.isolate"
+    bl_label = "Isolate Light"
+    bl_options = {"REGISTER", "UNDO", "INTERNAL"}
+
+    index: IntProperty(default=-1)
+
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
+
+    def execute(self, context):
+        props = context.scene.LLStudio
+        mesh_name = props.light_list[self.index].mesh_name
+        mesh_object = context.scene.objects[mesh_name]
+        mesh_collection = get_collection(mesh_object)
+        view_layer = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+        
+        view_layers=[]
+        excluded=0
+        for li in props.light_list:
+            mesh_object = context.scene.objects[li.mesh_name]
+            mesh_collection = get_collection(mesh_object)
+
+            vl = find_view_layer(mesh_collection, context.view_layer.layer_collection)
+            view_layers.append(vl)
+            excluded += vl.exclude
+
+        if not view_layer.exclude and excluded == len(view_layers)-1:
+            for v in view_layers:
+                v.exclude = False
+        else:
+            for v in view_layers:
+                v.exclude = True
+            view_layer.exclude = False
+
+        return {"FINISHED"}
\ No newline at end of file
diff --git a/src/light_operators.py b/src/light_operators.py
index bb23ec2..a445d4d 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -4,6 +4,7 @@ from . light_profiles import ListItem, update_list_index
 from . common import *
 import os
 from . import operators
+from . import light_list
 
 _ = os.sep
 
@@ -18,6 +19,12 @@ class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
     list_index: IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
     last_empty: StringProperty(name="Name of last Empty holding profile", default="")
 
+    light_list: CollectionProperty(type = light_list.LightListItem)
+    light_list_index: IntProperty(name = "Index for light_list", default = 0, get=light_list.get_list_index, set=light_list.set_list_index)
+
+class LeoMoon_Light_Studio_Object_Properties(bpy.types.PropertyGroup):
+    # protected: bpy.props.BoolProperty(name = 'protected', default = False)
+    light_name: bpy.props.StringProperty()
 
 class CreateBlenderLightStudio(bpy.types.Operator):
     bl_idname = "scene.create_leomoon_light_studio"
@@ -167,6 +174,8 @@ class AddBSLight(bpy.types.Operator):
         # refreshMaterials()
 
         operators.update()
+        light_list.update_light_list_set(context)
+
         return {"FINISHED"}
 
 class DeleteBSLight(bpy.types.Operator):
@@ -195,6 +204,8 @@ class DeleteBSLight(bpy.types.Operator):
                 bpy.data.collections.remove(collection)
 
         operators.update()
+        light_list.update_light_list_set(context)
+
         return {"FINISHED"}
 
     def invoke(self, context, event):
diff --git a/src/light_profiles.py b/src/light_profiles.py
index c0c4fd3..4881872 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -4,6 +4,7 @@ import os, sys, subprocess
 from . common import *
 from itertools import chain
 from . operators.modal import close_control_panel
+from . import light_list
 
 _ = os.sep
 
@@ -21,19 +22,6 @@ class ListItem(bpy.types.PropertyGroup):
             description="",
             default="")
 
-class LLS_UL_List(bpy.types.UIList):
-    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
-        custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.LLStudio.list_index else 'LIGHT'
-
-        # Make sure your code supports all 3 layout types
-        if self.layout_type in {'DEFAULT', 'COMPACT'}:
-            layout.prop(item, 'name', text='', icon = custom_icon, emboss=False, translate=False)
-
-        elif self.layout_type in {'GRID'}:
-            layout.alignment = 'CENTER'
-            layout.label("", icon = custom_icon)
-
-
 class LIST_OT_NewItem(bpy.types.Operator):
 
     bl_idname = "lls_list.new_profile"
@@ -105,6 +93,8 @@ class LIST_OT_NewItem(bpy.types.Operator):
         props.last_empty = profile.name
         props.list_index = len(props.profile_list)-1
 
+        light_list.update_light_list_set(context)
+
         return{'FINISHED'}
 
 class LIST_OT_DeleteItem(bpy.types.Operator):
@@ -141,6 +131,8 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
             index = index - 1
         props.list_index = index
 
+        light_list.update_light_list_set(context)
+
         return{'FINISHED'}
 
 def duplicate_collection(collection, parent_collection):
@@ -312,7 +304,6 @@ class LIST_OT_MoveItem(bpy.types.Operator):
 
         return{'FINISHED'}
 
-
 def update_list_index(self, context):
     props = context.scene.LLStudio
 
@@ -340,12 +331,14 @@ def update_list_index(self, context):
     if panel_global:
         update_light_sets(panel_global, bpy.context, always=True)
 
+    light_list.update_light_list_set(context)
+
 # import/export
 import json, time
 script_file = os.path.realpath(__file__)
 dir = os.path.dirname(script_file)
 
-VERSION = 2.00
+VERSION = 2.01
 def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
     plist = props.profile_list
     for profile in profiles:
@@ -391,6 +384,9 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
 
             lmesh.rotation_euler.x = light['rotation']
 
+            if 'light_name' in light:
+                lmesh.LLStudio.light_name = light['light_name']
+
             lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['Texture Switch']
             lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
             lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1] = light['Color Overlay'][1]
@@ -465,6 +461,7 @@ def compose_profile(list_index):
         lmesh = [ob for ob in light_collection.objects if ob.name.startswith('LLS_LIGHT_MESH')][0]
         actuator = [ob for ob in light_collection.objects if ob.name.startswith('LLS_ROTATION')][0]
         light = {}
+        light['light_name'] = lmesh.LLStudio.light_name
         light['radius'] = lmesh.location.x
         light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
         light['scale'] = [lmesh.scale.x, lmesh.scale.y, lmesh.scale.z]
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 6d2d2cc..ce17986 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -4,6 +4,7 @@ from mathutils import *
 
 from . modal_utils import *
 from . import *
+from .. import light_list
 
 from .modal_utils import shader2Dcolor
 from gpu_extras.batch import batch_for_shader
@@ -55,6 +56,8 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget):
         bpy.context.workspace.status_text_set(f"Rot: {self.angle():.3f}")
         #context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
 
+        if not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+            return {"RUNNING_MODAL"}
         return {"PASS_THROUGH"}
 
 class LLS_OT_Scale(bpy.types.Operator, MouseWidget):
@@ -161,6 +164,7 @@ W_LEFT = 1
 W_RIGHT = 2
 W_TOP = 4
 W_BOTTOM = 8
+# CTRL, SHIFT, ALT = False
 class LLS_OT_control_panel(bpy.types.Operator):
     bl_idname = "light_studio.control_panel"
     bl_label = "LightStudio Control Panel"
@@ -205,6 +209,8 @@ class LLS_OT_control_panel(bpy.types.Operator):
         return dx, dy, area_mouse_x, area_mouse_y
 
     def invoke(self, context, event):
+        light_list.update_light_list_set(context)
+
         global running_modals
         running_modals += 1
         if running_modals > 1:
@@ -233,6 +239,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
         #context.area.header_text_set(text=textinfo)
 
         self.ctrl = False
+        self.modifier_key = False
 
         return {"RUNNING_MODAL"}
     
@@ -242,6 +249,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
 
         for b in Button.buttons:
             if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
+                context.window.cursor_set('DEFAULT')
                 return 0
 
         if area_mouse_x < self.panel.point_lt.x+treshold and area_mouse_x >= self.panel.point_lt.x-treshold:
@@ -274,7 +282,9 @@ class LLS_OT_control_panel(bpy.types.Operator):
             context.area.tag_redraw()
             return {"FINISHED"}
 
-        # print(event.type, event.value)
+        if event.type != "MOUSEMOVE":
+            print(event.type, event.value)
+
         if not context.area or (context.object and not context.object.mode == 'OBJECT'):
             self._unregister_handler()
             return {"CANCELLED"}
@@ -284,7 +294,10 @@ class LLS_OT_control_panel(bpy.types.Operator):
             update_light_sets(self.panel, context)
             LightImage.refresh()
 
-            if event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+            if event.type in {"TIMER", "NONE", "WINDOW_DEACTIVATE"}:
+                self.ctrl = False
+                self.modifier_key = False
+            elif event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
                 dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
                 
                 # Draw resize cursor
@@ -318,8 +331,10 @@ class LLS_OT_control_panel(bpy.types.Operator):
             if event.value == "PRESS":
                 if event.type in {"LEFT_CTRL"}:
                     self.ctrl = True
-
-                if event.type in {"R"}:
+                if event.type in {"LEFT_CTRL", "RIGHT_CTRL", "LEFT_SHIFT", "RIGHT_SHIFT", "LEFT_ALT", "RIGHT_ALT"}:
+                    self.modifier_key = True
+                
+                if event.type in {"R"} and not self.modifier_key:
                     active_object = None
                     if LightImage.selected_object:
                         active_object = LightImage.selected_object
@@ -327,7 +342,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     if active_object:
                         bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
                         return {'RUNNING_MODAL'}
-                elif event.type in {"S"}:
+                elif event.type in {"S"} and not self.modifier_key:
                     active_object = None
                     if LightImage.selected_object:
                         active_object = LightImage.selected_object
@@ -463,10 +478,9 @@ class LLS_OT_control_panel(bpy.types.Operator):
                 elif event.type == "LEFT_SHIFT":
                     self.precision_mode = False
                     return {'RUNNING_MODAL'}
-                elif event.type in {"LEFT_CTRL"}:
-                    self.ctrl = False
-
-            if event.value == "CLICK":
+                if event.type in {"LEFT_CTRL", "RIGHT_CTRL", "LEFT_SHIFT", "RIGHT_SHIFT", "LEFT_ALT", "RIGHT_ALT"}:
+                    self.modifier_key = False
+            elif event.value == "CLICK":
                 # Left mouse button clicked
                 if event.type == "LEFTMOUSE":
                     return {"PASS_THROUGH"}
@@ -512,7 +526,12 @@ def update_light_sets(panel, context, always=False):
                 LightImage.remove(col)
 
             for col in to_add:
-                LightImage(context, panel, col)
+                try:
+                    LightImage(context, panel, col)
+                except:
+                    # Some crucial objects are missing. Delete whole light collection
+                    bpy.ops.object.delete({"selected_objects": col.objects}, use_global=True)
+                    bpy.data.collections.remove(col)
 
             update_clear()
 
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index d572507..a364584 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -470,6 +470,8 @@ class LightImage(Rectangle):
     
     @classmethod
     def refresh(cls):
+        props = bpy.context.scene.LLStudio
+
         cls.selected_object = None
         for l in cls.lights:
             try:
@@ -534,10 +536,13 @@ class LightImage(Rectangle):
         self.panel = panel
         self.__panel_loc = Vector((.5, .5))
 
+        # try:
         self._collection = lls_light_collection
         self._lls_mesh = [m for m in lls_light_collection.objects if m.name.startswith("LLS_LIGHT_MESH")][0]
         self._lls_actuator = self._lls_mesh.parent
         self._view_layer = find_view_layer(self._collection, context.view_layer.layer_collection)
+        # except Exception:
+        #     raise Exception
         
         self._image_path = ""
         self._lls_rot = None

commit 2e03caad82efd61e4473c11a870856ca50fd5f8f
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jul 10 16:23:37 2020 -0700

    readme change

diff --git a/README.md b/README.md
index 90dfba4..291d893 100644
--- a/README.md
+++ b/README.md
@@ -45,7 +45,7 @@ Thank you.
 ## Changelog
 ### 2.5.2 2020-07-10:
 * Fixed light going outside of LightPanel
-* Added LighPanel resizing
+* Added resizing to LighPanel
 * Minor bugfixes
 
 ### 2.5.1 2020-05-08:

commit 1c0875d4d50c6b6ddd43c7909bccaddad94f7063
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jul 10 15:44:03 2020 -0700

    readme change

diff --git a/README.md b/README.md
index 2503e4a..90dfba4 100644
--- a/README.md
+++ b/README.md
@@ -43,6 +43,11 @@ If you think this plugin speeds up your workflow, consider funding the developme
 Thank you.
 
 ## Changelog
+### 2.5.2 2020-07-10:
+* Fixed light going outside of LightPanel
+* Added LighPanel resizing
+* Minor bugfixes
+
 ### 2.5.1 2020-05-08:
 * Fixed Copy Profile function
 * Fixed Copy Profile to Scene function

commit c70e2c9acd71cc08022a9a3d131fc9369d7b2709
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jul 10 15:24:10 2020 -0700

    2.5.2

diff --git a/src/__init__.py b/src/__init__.py
index d5d96fd..8810b66 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -4,7 +4,7 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 5, 1),
+    "version": (2, 5, 2),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 3ce8307..f3d5a3a 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -40,7 +40,7 @@ class LLS_OT_Rotate(bpy.types.Operator, MouseWidget):
         super().invoke(context, event)
         self.base_object_rotation = LightImage.selected_object._lls_mesh.rotation_euler.x
         return {"RUNNING_MODAL"}
-    
+
     def _finish(self, context, event):
         bpy.context.workspace.status_text_set(None)
         #context.area.header_text_set(text=None)
@@ -73,7 +73,7 @@ class LLS_OT_Scale(bpy.types.Operator, MouseWidget):
         super().invoke(context, event)
         self.base_object_scale = LightImage.selected_object._lls_mesh.scale.copy()
         return {"RUNNING_MODAL"}
-    
+
     def _cancel(self, context, event):
         LightImage.selected_object._lls_mesh.scale = self.base_object_scale
         bpy.context.workspace.status_text_set(None)
@@ -120,7 +120,7 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget):
         super().invoke(context, event)
         self.base_object_rotation = LightImage.selected_object._lls_actuator.rotation_euler.copy()
         return {"RUNNING_MODAL"}
-    
+
     def _cancel(self, context, event):
         LightImage.selected_object._lls_actuator.rotation_euler = self.base_object_rotation
         global GRABBING
@@ -157,6 +157,10 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget):
 
 panel_global = None
 running_modals = 0
+W_LEFT = 1
+W_RIGHT = 2
+W_TOP = 4
+W_BOTTOM = 8
 class LLS_OT_control_panel(bpy.types.Operator):
     bl_idname = "light_studio.control_panel"
     bl_label = "LightStudio Control Panel"
@@ -178,6 +182,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
         self.click_manager = ClickManager()
         self.active_feature = None
         self.precision_mode = False
+        self.border_touch = 0
 
     def __del__(self):
         self._unregister_handler()
@@ -212,7 +217,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
         aw = context.area.width
         ah = context.area.height
         pw = min(aw-60, 800)
-        
+
         global panel_global
         if not panel_global:
             panel_global = Panel(Vector((30, 25)), pw, pw*(9/16))
@@ -230,7 +235,38 @@ class LLS_OT_control_panel(bpy.types.Operator):
         self.ctrl = False
 
         return {"RUNNING_MODAL"}
-    
+
+    def border_touch_point(self, context, area_mouse_x, area_mouse_y):
+        touch_point = 0
+        treshold = 5
+
+        for b in Button.buttons:
+            if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
+                return 0
+
+        if area_mouse_x < self.panel.point_lt.x+treshold and area_mouse_x >= self.panel.point_lt.x-treshold:
+            touch_point |= W_LEFT
+            context.window.cursor_set('MOVE_X')
+        elif area_mouse_x > self.panel.point_rb.x-treshold and area_mouse_x <= self.panel.point_rb.x+treshold:
+            touch_point |= W_RIGHT
+            context.window.cursor_set('MOVE_X')
+        if area_mouse_y > self.panel.point_lt.y-treshold and area_mouse_y <= self.panel.point_lt.y+treshold:
+            touch_point |= W_TOP
+            context.window.cursor_set('MOVE_Y')
+        elif area_mouse_y < self.panel.point_rb.y+treshold and area_mouse_y >= self.panel.point_rb.y-treshold:
+            touch_point |= W_BOTTOM
+            context.window.cursor_set('MOVE_Y')
+
+        if touch_point == W_LEFT | W_TOP\
+            or touch_point == W_LEFT | W_BOTTOM\
+            or touch_point == W_RIGHT | W_TOP\
+            or touch_point == W_RIGHT | W_BOTTOM:
+            context.window.cursor_set('SCROLL_XY')
+        elif touch_point == 0:
+            context.window.cursor_set('DEFAULT')
+
+        return touch_point
+
     def modal(self, context, event):
         global running_modals
         if running_modals < 1:
@@ -250,11 +286,22 @@ class LLS_OT_control_panel(bpy.types.Operator):
 
             if event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
                 dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+
+                # Draw resize cursor
+                touch_point = self.border_touch_point(context, area_mouse_x, area_mouse_y)
+                if self.border_touch and event.value == "PRESS":
+                    if self.border_touch & W_LEFT:
+                        self.panel.point_lt.x = min(area_mouse_x, self.panel.point_rb.x - 100)
+                    elif self.border_touch & W_RIGHT:
+                        self.panel.point_rb.x = max(area_mouse_x, self.panel.point_lt.x + 100)
+                    if self.border_touch & W_TOP:
+                        self.panel.point_lt.y = max(area_mouse_y, self.panel.point_rb.y + 100)
+                    elif self.border_touch & W_BOTTOM:
+                        self.panel.point_rb.y = min(area_mouse_y, self.panel.point_lt.y - 100)
+                    self.panel.move(Vector([0,0]))
+
                 if self.clicked_object and self.panel_moving:
-                    # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
-                    # self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
                     if isinstance(self.clicked_object, Panel):
-                        # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
                         self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
                     else:
                         active_object = None
@@ -263,11 +310,11 @@ class LLS_OT_control_panel(bpy.types.Operator):
                         if active_object and not GRABBING:
                             bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
                             self.panel_moving = False
-                    
+
                     return {"RUNNING_MODAL"}
 
                 return {"PASS_THROUGH"}
-            
+
             if event.value == "PRESS":
                 if event.type in {"LEFT_CTRL"}:
                     self.ctrl = True
@@ -276,7 +323,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     active_object = None
                     if LightImage.selected_object:
                         active_object = LightImage.selected_object
-                    
+
                     if active_object:
                         bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
                         return {'RUNNING_MODAL'}
@@ -284,7 +331,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     active_object = None
                     if LightImage.selected_object:
                         active_object = LightImage.selected_object
-                    
+
                     if active_object:
                         bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
                         return {'RUNNING_MODAL'}
@@ -295,7 +342,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
 
                     if not self.clicked_object:
                         return {"PASS_THROUGH"}
-                    
+
                     if hasattr(self.clicked_object, 'mute'):
                         muted_count = len([l for l in LightImage.lights if l.mute])
                         unmuted_count = len(LightImage.lights) - muted_count
@@ -316,10 +363,11 @@ class LLS_OT_control_panel(bpy.types.Operator):
 
                     if hasattr(self.clicked_object, 'select'):
                         self.clicked_object.select()
-                    
+                        send_light_to_top(self.clicked_object)
+
                     return {"RUNNING_MODAL"}
 
-                # Left mouse button pressed            
+                # Left mouse button pressed
                 elif event.type == "LEFTMOUSE":
                     dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
 
@@ -330,8 +378,15 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     else:
                         # Button
                         self.clicked_object = overlapped
+
+                    # Resize
+                    touch_point = self.border_touch_point(context, area_mouse_x, area_mouse_y)
+                    if touch_point and not isinstance(self.clicked_object, Button):
+                        self.border_touch = touch_point
+                        return {"RUNNING_MODAL"}
+
                     self.panel_moving = self.clicked_object != None
-                    
+
                     click_result = self.click_manager.click(self.clicked_object)
                     if not self.ctrl and hasattr(self.clicked_object, 'mute'):
                         if click_result == "TRIPLE":
@@ -390,19 +445,20 @@ class LLS_OT_control_panel(bpy.types.Operator):
                 elif event.type == "LEFT_SHIFT":
                     self.precision_mode = True
                     return {'RUNNING_MODAL'}
-                
+
                 # Return (Enter) key is pressed
                 elif event.type == "RET":
                     bpy.context.workspace.status_text_set(None)
                     #context.area.header_text_set(text=None)
                     self._unregister_handler()
                     return {'FINISHED'}
-            
+
             if event.value == "RELEASE":
                 #bpy.context.workspace.status_text_set(textinfo)
                 #context.area.header_text_set(text=textinfo)
                 if event.type == "LEFTMOUSE":
                     self.panel_moving = False
+                    self.border_touch = 0
                 elif event.type == "LEFT_SHIFT":
                     self.precision_mode = False
                     return {'RUNNING_MODAL'}
@@ -418,7 +474,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
             import traceback
             traceback.print_exc()
             return {"CANCELLED"}
-        
+
         return {"PASS_THROUGH"}
 
     def find_clicked(self, area_mouse_x, area_mouse_y, overlapping=False):
@@ -432,7 +488,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
 
         if overlapping and overlapped:
             return overlapped
-        
+
         for b in Button.buttons:
             if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
                 return b
@@ -450,7 +506,7 @@ def update_light_sets(panel, context, always=False):
 
             to_delete = working_set.difference(lls_lights)
             to_add =  lls_lights.difference(working_set)
-            
+
             for col in to_delete:
                 LightImage.remove(col)
 
@@ -462,4 +518,3 @@ def update_light_sets(panel, context, always=False):
 def close_control_panel():
     global running_modals
     running_modals = 0
-    
\ No newline at end of file
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 143b88c..d572507 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -36,8 +36,8 @@ fragment_shader = '''
     layout(location = 1) out vec4 trash;
 
     uniform sampler2D image;
-    uniform float panel_point_left;
-    uniform float panel_point_right;
+    uniform vec2 panel_point_lt;
+    uniform vec2 panel_point_rb;
 
     uniform vec4 color_overlay = vec4(0);
     uniform float intensity = 1;
@@ -62,7 +62,7 @@ fragment_shader = '''
     void main()
     {
         // Trash output - sum all uniforms to prevent compiler from skipping currently unused ones
-        trash = vec4(panel_point_left+panel_point_right+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
+        trash = vec4(panel_point_lt.x+panel_point_rb.x+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
         
         // Texture Switch + Intensity
         // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
@@ -127,7 +127,8 @@ fragment_shader = '''
         fragColor.a = (texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_left ? fragColor.a : 0;
 
         // Panel bound clipping
-        if(gl_FragCoord.x < panel_point_left || gl_FragCoord.x > panel_point_right)
+        if((gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
+         || (gl_FragCoord.y < panel_point_rb.y || gl_FragCoord.y > panel_point_lt.y))
             discard;
     }
 '''
@@ -158,8 +159,9 @@ border_fragment_shader= '''
     {
         fragColor = color;
 
-        if(gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
-            fragColor.rgba = vec4(0);
+        if((gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
+         || (gl_FragCoord.y < panel_point_rb.y || gl_FragCoord.y > panel_point_lt.y))
+            discard;
     }
 '''
 
@@ -645,8 +647,8 @@ class LightImage(Rectangle):
         bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
         lightIconShader.uniform_int("image", 0)
 
-        lightIconShader.uniform_float("panel_point_left", self.panel.point_lt.x)
-        lightIconShader.uniform_float("panel_point_right", self.panel.point_rb.x)
+        lightIconShader.uniform_float("panel_point_lt", self.panel.point_lt)
+        lightIconShader.uniform_float("panel_point_rb", self.panel.point_rb)
 
         try:
             # material properties

commit 23ab11df78c7e221c6775dfaf1a3a62defa63b0e
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Jul 8 17:33:55 2020 +0200

    2.5.2

diff --git a/src/operators/modal.py b/src/operators/modal.py
index 264321c..6d2d2cc 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -379,7 +379,9 @@ class LLS_OT_control_panel(bpy.types.Operator):
                         self.clicked_object = overlapped
 
                     # Resize
+                    # Find border touch point. 0 when no point found
                     touch_point = self.border_touch_point(context, area_mouse_x, area_mouse_y)
+                    # Make sure border touch point is not obstructed by other objects
                     if touch_point and not isinstance(self.clicked_object, Button):
                         self.border_touch = touch_point
                         return {"RUNNING_MODAL"}

commit 6aef1f393aa15a2ad6374338dd93a7be922544f1
Author: StyriamMZ <styriam@o2.pl>
Date:   Tue Jul 7 23:20:43 2020 +0200

    2.5.2

diff --git a/src/__init__.py b/src/__init__.py
index d5d96fd..8810b66 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -4,7 +4,7 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 5, 1),
+    "version": (2, 5, 2),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 3ce8307..264321c 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -157,6 +157,10 @@ class LLS_OT_Grab(bpy.types.Operator, MouseWidget):
 
 panel_global = None
 running_modals = 0
+W_LEFT = 1
+W_RIGHT = 2
+W_TOP = 4
+W_BOTTOM = 8
 class LLS_OT_control_panel(bpy.types.Operator):
     bl_idname = "light_studio.control_panel"
     bl_label = "LightStudio Control Panel"
@@ -178,6 +182,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
         self.click_manager = ClickManager()
         self.active_feature = None
         self.precision_mode = False
+        self.border_touch = 0
 
     def __del__(self):
         self._unregister_handler()
@@ -231,6 +236,37 @@ class LLS_OT_control_panel(bpy.types.Operator):
 
         return {"RUNNING_MODAL"}
     
+    def border_touch_point(self, context, area_mouse_x, area_mouse_y):
+        touch_point = 0
+        treshold = 5
+
+        for b in Button.buttons:
+            if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
+                return 0
+
+        if area_mouse_x < self.panel.point_lt.x+treshold and area_mouse_x >= self.panel.point_lt.x-treshold:
+            touch_point |= W_LEFT
+            context.window.cursor_set('MOVE_X')
+        elif area_mouse_x > self.panel.point_rb.x-treshold and area_mouse_x <= self.panel.point_rb.x+treshold:
+            touch_point |= W_RIGHT
+            context.window.cursor_set('MOVE_X')
+        if area_mouse_y > self.panel.point_lt.y-treshold and area_mouse_y <= self.panel.point_lt.y+treshold:
+            touch_point |= W_TOP
+            context.window.cursor_set('MOVE_Y')
+        elif area_mouse_y < self.panel.point_rb.y+treshold and area_mouse_y >= self.panel.point_rb.y-treshold:
+            touch_point |= W_BOTTOM
+            context.window.cursor_set('MOVE_Y')
+
+        if touch_point == W_LEFT | W_TOP\
+            or touch_point == W_LEFT | W_BOTTOM\
+            or touch_point == W_RIGHT | W_TOP\
+            or touch_point == W_RIGHT | W_BOTTOM:
+            context.window.cursor_set('SCROLL_XY')
+        elif touch_point == 0:
+            context.window.cursor_set('DEFAULT')
+        
+        return touch_point
+
     def modal(self, context, event):
         global running_modals
         if running_modals < 1:
@@ -250,11 +286,22 @@ class LLS_OT_control_panel(bpy.types.Operator):
 
             if event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
                 dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                
+                # Draw resize cursor
+                touch_point = self.border_touch_point(context, area_mouse_x, area_mouse_y)
+                if self.border_touch and event.value == "PRESS":
+                    if self.border_touch & W_LEFT:
+                        self.panel.point_lt.x = min(area_mouse_x, self.panel.point_rb.x - 100)
+                    elif self.border_touch & W_RIGHT:
+                        self.panel.point_rb.x = max(area_mouse_x, self.panel.point_lt.x + 100)
+                    if self.border_touch & W_TOP:
+                        self.panel.point_lt.y = max(area_mouse_y, self.panel.point_rb.y + 100)
+                    elif self.border_touch & W_BOTTOM:
+                        self.panel.point_rb.y = min(area_mouse_y, self.panel.point_lt.y - 100)
+                    self.panel.move(Vector([0,0]))
+
                 if self.clicked_object and self.panel_moving:
-                    # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
-                    # self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
                     if isinstance(self.clicked_object, Panel):
-                        # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
                         self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
                     else:
                         active_object = None
@@ -330,8 +377,15 @@ class LLS_OT_control_panel(bpy.types.Operator):
                     else:
                         # Button
                         self.clicked_object = overlapped
-                    self.panel_moving = self.clicked_object != None
+
+                    # Resize
+                    touch_point = self.border_touch_point(context, area_mouse_x, area_mouse_y)
+                    if touch_point and not isinstance(self.clicked_object, Button):
+                        self.border_touch = touch_point
+                        return {"RUNNING_MODAL"}
                     
+                    self.panel_moving = self.clicked_object != None
+
                     click_result = self.click_manager.click(self.clicked_object)
                     if not self.ctrl and hasattr(self.clicked_object, 'mute'):
                         if click_result == "TRIPLE":
@@ -403,6 +457,7 @@ class LLS_OT_control_panel(bpy.types.Operator):
                 #context.area.header_text_set(text=textinfo)
                 if event.type == "LEFTMOUSE":
                     self.panel_moving = False
+                    self.border_touch = 0
                 elif event.type == "LEFT_SHIFT":
                     self.precision_mode = False
                     return {'RUNNING_MODAL'}
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 143b88c..d572507 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -36,8 +36,8 @@ fragment_shader = '''
     layout(location = 1) out vec4 trash;
 
     uniform sampler2D image;
-    uniform float panel_point_left;
-    uniform float panel_point_right;
+    uniform vec2 panel_point_lt;
+    uniform vec2 panel_point_rb;
 
     uniform vec4 color_overlay = vec4(0);
     uniform float intensity = 1;
@@ -62,7 +62,7 @@ fragment_shader = '''
     void main()
     {
         // Trash output - sum all uniforms to prevent compiler from skipping currently unused ones
-        trash = vec4(panel_point_left+panel_point_right+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
+        trash = vec4(panel_point_lt.x+panel_point_rb.x+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
         
         // Texture Switch + Intensity
         // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
@@ -127,7 +127,8 @@ fragment_shader = '''
         fragColor.a = (texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_left ? fragColor.a : 0;
 
         // Panel bound clipping
-        if(gl_FragCoord.x < panel_point_left || gl_FragCoord.x > panel_point_right)
+        if((gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
+         || (gl_FragCoord.y < panel_point_rb.y || gl_FragCoord.y > panel_point_lt.y))
             discard;
     }
 '''
@@ -158,8 +159,9 @@ border_fragment_shader= '''
     {
         fragColor = color;
 
-        if(gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
-            fragColor.rgba = vec4(0);
+        if((gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
+         || (gl_FragCoord.y < panel_point_rb.y || gl_FragCoord.y > panel_point_lt.y))
+            discard;
     }
 '''
 
@@ -645,8 +647,8 @@ class LightImage(Rectangle):
         bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
         lightIconShader.uniform_int("image", 0)
 
-        lightIconShader.uniform_float("panel_point_left", self.panel.point_lt.x)
-        lightIconShader.uniform_float("panel_point_right", self.panel.point_rb.x)
+        lightIconShader.uniform_float("panel_point_lt", self.panel.point_lt)
+        lightIconShader.uniform_float("panel_point_rb", self.panel.point_rb)
 
         try:
             # material properties

commit e7317a9885f4eaf13b17d1e22eecf7f2616be603
Merge: 81baef5 2b7d6e9
Author: StyriamMZ <47333958+StyriamMZ@users.noreply.github.com>
Date:   Tue Jul 7 22:43:51 2020 +0200

    Merge pull request #2 from leomoon-studios/master
    
    Merge

commit 2b7d6e90589899e3fc1f609f1677a4a93a605ec3
Author: Amin Persia <leomoon@gmail.com>
Date:   Sat May 9 11:50:07 2020 -0700

    changed gui file

diff --git a/GUI b/GUI
index 7833878..198a7d3 100644
--- a/GUI
+++ b/GUI
@@ -1,20 +1,20 @@
 * BUTTON ICONS GUIDE:
-	[+] = Add light (icon: ADD)
-	[-] = Delete light (icon: REMOVE)
-	[L] = Lock light (icon: UNLOCKED, LOCKED)
-	[V] = Show/hide light (icon: HIDE_OFF, HIDE_ON)
-	[S] = Solo selected light (icon: SOLO_OFF, SOLO_ON)
-	[C] = Copy menu (icon: DUPLICATE)
+    [+] = Add light (icon: ADD)
+    [-] = Delete light (icon: REMOVE)
+    [L] = Lock light (icon: UNLOCKED, LOCKED)
+    [V] = Show/hide light (icon: HIDE_OFF, HIDE_ON)
+    [S] = Solo selected light (icon: SOLO_OFF, SOLO_ON)
+    [C] = Copy menu (icon: DUPLICATE)
 
 New scene that doesn't have LightStudio:
  Studio
-	[            Create LightStudio             ]
+    [            Create LightStudio             ]
 
 
 After adding LightStudio:
  Studio
-	[            Delete LightStudio             ]
-	[          Show LightStudio Panel           ]
+    [            Delete LightStudio             ]
+    [          Show LightStudio Panel           ]
  Lights
     --------------------------------------- [+]
     | Light 1                      [L][V][S]| [-]
@@ -27,17 +27,17 @@ After adding LightStudio:
     -------------------------------------------
     |              -------------              |
     |              |             |              |
-	|              |             |              |
-	|              |             |              |
+    |              |             |              |
+    |              |             |              |
     |              |             |              |
     |              |             |              |
     |              -------------              |
     | Soft Box A                                |
-	|  Texture Switch                  1.000  |
+    |  Texture Switch                  1.000  |
     -------------------------------------------
     Color Overlay:                      [       ]
     -------------------------------------------
-	|  Color Saturation:               0.300  |
+    |  Color Saturation:               0.300  |
     |  Intensity:                      2.000  |
     |  Mask - Gradient Switch:         0.000  |
     |  Mask - Gradient Type:           0.000  |
@@ -64,8 +64,8 @@ After adding LightStudio:
     |                                       | []
     ---------------------------------------
  Import/Export
-	[          Export Selected Profile          ]
-	[            Export All Profiles            ]
-	[              Import Profiles              ]
+    [          Export Selected Profile          ]
+    [            Export All Profiles            ]
+    [              Import Profiles              ]
  Misc
-	[            Find Missing Textures          ]
\ No newline at end of file
+    [            Find Missing Textures          ]
\ No newline at end of file

commit 70bbbaca76f76e862a8b47c7c009fabe421fbc21
Author: Amin Persia <leomoon@gmail.com>
Date:   Sat May 9 00:21:03 2020 -0700

    minor changes

diff --git a/src/light_operators.py b/src/light_operators.py
index 333aee0..bb23ec2 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -99,12 +99,13 @@ class SetBackground(bpy.types.Operator):
     bl_description = "Darken background and disable background influence"
     bl_label = "Background Setup (Optional)"
     bl_options = {"REGISTER", "UNDO"}
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list """
-        return len(context.scene.LLStudio.profile_list)
+    # @classmethod
+    # def poll(self, context):
+        # """ Enable if there's something in the list """
+        # return len(context.scene.LLStudio.profile_list)
 
     def execute(self, context):
+        bpy.context.scene.render.engine = 'CYCLES'
         if bpy.data.worlds.get('LightStudio') is None:
             bpy.context.scene.world = bpy.data.worlds.new('LightStudio')
         else:

commit 5dbd146a1926994d82efeb76c387267f881a3164
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri May 8 12:35:01 2020 -0700

    added changelog for 2.5.1 to readme.md

diff --git a/README.md b/README.md
index d6b892f..2503e4a 100644
--- a/README.md
+++ b/README.md
@@ -43,6 +43,12 @@ If you think this plugin speeds up your workflow, consider funding the developme
 Thank you.
 
 ## Changelog
+### 2.5.1 2020-05-08:
+* Fixed Copy Profile function
+* Fixed Copy Profile to Scene function
+* Fixed LightStudio world node from being created again if it exists
+* Added Open Textures Folder button
+
 ### 2.5.0 2020-03-23:
 * Fixed LightStudio error when opening Bledner 2.8x
 * Fixed LightStudio error when deleting studio

commit a554d8e2d046da5e2937a376a71be54740dcc76b
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri May 8 11:47:31 2020 -0700

    removed skrypt folder

diff --git a/.gitignore b/.gitignore
index b07fc4d..34ea7d0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,7 +7,7 @@ __pycache__/
 *.so
 
 # Distribution / packaging
-/skrypt/
+skrypt/
 .Python
 build/
 develop-eggs/
diff --git a/skrypt/leomoon_lightstudio.zip.001 b/skrypt/leomoon_lightstudio.zip.001
deleted file mode 100644
index 56fc9e3..0000000
Binary files a/skrypt/leomoon_lightstudio.zip.001 and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio.zip.002 b/skrypt/leomoon_lightstudio.zip.002
deleted file mode 100644
index 38ef6ae..0000000
Binary files a/skrypt/leomoon_lightstudio.zip.002 and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/BLS3.blend b/skrypt/leomoon_lightstudio/BLS3.blend
deleted file mode 100644
index 5939dec..0000000
Binary files a/skrypt/leomoon_lightstudio/BLS3.blend and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/__init__.py b/skrypt/leomoon_lightstudio/__init__.py
deleted file mode 100644
index e9b6f34..0000000
--- a/skrypt/leomoon_lightstudio/__init__.py
+++ /dev/null
@@ -1,40 +0,0 @@
-#Created by Striam Sp. z o.o.
-
-bl_info = {
-    "name": "LeoMoon LightStudio",
-    "description": "Easy setup for complex studio lighting",
-    "author": "LeoMoon Studios",
-    "version": (2, 5, 0),
-    "blender": (2, 80, 0),
-    "location": "View3D -> Tools -> Light Studio",
-    "wiki_url": "",
-    "category": "User Interface" }
-    
-    
-import bpy      
-
-# load and reload submodules
-##################################    
-
-from . import auto_load
-
-auto_load.init()
-
-
-# register
-################################## 
-
-from . light_operators import Blender_Light_Studio_Properties
-from . import deleteOperator
-
-def register():
-    auto_load.register()
-
-    bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
-    bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
-    deleteOperator.add_shortkeys()
-    
-
-def unregister():
-    deleteOperator.remove_shortkeys()
-    auto_load.unregister()
diff --git a/skrypt/leomoon_lightstudio/auto_load.py b/skrypt/leomoon_lightstudio/auto_load.py
deleted file mode 100644
index 0f930b5..0000000
--- a/skrypt/leomoon_lightstudio/auto_load.py
+++ /dev/null
@@ -1,184 +0,0 @@
-import os
-import bpy
-import sys
-import typing
-import inspect
-import pkgutil
-import importlib
-from pathlib import Path
-
-__all__ = (
-    "init",
-    "register",
-    "unregister",
-)
-
-modules = None
-ordered_classes = None
-ignored=[]
-auto_annotations = False
-def init(ignore=[], make_annotations=False):
-    global modules
-    global ordered_classes
-    global ignored    
-    global fifo_cls
-    global auto_annotations
-
-    ignored = ignore
-    modules = get_all_submodules(Path(__file__).parent)
-    ordered_classes = get_ordered_classes_to_register(modules)
-    auto_annotations = make_annotations
-
-def register():
-    for cls in fifo_cls:
-        if auto_annotations:
-            make_annotations(cls)
-        bpy.utils.register_class(cls)
-
-    for cls in ordered_classes:
-        if cls not in fifo_cls:
-            if auto_annotations:
-                make_annotations(cls)
-            bpy.utils.register_class(cls)
-
-    for module in modules:
-        if module.__name__ == __name__:
-            continue
-        if hasattr(module, "register"):
-            module.register()
-
-def unregister():
-    for cls in reversed(ordered_classes):
-        bpy.utils.unregister_class(cls)
-
-    for cls in reversed(fifo_cls):
-        if cls not in ordered_classes:
-            bpy.utils.unregister_class(cls)
-
-    for module in modules:
-        if module.__name__ == __name__:
-            continue
-        if hasattr(module, "unregister"):
-            module.unregister()
-
-
-# Import modules
-#################################################
-
-def get_all_submodules(directory):
-    return list(iter_submodules(directory, directory.name))
-
-def iter_submodules(path, package_name):
-    global ignored
-    for name in sorted(iter_submodule_names(path)):
-        if name in ignored:#("addon_updater", "addon_updater_ops"):
-            continue
-        yield importlib.import_module("." + name, package_name)
-
-def iter_submodule_names(path, root=""):
-    for _, module_name, is_package in pkgutil.iter_modules([str(path)]):
-        if is_package:
-            sub_path = path / module_name
-            sub_root = root + module_name + "."
-            yield from iter_submodule_names(sub_path, sub_root)
-            yield root + module_name
-        else:
-            yield root + module_name
-
-
-# Find classes to register
-#################################################
-
-def get_ordered_classes_to_register(modules):
-    return toposort(get_register_deps_dict(modules))
-
-def get_register_deps_dict(modules):
-    deps_dict = {}
-    classes_to_register = set(iter_classes_to_register(modules))
-    for cls in classes_to_register:
-        deps_dict[cls] = set(iter_own_register_deps(cls, classes_to_register))
-    return deps_dict
-
-def iter_own_register_deps(cls, own_classes):
-    yield from (dep for dep in iter_register_deps(cls) if dep in own_classes)
-
-def iter_register_deps(cls):
-    for value in typing.get_type_hints(cls, {}, {}).values():
-        dependency = get_dependency_from_annotation(value)
-        if dependency is not None:
-            yield dependency
-
-def get_dependency_from_annotation(value):
-    if isinstance(value, tuple) and len(value) == 2:
-        if value[0] in (bpy.props.PointerProperty, bpy.props.CollectionProperty):
-            return value[1]["type"]
-    return None
-
-def iter_classes_to_register(modules):
-    base_types = get_register_base_types()
-    for cls in get_classes_in_modules(modules):
-        if any(base in base_types for base in cls.__bases__):
-            if not getattr(cls, "is_registered", False):
-                yield cls
-
-def get_classes_in_modules(modules):
-    classes = set()
-    for module in modules:
-        for cls in iter_classes_in_module(module):
-            classes.add(cls)
-    return classes
-
-def iter_classes_in_module(module):
-    for value in module.__dict__.values():
-        if inspect.isclass(value):
-            yield value
-
-def get_register_base_types():
-    return set(getattr(bpy.types, name) for name in [
-        "Panel", "Operator", "PropertyGroup",
-        "AddonPreferences", "Header", "Menu",
-        "Node", "NodeSocket", "NodeTree",
-        "UIList", "RenderEngine", "KeyingSetInfo"
-    ])
-
-
-# Find order to register to solve dependencies
-#################################################
-
-def toposort(deps_dict):
-    sorted_list = []
-    sorted_values = set()
-    while len(deps_dict) > 0:
-        unsorted = []
-        for value, deps in deps_dict.items():
-            if len(deps) == 0:
-                sorted_list.append(value)
-                sorted_values.add(value)
-            else:
-                unsorted.append(value)
-        deps_dict = {value : deps_dict[value] - sorted_values for value in unsorted}
-    return sorted_list
-
-
-# Force register classes at FIFO order (decorator).
-#################################################
-# Use for ordering in nesting cases
-fifo_cls = []
-def force_register(cls):
-    global fifo_cls
-    fifo_cls.append(cls)
-    return cls
-
-def make_annotations(cls):
-    """Converts class fields to annotations if running with Blender 2.8"""
-    if bpy.app.version < (2, 80):
-        return cls
-    bl_props = {k: v for k, v in cls.__dict__.items() if isinstance(v, tuple)}
-    if bl_props:
-        if '__annotations__' not in cls.__dict__:
-            setattr(cls, '__annotations__', {})
-        annotations = cls.__dict__['__annotations__']
-        for k, v in bl_props.items():
-            annotations[k] = v
-            delattr(cls, k)
-    return cls
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/common.py b/skrypt/leomoon_lightstudio/common.py
deleted file mode 100644
index 67c38d9..0000000
--- a/skrypt/leomoon_lightstudio/common.py
+++ /dev/null
@@ -1,124 +0,0 @@
-import bpy
-
-def replace_link(object, collection_name):
-    if isinstance(object, bpy.types.Collection):
-        bpy.context.scene.collection.children.unlink(bpy.context.scene.collection.children[object.name])
-        bpy.data.collections[collection_name].children.link(object)
-    else:
-        object.users_collection[0].objects.unlink(object)
-        bpy.data.collections[collection_name].objects.link(object)
-
-def get_collection(object):
-    return [c for c in object.users_collection if c.name.startswith('BLS')][0]
-
-def get_bls_collection(context):
-    return [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-
-def blscol_profilecol_profile_handle(context):
-    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
-    profile = [ob for ob in profile_collection.objects if ob.name.startswith('BLS_PROFILE')][0]
-    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
-    return bls_collection, profile_collection, profile, handle
-
-def blscol_profilecol(context):
-    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
-    return bls_collection, profile_collection
-
-def find_view_layer(collection, layer_collection):
-    idx = layer_collection.children.find(collection.name)
-    if idx >= 0:
-        return layer_collection.children[idx]
-    else:
-        for vc in layer_collection.children:
-            rcol = find_view_layer(collection, layer_collection=vc)
-            if rcol:
-                return rcol
-            
-def get_view_layers(layer_collection):
-    for lc in layer_collection.children:
-        yield lc
-        for clc in get_view_layers(layer_collection=lc):
-            yield clc
-            
-def isFamily(ob=None):
-    if not ob:
-        ob = bpy.context.scene.objects.active
-
-    if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
-    if not ob.name.startswith('BLS_'): return False
-    while ob.parent:
-        ob = ob.parent
-        if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
-    
-    return False
-
-def family(object):
-    ''' Object + Grand children without ancestors '''
-    family = [object.children[:]+(object,)]
-      
-    def rec(object, family):
-        family[0] += object.children
-        for ob in object.children:
-            rec(ob, family)
-        
-    for ob in object.children:
-        rec(ob, family)
-        
-    return family.pop()
-
-def findLightGrp(ob):
-    while ob and ob.parent:
-        ob = ob.parent
-        if ob.name.startswith('BLS_LIGHT.'): return ob
-    return None
-
-def getLightMesh():
-    #obs = bpy.context.scene.objects
-    #lightGrp = obs.active
-    #light_no = lightGrp.name.split('.')[1]
-    #return obs[obs.find('BLS_LIGHT_MESH.'+light_no)]
-
-    lg = findLightGrp(bpy.context.active_object)
-    lm = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH")]
-    return lm[0] if len(lm) else None
-
-def getLightController():
-    obs = bpy.context.view_layer.objects
-    lightGrp = obs.active
-    light_no = lightGrp.name.split('.')[1]
-    return obs[obs.find('BLS_CONTROLLER.'+light_no)]
-
-
-def findLightProfile(ob):
-    if ob.name.startswith('BLS_PROFILE'):
-        return ob
-    
-    while ob.parent:
-        ob = ob.parent
-        if ob.name.startswith('BLS_PROFILE'): return ob
-        
-    return None
-
-def getLightHandle(ob=None):
-    if not ob:
-        ob = bpy.context.scene.objects.active
-
-    p = findLightProfile(ob)
-    if not p:
-        return None
-    
-    h = [h for h in p.children if h.name.startswith('BLS_HANDLE')]
-    if len(h):
-        return h[0]
-    else:
-        return None
-
-def refreshMaterials():
-    #controllers = [ob for ob in family(findLightGrp(context.active_object).parent) if ob.name.startswith('BLS_CONTROLLER.')]
-    controllers = (ob for ob in bpy.context.scene.objects if ob.name.startswith('BLS_CONTROLLER.') and isFamily(ob))
-    for cntrl in controllers:
-        mat = [m for m in cntrl.data.materials if m.name.startswith('BLS_icon_ctrl')][0]
-        mixNode = mat.node_tree.nodes['Mix Shader'].inputs['Fac']
-        mixNode.default_value = mixNode.default_value
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/deleteOperator.py b/skrypt/leomoon_lightstudio/deleteOperator.py
deleted file mode 100644
index f525d96..0000000
--- a/skrypt/leomoon_lightstudio/deleteOperator.py
+++ /dev/null
@@ -1,63 +0,0 @@
-import bpy
-from bpy.props import BoolProperty
-from . common import findLightGrp
-
-class DeleteOperator(bpy.types.Operator):
-    """ Custom delete """
-    bl_idname = "object.delete_custom" 
-    bl_label = "Custom Delete"
-    bl_options = {'REGISTER', 'UNDO'}
-
-    use_global: BoolProperty(default = False)
-
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
-    
-    def execute(self, context):
-        protected_groups = [findLightGrp(ob) for ob in context.selected_objects if ob.protected]
-        protected_objects = (ob for ob in context.selected_objects if ob.protected)
-        
-        for obj in protected_objects:
-            context.view_layer.objects.active = obj
-            if hasattr(obj, 'use_fake_user'):
-                obj.use_fake_user = False
-            ret = bpy.ops.scene.delete_blender_studio_light()
-            if 'CANCELLED' in ret:
-                self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
-        
-        bpy.ops.object.delete(use_global=self.use_global)
-
-        return {'FINISHED'}
-
-    # def invoke(self, context, event):
-    #     wm = context.window_manager
-    #     return wm.invoke_confirm(self, event)
-        
-addon_keymaps = []
-def add_shortkeys():       
-    wm = bpy.context.window_manager
-    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
-    addon_kmi.properties.use_global = False
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
-    addon_kmi.shift = True
-    addon_kmi.properties.use_global = True
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
-    addon_kmi.properties.use_global = False
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
-    addon_kmi.shift = True
-    addon_kmi.properties.use_global = True
-    
-    addon_keymaps.append(addon_km)
-
-def remove_shortkeys():
-    wm = bpy.context.window_manager
-    for km in addon_keymaps:
-        wm.keyconfigs.addon.keymaps.remove(km)
-        
-    addon_keymaps.clear()
diff --git a/skrypt/leomoon_lightstudio/extensions_framework/util.py b/skrypt/leomoon_lightstudio/extensions_framework/util.py
deleted file mode 100644
index 2ad450b..0000000
--- a/skrypt/leomoon_lightstudio/extensions_framework/util.py
+++ /dev/null
@@ -1,270 +0,0 @@
-# -*- coding: utf-8 -*-
-#
-# ***** BEGIN GPL LICENSE BLOCK *****
-#
-# --------------------------------------------------------------------------
-# Blender 2.5 Extensions Framework
-# --------------------------------------------------------------------------
-#
-# Authors:
-# Doug Hammond
-#
-# This program is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License
-# as published by the Free Software Foundation; either version 2
-# of the License, or (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-#
-# ***** END GPL LICENCE BLOCK *****
-#
-import configparser
-import datetime
-import os
-import tempfile
-import threading
-
-import bpy
-
-"""List of possibly appropriate paths to load/save addon config from/to"""
-config_paths = []
-if bpy.utils.user_resource('CONFIG', '') != "": config_paths.append(bpy.utils.user_resource('CONFIG', '', create=True))
-if bpy.utils.user_resource('SCRIPTS', '') != "": config_paths.append(bpy.utils.user_resource('SCRIPTS', '', create=True))
-# want to scan other script paths in reverse order, since the user path comes last
-sp = [p for p in bpy.utils.script_paths() if p != '']
-sp.reverse()
-config_paths.extend(sp)
-
-"""This path is set at the start of export, so that calls to
-path_relative_to_export() can make all exported paths relative to
-this one.
-"""
-export_path = '';
-
-def path_relative_to_export(p):
-    """Return a path that is relative to the export path"""
-    global export_path
-    p = filesystem_path(p)
-    ep = os.path.dirname(export_path)
-
-    if os.sys.platform[:3] == "win":
-        # Prevent an error whereby python thinks C: and c: are different drives
-        if p[1] == ':': p = p[0].lower() + p[1:]
-        if ep[1] == ':': ep = ep[0].lower() + ep[1:]
-
-    try:
-        relp = os.path.relpath(p, ep)
-    except ValueError: # path on different drive on windows
-        relp = p
-
-    return relp.replace('\\', '/')
-
-def filesystem_path(p):
-    """Resolve a relative Blender path to a real filesystem path"""
-    if p.startswith('//'):
-        pout = bpy.path.abspath(p)
-    else:
-        pout = os.path.realpath(p)
-
-    return pout.replace('\\', '/')
-
-# TODO: - somehow specify TYPES to get/set from config
-
-def find_config_value(module, section, key, default):
-    """Attempt to find the configuration value specified by string key
-    in the specified section of module's configuration file. If it is
-    not found, return default.
-
-    """
-    global config_paths
-    fc = []
-    for p in config_paths:
-        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
-            fc.append( '/'.join([p, '%s.cfg' % module]))
-
-    if len(fc) < 1:
-        print('Cannot find %s config file path' % module)
-        return default
-
-    cp = configparser.SafeConfigParser()
-
-    cfg_files = cp.read(fc)
-    if len(cfg_files) > 0:
-        try:
-            val = cp.get(section, key)
-            if val == 'true':
-                return True
-            elif val == 'false':
-                return False
-            else:
-                return val
-        except:
-            return default
-    else:
-        return default
-
-def write_config_value(module, section, key, value):
-    """Attempt to write the configuration value specified by string key
-    in the specified section of module's configuration file.
-
-    """
-    global config_paths
-    fc = []
-    for p in config_paths:
-        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
-            fc.append( '/'.join([p, '%s.cfg' % module]))
-
-    if len(fc) < 1:
-        raise Exception('Cannot find a writable path to store %s config file' %
-            module)
-
-    cp = configparser.SafeConfigParser()
-
-    cfg_files = cp.read(fc)
-
-    if not cp.has_section(section):
-        cp.add_section(section)
-
-    if value == True:
-        cp.set(section, key, 'true')
-    elif value == False:
-        cp.set(section, key, 'false')
-    else:
-        cp.set(section, key, value)
-
-    if len(cfg_files) < 1:
-        cfg_files = fc
-
-    fh=open(cfg_files[0],'w')
-    cp.write(fh)
-    fh.close()
-
-    return True
-
-def scene_filename():
-    """Construct a safe scene filename, using 'untitled' instead of ''"""
-    filename = os.path.splitext(os.path.basename(bpy.data.filepath))[0]
-    if filename == '':
-        filename = 'untitled'
-    return bpy.path.clean_name(filename)
-
-def temp_directory():
-    """Return the system temp directory"""
-    return tempfile.gettempdir()
-
-def temp_file(ext='tmp'):
-    """Get a temporary filename with the given extension. This function
-    will actually attempt to create the file."""
-    tf, fn = tempfile.mkstemp(suffix='.%s'%ext)
-    os.close(tf)
-    return fn
-
-class TimerThread(threading.Thread):
-    """Periodically call self.kick(). The period of time in seconds
-    between calling is given by self.KICK_PERIOD, and the first call
-    may be delayed by setting self.STARTUP_DELAY, also in seconds.
-    self.kick() will continue to be called at regular intervals until
-    self.stop() is called. Since this is a thread, calling self.join()
-    may be wise after calling self.stop() if self.kick() is performing
-    a task necessary for the continuation of the program.
-    The object that creates this TimerThread may pass into it data
-    needed during self.kick() as a dict LocalStorage in __init__().
-
-    """
-    STARTUP_DELAY = 0
-    KICK_PERIOD = 8
-
-    active = True
-    timer = None
-
-    LocalStorage = None
-
-    def __init__(self, LocalStorage=dict()):
-        threading.Thread.__init__(self)
-        self.LocalStorage = LocalStorage
-
-    def set_kick_period(self, period):
-        """Adjust the KICK_PERIOD between __init__() and start()"""
-        self.KICK_PERIOD = period + self.STARTUP_DELAY
-
-    def stop(self):
-        """Stop this timer. This method does not join()"""
-        self.active = False
-        if self.timer is not None:
-            self.timer.cancel()
-
-    def run(self):
-        """Timed Thread loop"""
-        while self.active:
-            self.timer = threading.Timer(self.KICK_PERIOD, self.kick_caller)
-            self.timer.start()
-            if self.timer.isAlive(): self.timer.join()
-
-    def kick_caller(self):
-        """Intermediary between the kick-wait-loop and kick to allow
-        adjustment of the first KICK_PERIOD by STARTUP_DELAY
-
-        """
-        if self.STARTUP_DELAY > 0:
-            self.KICK_PERIOD -= self.STARTUP_DELAY
-            self.STARTUP_DELAY = 0
-
-        self.kick()
-
-    def kick(self):
-        """Sub-classes do their work here"""
-        pass
-
-def format_elapsed_time(t):
-    """Format a duration in seconds as an HH:MM:SS format time"""
-
-    td = datetime.timedelta(seconds=t)
-    min = td.days*1440  + td.seconds/60.0
-    hrs = td.days*24    + td.seconds/3600.0
-
-    return '%i:%02i:%02i' % (hrs, min%60, td.seconds%60)
-
-def getSequenceTexturePath(it, f):
-    import bpy.path
-    import os.path
-    import string
-    fd = it.image_user.frame_duration
-    fs = it.image_user.frame_start
-    fo = it.image_user.frame_offset
-    cyclic = it.image_user.use_cyclic
-    ext = os.path.splitext(it.image.filepath)[-1]
-    fb = bpy.path.display_name_from_filepath(it.image.filepath)
-    dn = os.path.dirname(it.image.filepath)
-    rf = fb[::-1]
-    nl = 0
-    for i in range (len(fb)):
-        if rf[i] in string.digits:
-            nl += 1
-        else:
-            break
-    head = fb[:len(fb)-nl]
-    fnum = f
-    if fs != 1:
-        if f != fs:
-            fnum -= (fs-1)
-        elif f == fs:
-            fnum = 1
-    if fnum <= 0:
-        if cyclic:
-            fnum = fd - abs(fnum) % fd
-        else:
-            fnum = 1
-    elif fnum > fd:
-        if cyclic:
-            fnum = fnum % fd
-        else:
-            fnum = fd
-    fnum += fo
-    return dn + "/" + head + str(fnum).rjust(nl, "0") + ext
diff --git a/skrypt/leomoon_lightstudio/gui.py b/skrypt/leomoon_lightstudio/gui.py
deleted file mode 100644
index 9d30015..0000000
--- a/skrypt/leomoon_lightstudio/gui.py
+++ /dev/null
@@ -1,172 +0,0 @@
-import bpy
-import os
-from . common import getLightMesh
-from . auto_load import force_register
-
-@force_register
-class BLS_PT_Studio(bpy.types.Panel):
-    bl_idname = "BLS_PT_studio"
-    bl_label = "Studio"
-    bl_space_type = "VIEW_3D"
-    bl_region_type = "UI"
-    bl_category = "Light Studio"
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'    
-    
-    def draw(self, context):
-        layout = self.layout
-        col = layout.column(align=True)
-        if not context.scene.BLStudio.initialized: col.operator('scene.create_blender_light_studio')
-        if context.scene.BLStudio.initialized: col.operator('scene.delete_blender_light_studio')
-        col.separator()
-        col.operator('light_studio.control_panel', icon='MENU_PANEL')
-
-@force_register
-class BLS_PT_Lights(bpy.types.Panel):
-    bl_idname = "BLS_PT_lights"
-    bl_label = "Lights"
-    bl_space_type = "VIEW_3D"
-    bl_region_type = "UI"
-    bl_category = "Light Studio"
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.BLStudio.profile_list)
-    
-    def draw(self, context):
-        layout = self.layout
-        col = layout.column(align=True)
-        row = col.row(align=True)
-        row.operator('scene.add_blender_studio_light', text='Add Light')
-        row.operator('scene.delete_blender_studio_light', text='Delete Light')
-
-@force_register
-class BLS_PT_Selected(bpy.types.Panel):
-    bl_idname = "BLS_PT_selected"
-    bl_label = "Selected Light"
-    bl_space_type = "VIEW_3D"
-    bl_region_type = "UI"
-    bl_category = "Light Studio"
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
-    
-    def draw(self, context):
-        if context.active_object and (context.active_object.name.startswith('BLS_CONTROLLER') or context.active_object.name.startswith('BLS_LIGHT_MESH')):
-            layout = self.layout
-            wm = context.window_manager
-            
-            col = layout.column(align=True)
-            col.operator('bls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
-            
-            box = layout.box()
-            col = box.column()
-            col.template_icon_view(wm, "bls_tex_previews", show_labels=True)
-            col.label(text=os.path.splitext(wm.bls_tex_previews)[0])
-            
-            layout.separator()
-            try:
-                bls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
-                for input in bls_inputs[2:]:
-                    if input.type == "RGBA":
-                        layout.prop(input, 'default_value', text=input.name)
-                        col = layout.column(align=True)
-                    else:
-                        col.prop(input, 'default_value', text=input.name)
-            except:
-                col.label(text="BLS_light material is not valid.")
-                #import traceback
-                #traceback.print_exc()
-            col.prop(getLightMesh(), 'location', index=0) #light radius
-
-@force_register
-class BLS_PT_ProfileList(bpy.types.Panel):
-    bl_idname = "BLS_PT_profile_list"
-    bl_label = "Profiles"
-    bl_space_type = "VIEW_3D"
-    bl_region_type = "UI"
-    bl_category = "Light Studio"
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-            
-    def draw(self, context):
-        layout = self.layout
-        scene = context.scene
-        
-        props = scene.BLStudio
-        
-        row = layout.row()
-        col = row.column()
-        col.template_list("BLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
-        
-        col = row.column(align=True)
-        col.operator('bls_list.new_profile', icon='PLUS', text="")
-        col.operator('bls_list.delete_profile', icon='TRASH', text="")
-        col.operator('bls_list.copy_profile_menu', icon='DUPLICATE', text="")
-        
-        col.separator()
-        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
-        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
-
-@force_register
-class BLS_PT_ProfileImportExport(bpy.types.Panel):
-    bl_idname = "BLS_PT_profile_import_export"
-    bl_label = "Import/Export"
-    bl_space_type = "VIEW_3D"
-    bl_region_type = "UI"
-    bl_category = "Light Studio"
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-            
-    def draw(self, context):
-        layout = self.layout
-        scene = context.scene
-              
-        col = layout.column(align=True)
-        col.operator('bls_list.export_profiles', text="Export Selected Profile")
-        col.operator('bls_list.export_profiles', text="Export All Profiles").all=True
-        col.operator('bls_list.import_profiles')
-
-from . import bl_info
-@force_register
-class BLS_PT_Misc(bpy.types.Panel):
-    bl_idname = "BLS_PT_misc"
-    bl_label = "Misc"
-    bl_space_type = "VIEW_3D"
-    bl_region_type = "UI"
-    bl_category = "Light Studio"
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.BLStudio.initialized
-                
-    def draw(self, context):
-        layout = self.layout
-        scene = context.scene
-        
-        props = scene.BLStudio
-              
-        col = layout.column(align=True)
-        col.operator('bls.find_missing_textures')
-        col.operator('bls.bls_keyingset')
-        if context.scene.keying_sets.active and context.scene.keying_sets.active.bl_idname == "BUILTIN_KSI_LightStudio":
-            box = col.box()
-            box.label(text="Keying Set is active")
-
-class BLSKeyingSet(bpy.types.Operator):
-    """Activate Light Studio Keying Set to animate lights"""
-    bl_idname = "bls.bls_keyingset"
-    bl_description = "Activate Light Studio Keying Set to animate lights"
-    bl_label = "Light Studio Keying Set"
-    bl_options = {"INTERNAL", "UNDO"}
-
-    def execute(self, context):
-        context.scene.keying_sets.active = [k for k in context.scene.keying_sets_all if k.bl_idname == "BUILTIN_KSI_LightStudio"][0]
-        return {"FINISHED"}
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_brush.py b/skrypt/leomoon_lightstudio/light_brush.py
deleted file mode 100644
index c30180a..0000000
--- a/skrypt/leomoon_lightstudio/light_brush.py
+++ /dev/null
@@ -1,168 +0,0 @@
-import bpy
-from bpy_extras import view3d_utils
-from math import *
-from mathutils.geometry import intersect_line_sphere
-from mathutils import Vector
-from bpy.props import *
-from . common import isFamily, family, findLightGrp, getLightMesh, getLightController
-
-
-           
-def raycast(context, event, diff):
-    """Run this function on left mouse, execute the ray cast"""
-    # get the context arguments
-    scene = context.scene
-    region = context.region
-    rv3d = context.region_data
-    coord = event.mouse_region_x, event.mouse_region_y
-
-    # get the ray from the viewport and mouse
-    view_vector = view3d_utils.region_2d_to_vector_3d(region, rv3d, coord)
-    ray_origin = view3d_utils.region_2d_to_origin_3d(region, rv3d, coord)
-    
-    ray_target = ray_origin + view_vector
-    
-    def visible_objects_and_duplis():
-        """Loop over (object, matrix) pairs (mesh only)"""
-
-        for obj in context.visible_objects:
-            if isFamily(obj):
-                continue
-            
-            if obj.type == 'MESH':
-                yield (obj, obj.matrix_world.copy())
-
-            if obj.instance_type != 'NONE':
-                depsgraph = context.depsgraph
-                for dup in depsgraph.object_instances:
-                    obj_dupli = dup.object
-                    if obj_dupli.type == 'MESH':
-                        yield (obj_dupli, dup.matrix_world.copy())
-
-    def obj_ray_cast(obj, matrix):
-        """Wrapper for ray casting that moves the ray into object space"""
-
-        # get the ray relative to the object
-        matrix_inv = matrix.inverted()
-        ray_origin_obj = matrix_inv @ ray_origin
-        ray_target_obj = matrix_inv @ ray_target
-        ray_direction_obj = ray_target_obj - ray_origin_obj
-
-        # cast the ray
-        success, location, normal, face_index = obj.ray_cast(ray_origin_obj, ray_direction_obj)
-
-        if success:
-            return location, normal, face_index
-        else:
-            return None, None, None
-    
-    # cast rays and find the closest object
-    best_length_squared = -1.0
-    best_obj = None
-    normal = None
-    location = None
-
-    for obj, matrix in visible_objects_and_duplis():
-        if obj.type == 'MESH':
-            hit, hit_normal, face_index = obj_ray_cast(obj, matrix)
-            if hit is not None:
-                hit_world = matrix @ hit
-                length_squared = (hit_world - ray_origin).length_squared
-                if best_obj is None or length_squared < best_length_squared:
-                    best_length_squared = length_squared
-                    best_obj = obj
-                    normal = hit_normal # local space
-                    location = hit_world
-                    
-
-    if best_obj is None:
-        return {'RUNNING_MODAL'}
-    
-    # convert normal from local space to global
-    matrix = best_obj.matrix_world
-    matrix_new = matrix.to_3x3().inverted().transposed()
-    normal = matrix_new @ normal
-    normal.normalize()
-    
-    #####
-    profile = findLightGrp(context.active_object).parent
-    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
-    lightmesh = getLightMesh()
-    actuator = lightmesh.parent
-    position = intersect_line_sphere(
-        location - handle.location,
-        (normal if diff else view_vector.reflect(normal)) + location - handle.location,
-        Vector((0,0,0)),
-        lightmesh.location.x,
-        False,
-        )[0]
-    
-    
-    if not position:
-        return {'RUNNING_MODAL'}
-   
-    # ctrl x
-    x,y,z = position
-    actuator.rotation_euler.x = atan2(x, -y)
-    
-    # ctrl y
-    deg = copysign(degrees(Vector.angle(Vector((x,y,z)), Vector((x,y,0)))), z)
-    actuator.rotation_euler.y = copysign(Vector.angle(Vector((x,y,z)), Vector((x,y,0))), z)
-
-class BLSLightBrush(bpy.types.Operator):
-    """Click on object to position light and reflection"""
-    bl_idname = "bls.light_brush"
-    bl_label = "Light Brush"
-    bl_options = {"UNDO"}
-    
-    aux: BoolProperty(default=False) # is aux operator working
-    diffuse_type: BoolProperty(default=False)
-    
-    @classmethod
-    def poll(cls, context):
-        light = context.active_object
-        return context.area.type == 'VIEW_3D' and \
-               context.mode == 'OBJECT' and \
-               context.scene.BLStudio.initialized and \
-               light and \
-               isFamily(light) and \
-               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
-
-    def modal(self, context, event):
-        print(event.type, event.value)
-        if self.aux:
-            if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
-                self.aux = False
-            return {'RUNNING_MODAL'}
-        
-        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.diffuse_type else '[Reflection] | Normal'}")
-        
-        if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'Z', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
-            # allow navigation
-            return {'PASS_THROUGH'}
-        elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
-            context.area.header_text_set(text=None)
-            return {'FINISHED'}
-        elif event.type == 'LEFTMOUSE':
-            if event.value == 'PRESS':
-                raycast(context, event, self.diffuse_type)
-                return {'RUNNING_MODAL'}
-            elif event.value == 'RELEASE':
-                return {'PASS_THROUGH'}
-        elif event.type == 'MOUSEMOVE':
-            if event.value == 'PRESS':
-                raycast(context, event, self.diffuse_type)
-                return {'PASS_THROUGH'}
-        elif event.type == 'N' and event.value == 'PRESS':
-            self.diffuse_type = not self.diffuse_type
-
-        #return {'PASS_THROUGH'}
-        return {'RUNNING_MODAL'}
-
-    def invoke(self, context, event):
-        if context.space_data.type == 'VIEW_3D':
-            context.window_manager.modal_handler_add(self)
-            return {'RUNNING_MODAL'}
-        else:
-            self.report({'WARNING'}, "Active space must be a View3d")
-            return {'CANCELLED'}
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_operators.py b/skrypt/leomoon_lightstudio/light_operators.py
deleted file mode 100644
index 746c383..0000000
--- a/skrypt/leomoon_lightstudio/light_operators.py
+++ /dev/null
@@ -1,208 +0,0 @@
-import bpy
-from bpy.props import BoolProperty, PointerProperty, FloatProperty, CollectionProperty, IntProperty, StringProperty
-from . light_profiles import ListItem, update_list_index
-from . common import *
-import os
-from . import operators
-
-_ = os.sep
-
-from . extensions_framework import util as efutil
-from . import bl_info
-    
-class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
-    initialized: BoolProperty(default = False)    
-    
-    ''' Profile List '''
-    profile_list: CollectionProperty(type = ListItem)
-    list_index: IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
-    last_empty: StringProperty(name="Name of last Empty holding profile", default="")
-    
-
-class CreateBlenderLightStudio(bpy.types.Operator):
-    bl_idname = "scene.create_blender_light_studio"
-    bl_label = "Create Light Studio"
-    bl_description = "Append Blender Light Studio to current scene"
-    bl_options = {"REGISTER"}
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and not context.scene.BLStudio.initialized
-    
-    def execute(self, context):
-        script_file = os.path.realpath(__file__)
-        dir = os.path.dirname(script_file)
-
-        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Collection'+_,
-        directory=os.path.join(dir,"BLS3.blend"+_+"Collection"+_),
-        filename="BLS",
-        active_collection=False)
-
-        bpy.ops.bls_list.new_profile()
-        
-        context.scene.BLStudio.initialized = True
-
-        bpy.context.scene.render.engine = 'CYCLES'
-
-        # add the first light
-        # bpy.ops.object.select_all(action='DESELECT')
-        # bpy.ops.scene.add_blender_studio_light()
-        
-        return {"FINISHED"}
-  
-class DeleteBlenderLightStudio(bpy.types.Operator):
-    bl_idname = "scene.delete_blender_light_studio"
-    bl_label = "Delete Studio"
-    bl_description = "Delete Blender Light Studio from current scene"
-    bl_options = {"REGISTER"}
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-    
-    def execute(self, context):
-        scene = context.scene
-        scene.BLStudio.initialized = False
-
-        # close control panel
-        from . operators.modal import close_control_panel
-        close_control_panel()
-        
-        ''' for each profile from this scene: delete objects then remove from list '''
-        while len(context.scene.BLStudio.profile_list):
-            bpy.ops.bls_list.delete_profile()
-            
-        obsToRemove = [ob for ob in scene.objects if isFamily(ob)]
-        for ob in obsToRemove:
-            for c in ob.users_collection:
-                c.objects.unlink(ob)
-            ob.user_clear()
-            ob.use_fake_user = False
-            bpy.data.objects.remove(ob)
-            
-        context.scene.collection.children.unlink(get_bls_collection(context))
-        
-        return {"FINISHED"}
-     
-    def invoke(self, context, event):
-        wm = context.window_manager
-        return wm.invoke_props_dialog(self)
-    
-    def draw(self, context):
-        layout = self.layout
-        col = layout.column(align=True)
-        col.label(text="Deleting Studio is irreversible!")
-        col.label(text="Your lighting setup will be lost.")
-
-class AddBSLight(bpy.types.Operator):
-    bl_idname = "scene.add_blender_studio_light"
-    bl_label = "Add Studio Light"
-    bl_description = "Add Light to Studio"
-    bl_options = {"REGISTER", "UNDO"}
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-    
-    def execute(self, context):
-        script_file = os.path.realpath(__file__)
-        dir = os.path.dirname(script_file)
-        
-        scene = context.scene
-        bls_collection, profile_collection, profile, handle = blscol_profilecol_profile_handle(context)
-
-        filepath = os.path.join(dir,"BLS3.blend")
-        # load a single scene we know the name of.
-        with bpy.data.libraries.load(filepath) as (data_from, data_to):
-            data_to.collections = ["BLS_Light"]
-            
-        for collection in data_to.collections:
-            if collection is not None:
-                profile_collection.children.link(collection)
-                new_objects = collection.objects
-                for ob in new_objects:
-                    ob.use_fake_user = True
-                
-                blslight = [l for l in new_objects if l.name.startswith('BLS_LIGHT')][0]
-                blslight.parent = profile 
-                
-                bpy.ops.object.select_all(action='DESELECT')
-                light = [p for p in new_objects if p.name.startswith('BLS_LIGHT_MESH')][0]
-                light.select_set(True)
-                context.view_layer.objects.active = light
-        
-        #####
-        
-        c = light.constraints.new('COPY_LOCATION')
-        c.target = handle
-        c.use_x = True
-        c.use_y = True
-        c.use_z = True
-        c.use_offset = True
-        # scene.frame_current = bpy.context.scene.frame_current # refresh hack
-        # refreshMaterials()
-        
-        operators.update()
-        return {"FINISHED"}
-    
-class DeleteBSLight(bpy.types.Operator):
-    bl_idname = "scene.delete_blender_studio_light"
-    bl_label = "Delete BLS Light"
-    bl_description = "Delete selected Light from Studio"
-    bl_options = {"REGISTER", "UNDO"}
-    
-    @classmethod
-    def poll(cls, context):
-        light = context.active_object
-        return context.area.type == 'VIEW_3D' and \
-               context.mode == 'OBJECT' and \
-               context.scene.BLStudio.initialized and \
-               light and \
-               light.name.startswith('BLS_LIGHT') and \
-               not light.name.startswith('BLS_PROFILE')
-
-    def execute(self, context):
-        scene = context.scene
-        light = context.object
-
-        for collection in light.users_collection:
-            if collection.name.startswith('BLS_Light'):
-                bpy.ops.object.delete({"selected_objects": collection.objects}, use_global=True)
-                bpy.data.collections.remove(collection)
-                
-        operators.update()
-        return {"FINISHED"}
-    
-    def invoke(self, context, event):
-        wm = context.window_manager
-        return wm.invoke_props_dialog(self)
-    
-    def draw(self, context):
-        layout = self.layout
-        col = layout.column(align=True)
-        col.label(text="OK?")
-
-class BUILTIN_KSI_LightStudio(bpy.types.KeyingSetInfo):
-    bl_label = "LightStudio KeyingSet"
-
-    # poll - test for whether Keying Set can be used at all
-    def poll(ksi, context):
-        return context.active_object or context.selected_objects and context.scene.BLStudio.initialized
-
-    # iterator - go over all relevant data, calling generate()
-    def iterator(ksi, context, ks):
-        for ob in (l for l in context.selected_objects if l.name.startswith("BLS_LIGHT")):
-            ksi.generate(context, ks, ob)
-
-    # generator - populate Keying Set with property paths to use
-    def generate(ksi, context, ks, data):
-        id_block = data.id_data
-
-        bls_collection = get_collection(id_block)
-        light_mesh = [m for m in bls_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
-        bls_actuator = light_mesh.parent
-        
-        ks.paths.add(light_mesh, "location", index=0, group_method='KEYINGSET')
-        ks.paths.add(light_mesh, "rotation_euler", index=0, group_method='KEYINGSET')
-        ks.paths.add(light_mesh, "scale", group_method='KEYINGSET')
-        ks.paths.add(bls_actuator, "rotation_euler", group_method='KEYINGSET')
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_preview_list.py b/skrypt/leomoon_lightstudio/light_preview_list.py
deleted file mode 100644
index 60bf71c..0000000
--- a/skrypt/leomoon_lightstudio/light_preview_list.py
+++ /dev/null
@@ -1,107 +0,0 @@
-import os
-from time import time
-import bpy
-from . common import getLightMesh, isFamily
-
-_ = os.sep
-script_file = os.path.realpath(__file__)
-dir = os.path.dirname(script_file)
-directory=os.path.join(dir,"textures_real_lights")
-    
-def enum_previews_from_directory_items(self, context):
-    """EnumProperty callback"""
-    enum_items = []
-
-    if context is None:
-        return enum_items
-
-    wm = context.window_manager
-    
-    script_file = os.path.realpath(__file__)
-    dir = os.path.dirname(script_file)
-    directory=os.path.join(dir,"textures_real_lights"+_)
-
-    # Get the preview collection (defined in register func).
-    pcoll = preview_collections["main"]
-    
-    dir_up = os.path.getmtime(directory)
-    if pcoll.initiated and dir_up <= pcoll.dir_update_time:
-        return pcoll.tex_previews
-    pcoll.dir_update_time = dir_up
-    
-    pcoll.clear()
-
-    print("Scanning directory: %s" % directory)
-
-    if directory and os.path.exists(directory):
-        # Scan the directory for png files
-        image_paths = []
-        for fn in os.listdir(directory):
-            if os.path.splitext(fn)[1] in (".tif", ".exr", ".hdr"):
-                image_paths.append(fn)
-
-        for i, name in enumerate(image_paths):
-            # generates a thumbnail preview for a file.
-            filepath = os.path.join(directory, name)
-            thumb = pcoll.load(filepath, filepath, 'IMAGE', True)
-            basename = os.path.splitext(name)[0]
-            enum_items.append((name, basename, name, thumb.icon_id, i))
-
-    pcoll.tex_previews = enum_items
-    pcoll.initiated = True
-    return pcoll.tex_previews
-
-
-# We can store multiple preview collections here,
-# however in this example we only store "main"
-preview_collections = {}
-
-def preview_enum_get(wm):
-    nodes = getLightMesh().active_material.node_tree.nodes
-    if not "Light Texture" in nodes:
-        return -1
-    
-    tex = nodes["Light Texture"].image.filepath
-    tex = os.path.split(tex)[1]
-    names = (p[0] for p in preview_collections["main"].tex_previews)
-    
-    for i, name in enumerate(names):
-        if name == tex:
-            return i
-    return -1
-    
-def preview_enum_set(wm, context):
-    print("Set preview = %s" % context)
-    name = preview_collections["main"].tex_previews[context][0]
-    
-    light = getLightMesh()
-    light.active_material.node_tree.nodes["Light Texture"].image = bpy.data.images.load(os.path.join(directory, name), check_existing=True)
-    
-    return None
-
-def register():
-    from bpy.types import WindowManager
-    from bpy.props import EnumProperty
-
-    WindowManager.bls_tex_previews = EnumProperty(
-            items=enum_previews_from_directory_items,
-            get=preview_enum_get,
-            set=preview_enum_set,
-            )
-    import bpy.utils.previews
-    pcoll = bpy.utils.previews.new()
-    pcoll.bls_tex_previews = ()
-    pcoll.initiated = False
-    pcoll.dir_update_time = os.path.getmtime(directory)
-
-    preview_collections["main"] = pcoll
-
-def unregister():
-    from bpy.types import WindowManager
-
-    del WindowManager.bls_tex_previews
-
-    for pcoll in preview_collections.values():
-        bpy.utils.previews.remove(pcoll)
-        pcoll.clear()
-    preview_collections.clear()
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_profiles.py b/skrypt/leomoon_lightstudio/light_profiles.py
deleted file mode 100644
index 7f25ed8..0000000
--- a/skrypt/leomoon_lightstudio/light_profiles.py
+++ /dev/null
@@ -1,634 +0,0 @@
-import bpy
-from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProperty, EnumProperty
-import os
-from . common import *
-from itertools import chain
-
-_ = os.sep
-
-class ListItem(bpy.types.PropertyGroup):
-    """ Group of properties representing an item in the list """
-    def update_name(self, context):
-        print("{} : {}".format(repr(self.name), repr(context)))
-                
-    name: StringProperty(
-            name="Profile Name",
-            default="Untitled")
-
-    empty_name: StringProperty(
-            name="Name of Empty that holds the profile",
-            description="",
-            default="")
-            
-class BLS_UL_List(bpy.types.UIList):
-    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
-        custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.BLStudio.list_index else 'LIGHT'
-
-        # Make sure your code supports all 3 layout types
-        if self.layout_type in {'DEFAULT', 'COMPACT'}:
-            layout.prop(item, 'name', text='', icon = custom_icon, emboss=False, translate=False)
-
-        elif self.layout_type in {'GRID'}:
-            layout.alignment = 'CENTER'
-            layout.label("", icon = custom_icon)
-            
-            
-class LIST_OT_NewItem(bpy.types.Operator):
-    """ Add a new profile to the list """
-
-    bl_idname = "bls_list.new_profile"
-    bl_label = "Add a new Profile"
-    bl_options = {"INTERNAL"}
-    
-    handle: BoolProperty(default=True)
-
-    def execute(self, context):
-        props = context.scene.BLStudio
-        item = props.profile_list.add()
-        bls_collection = get_bls_collection(context)
-
-        # unlink existing profiles
-        for profile in (prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)):
-            profile_collection = profile.users_collection[0]
-            bls_collection.children.unlink(profile_collection)
-        #
-
-        idx = 0
-        for id in (i.name.split('Profile ')[1] for i in props.profile_list if i.name.startswith('Profile ')):
-            try:
-                id = int(id)
-            except ValueError:
-                continue
-            
-            if id > idx: idx = id
-            
-        item.name = 'Profile '+str(idx+1)
-        
-        ''' Add Hierarchy stuff '''
-        # before
-        A = set(bpy.data.objects[:])
-        
-        script_file = os.path.realpath(__file__)
-        dir = os.path.dirname(script_file)
-        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Object'+_,
-            directory=os.path.join(dir,"BLS3.blend"+_+"Object"+_),
-            filename="BLS_PROFILE.000",
-            active_collection=True)
-        
-        # after operation
-        B = set(bpy.data.objects[:])
-
-        # whats the difference
-        profile = (A ^ B).pop()
-        
-        profile.parent = [ob for ob in context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
-        profile.use_fake_user = True
-        profile_collection = bpy.data.collections.new(profile.name)
-        profile_collection.use_fake_user = True
-        bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-        bls_collection.children.link(profile_collection)
-        replace_link(profile, profile.name)
-        
-        item.empty_name = profile.name
-        
-        handle = None
-        if self.handle:
-            bpy.ops.object.empty_add()
-            handle = context.active_object
-            handle.name = "BLS_HANDLE"
-            handle.empty_display_type = 'SPHERE'
-            handle.parent = profile
-            handle.protected = True
-            handle.use_fake_user = True
-            replace_link(handle, profile.name)
-        
-        props.last_empty = profile.name
-        props.list_index = len(props.profile_list)-1
-
-        return{'FINISHED'}
-
-class LIST_OT_DeleteItem(bpy.types.Operator):
-    """ Delete the selected profile from the list """
- 
-    bl_idname = "bls_list.delete_profile"
-    bl_label = "Deletes an profile"
-    bl_options = {"INTERNAL"}
- 
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
- 
-    def execute(self, context):
-        props = context.scene.BLStudio
-        index = props.list_index
- 
-        props.profile_list.remove(index)
-        
-        ''' Delete/Switch Hierarchy stuff '''
-        #delete objects from current profile           
-        obsToRemove = family(context.scene.objects[props.last_empty])
-        collectionsToRemove = set()
-        for ob in obsToRemove:
-            collectionsToRemove.update(ob.users_collection)
-            ob.use_fake_user = False
-        bpy.ops.object.delete({"selected_objects": obsToRemove}, use_global=True)
-        for c in collectionsToRemove:
-            if c.name.startswith('BLS_'):
-                bpy.data.collections.remove(c)
-        
-        # update index
-        if index > 0:
-            index = index - 1
-        props.list_index = index
- 
-        return{'FINISHED'}
-    
-
-class LIST_OT_CopyItem(bpy.types.Operator):
-    """ Copy an item in the list """
-
-    bl_idname = "bls_list.copy_profile"
-    bl_label = "Copy profile"
-    bl_options = {"INTERNAL"}
-
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list. """
-        return len(context.scene.BLStudio.profile_list)
-
-    def execute(self, context):
-        props = context.scene.BLStudio
-        list = props.profile_list
-        index = props.list_index
-        
-        scene = context.scene
-        
-        # all objects on all layers visible
-        oldlaysArea = context.area.spaces[0].layers[:]
-        oldlaysScene = context.scene.layers[:]
-        context.area.spaces[0].layers = [True]*20
-        context.scene.layers = [True]*20
-        
-        obsToCopy = family(context.scene.objects[props.last_empty])
-        
-        for ob in context.selected_objects: ob.select = False
-        for ob in obsToCopy:
-            if ob.name.startswith('BLS_PROFILE.'): continue
-            ob.hide_select = False
-            ob.hide = False
-            ob.select = True
-            
-            
-        # before
-        A = set(scene.objects[:])
-        
-        bpy.ops.object.duplicate()
-        
-        # after operation
-        B = set(scene.objects[:])
-
-        # whats the difference
-        new_objects = (A ^ B)
-        
-        # make light material single user and update selection drivers]
-        bpy.ops.group.objects_remove_all()
-        bpy.ops.group.create(name='BLS_Light')
-        
-        for lg in new_objects:
-            if lg.name.startswith('BLS_LIGHT_GRP.'):
-                controller = [c for c in family(lg) if c.name.startswith("BLS_CONTROLLER.")][0]
-                lmesh = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH.")][0]
-                
-                light_mat = None
-                for id, mat in enumerate(controller.data.materials):
-                    if mat.name.startswith('BLS_icon_ctrl'):
-                        mat = mat.copy()
-                        controller.data.materials[id] = mat
-                        
-                        for d in mat.animation_data.drivers:
-                            d.driver.variables[0].targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
-                        
-                        for d in mat.node_tree.animation_data.drivers:
-                            for v in d.driver.variables:
-                                v.targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
-                                
-                    elif mat.name.startswith('BLS_light'):
-                        #mat = mat.copy()
-                        light_mat = mat.copy()
-                        controller.data.materials[id] = light_mat
-                        light_mat.node_tree.nodes['Light Texture'].image = light_mat.node_tree.nodes['Light Texture'].image.copy()
-                        
-                for id, mat in enumerate(lmesh.data.materials):
-                    if mat.name.startswith('BLS_light'):
-                        lmesh.data.materials[id] = light_mat               
-                            
-        # revert visibility
-        for ob in chain(obsToCopy, new_objects):
-            ob.hide = True
-            ob.hide_select = True
-            
-            if ob.name.startswith('BLS_LIGHT_MESH.') or \
-               ob.name.startswith('BLS_HANDLE') or \
-               ob.name.startswith('BLS_CONTROLLER.'):
-                ob.hide = False
-                ob.hide_select = False
-                
-        profileName = props.profile_list[props.list_index].name
-        
-        bpy.ops.bls_list.new_profile(handle=False)
-        lastItemId = len(props.profile_list)-1
-        
-        # parent objects to new profile
-        for ob in new_objects:
-            scene.objects.unlink(ob)
-            if ob.name.startswith('BLS_LIGHT_GRP.'):
-                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
-            elif ob.name.startswith('BLS_HANDLE.'):
-                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
-                
-            
-        props.profile_list[len(props.profile_list)-1].name = profileName + ' Copy'
-        
-        
-        # place copied profile next to source profile
-        while lastItemId > props.list_index+1:
-            list.move(lastItemId-1, lastItemId)
-            lastItemId -= 1
-        
-        context.area.spaces[0].layers = oldlaysArea
-        context.scene.layers = oldlaysScene
-        
-        return{'FINISHED'}
-    
-    
- 
-class LIST_OT_MoveItem(bpy.types.Operator):
-    """ Move an item in the list """
-
-    bl_idname = "bls_list.move_profile"
-    bl_label = "Move profile in the list"
-    bl_options = {"INTERNAL"}
-
-    direction: bpy.props.EnumProperty(
-                items=(
-                    ('UP', 'Up', ""),
-                    ('DOWN', 'Down', ""),))
-
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list. """
-        return len(context.scene.BLStudio.profile_list)
-
-
-    def move_index(self, context):
-        """ Move index of an item render queue while clamping it. """
-        props = context.scene.BLStudio
-        index = props.list_index
-        list_length = len(props.profile_list) - 1 # (index starts at 0)
-        new_index = 0
-
-        if self.direction == 'UP':
-            new_index = index - 1
-        elif self.direction == 'DOWN':
-            new_index = index + 1
-
-        new_index = max(0, min(new_index, list_length))
-        props.list_index = new_index
-
-
-    def execute(self, context):
-        props = context.scene.BLStudio
-        list = props.profile_list
-        index = props.list_index
-
-        if self.direction == 'DOWN':
-            neighbor = index + 1
-            list.move(index,neighbor)
-        elif self.direction == 'UP':
-            neighbor = index - 1
-            list.move(neighbor, index)
-        else:
-            return{'CANCELLED'}
-        self.move_index(context)
-
-        return{'FINISHED'}
-
-
-def update_list_index(self, context):
-    props = context.scene.BLStudio
-    bls_collection = get_bls_collection(context)
-    
-    if len(props.profile_list) == 0: return
-        
-    selected_profile = props.profile_list[self.list_index]
-    
-    if selected_profile.empty_name == props.last_empty: return
-
-    print('Index update {}'.format(self.list_index))
-        
-    #unlink current profile
-    prof_idx = context.scene.objects.find(props.last_empty)
-    if prof_idx > -1: # in case of update after deletion
-        profile_collection = context.scene.objects[prof_idx].users_collection[0]
-        bls_collection.children.unlink(profile_collection)
-        
-    #link selected profile
-    bls_collection.children.link(bpy.data.collections[selected_profile.empty_name])
-    
-    props.last_empty = selected_profile.empty_name
-
-    from . operators.modal import update_light_sets, panel_global
-    update_light_sets(panel_global, bpy.context, always=True)
-        
-# import/export
-import json, time
-script_file = os.path.realpath(__file__)
-dir = os.path.dirname(script_file)
-
-VERSION = 2.00
-def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
-    plist = props.profile_list
-    for profile in profiles:
-        print(profile)
-        bpy.ops.bls_list.new_profile()
-        props.list_index = len(plist)-1
-        plist[-1].name = profile["name"]
-        if not internal_copy:
-            date = time.localtime()
-            plist[-1].name += ' {}-{:02}-{:02} {:02}:{:02}'.format(str(date.tm_year)[-2:], date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
-
-        profile_empty = context.scene.objects[plist[-1].empty_name]
-        
-        if version > 1:
-            handle = getLightHandle(profile_empty)    
-            handle.location.x = profile['handle_position'][0]
-            handle.location.y = profile['handle_position'][1]
-            handle.location.z = profile['handle_position'][2]
-
-        for light in profile["lights"]:
-            # before
-            A = set(profile_empty.children)
-            
-            bpy.ops.scene.add_blender_studio_light()
-            
-            # after operation
-            B = set(profile_empty.children)
-            
-            # whats the difference
-            lgrp = (A ^ B).pop()
-
-            actuator = [c for c in family(lgrp) if "BLS_ROTATION" in c.name][0]
-            lmesh = [c for c in family(lgrp) if "BLS_LIGHT_MESH" in c.name][0]
-            lmesh.location.x = light['radius']
-            
-            actuator.rotation_euler.x = light['position'][0]
-            actuator.rotation_euler.y = light['position'][1]
-            actuator.rotation_euler.z = 0
-            
-            lmesh.scale.x = light['scale'][0]
-            lmesh.scale.y = light['scale'][1]
-            lmesh.scale.z = light['scale'][2]
-            
-            lmesh.rotation_euler.x = light['rotation']
-
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['Texture Switch']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1] = light['Color Overlay'][1]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2] = light['Color Overlay'][2]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3] = light['Color Overlay'][3]
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Color Saturation']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Intensity']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Mask - Gradient Switch']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value = light['Mask - Gradient Type']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value = light['Mask - Gradient Amount']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value = light['Mask - Ring Switch']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value = light['Mask - Ring Inner Radius']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value = light['Mask - Ring Outer Radius']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value = light['Mask - Top to Bottom']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value = light['Mask - Bottom to Top']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value = light['Mask - Left to Right']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value = light['Mask - Right to Left']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value = light['Mask - Diagonal Top Left']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value = light['Mask - Diagonal Top Right']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value = light['Mask - Diagonal Bottom Right']
-            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value = light['Mask - Diagonal Bottom Left']
-
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
-            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
-            
-            if os.path.isabs(light['tex']):
-                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
-            else:
-                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
-                
-class ImportProfiles(bpy.types.Operator):
-    """ Import Profiles from File """
- 
-    bl_idname = "bls_list.import_profiles"
-    bl_label = "Import Profiles"
-    #bl_options = {"INTERNAL"}
-    
-    filepath: bpy.props.StringProperty(default="*.bls", subtype="FILE_PATH")
- 
-    @classmethod
-    def poll(self, context):
-        return True
- 
-    def execute(self, context):
-        props = context.scene.BLStudio
-        
-        with open(self.filepath, 'r') as f:
-            file = f.read()
-        f.closed
-        
-        file = json.loads(file)
-        parse_profile(context, props, file["profiles"], float(file["version"]))
- 
-        return{'FINISHED'}
-    
-    def invoke(self, context, event):
-        context.window_manager.fileselect_add(self)
-        return {'RUNNING_MODAL'}
-
-def compose_profile(list_index):
-    props = bpy.context.scene.BLStudio
-    profile_dict = {}
-    profile_dict['name'] = props.profile_list[list_index].name
-    profile_dict['lights']= []
-    profile = bpy.data.objects[props.profile_list[list_index].empty_name]
-    profile_collection = get_collection(profile)
-    handle = getLightHandle(profile)
-    profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
-    for light_collection in profile_collection.children:
-        lmesh = [ob for ob in light_collection.objects if ob.name.startswith('BLS_LIGHT_MESH')][0]
-        actuator = [ob for ob in light_collection.objects if ob.name.startswith('BLS_ROTATION')][0]
-        light = {}
-        light['radius'] = lmesh.location.x
-        light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
-        light['scale'] = [lmesh.scale.x, lmesh.scale.y, lmesh.scale.z]
-        light['rotation'] = lmesh.rotation_euler.x
-        # view_layer = find_view_layer(light_collection, bpy.context.view_layer.layer_collection)
-        # light['mute'] = view_layer.exclude
-        texpath = lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
-        light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
-        
-        light['Texture Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
-        light['Color Overlay'] = [lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0],
-                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1],
-                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2],
-                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3]]
-        light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
-        light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
-        light['Mask - Gradient Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
-        light['Mask - Gradient Type'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value
-        light['Mask - Gradient Amount'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value
-        light['Mask - Ring Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value
-        light['Mask - Ring Inner Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value
-        light['Mask - Ring Outer Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value
-        light['Mask - Top to Bottom'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value
-        light['Mask - Bottom to Top'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value
-        light['Mask - Left to Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value
-        light['Mask - Right to Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value
-        light['Mask - Diagonal Top Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value
-        light['Mask - Diagonal Top Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value
-        light['Mask - Diagonal Bottom Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value
-        light['Mask - Diagonal Bottom Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value
-
-        # light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
-        # light['Opacity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value
-        # light['Falloff'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
-        # light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
-        # light['Half'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
-        
-        profile_dict['lights'].append(light)
-        
-    return profile_dict
-        
-class ExportProfiles(bpy.types.Operator):
-    """ Export Profiles to File """
- 
-    bl_idname = "bls_list.export_profiles"
-    bl_label = "Export"
-    #bl_options = {"INTERNAL"}
-    
-    filepath: bpy.props.StringProperty(default="profile.bls", subtype="FILE_PATH")
-    all: bpy.props.BoolProperty(default=False, name="Export All Profiles")
- 
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
- 
-    def execute(self, context):
-        props = context.scene.BLStudio
-        index = props.list_index
-            
-        export_file = {}
-        date = time.localtime()
-        export_file['date'] = '{}-{:02}-{:02} {:02}:{:02}'.format(date.tm_year, date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
-        export_file['version'] = VERSION
-        profiles_to_export = export_file['profiles'] = []
-        
-        if self.all:
-            for p in range(len(props.profile_list)):
-                try:
-                    profiles_to_export.append(compose_profile(p))
-                except Exception:
-                    self.report({'WARNING'}, 'Malformed profile %s. Omitting.' % props.profile_list[p].name)
-        else:
-            try:
-                profiles_to_export.append(compose_profile(index))
-            except Exception:
-                self.report({'WARNING'}, 'Malformed profile %s. Omitting.' % props.profile_list[index].name)
-        
-        with open(self.filepath, 'w') as f:
-            f.write(json.dumps(export_file, indent=4))
-        f.closed
-        
-        return{'FINISHED'}
-    
-    def invoke(self, context, event):
-        self.filepath = "profile.bls"
-        context.window_manager.fileselect_add(self)
-        return {'RUNNING_MODAL'}
-    
-class FindMissingTextures(bpy.types.Operator):
-    """ Find Missing Textures """
- 
-    bl_idname = "bls.find_missing_textures"
-    bl_label = "Find Missing Textures"
-    #bl_options = {"INTERNAL"}
-    
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
- 
-    def execute(self, context):
-        bpy.ops.file.find_missing_files(directory=os.path.join(dir, "textures_real_lights"))        
-        bpy.context.scene.frame_current = bpy.context.scene.frame_current
-        return{'FINISHED'}
-
-class CopyProfileToScene(bpy.types.Operator):
-    """ Copy Light Profile to Scene """
- 
-    bl_idname = "bls_list.copy_profile_to_scene"
-    bl_label = "Copy Profile to Scene"
-    bl_property = "sceneprop"
-    
-    def get_scenes(self, context):
-        return ((s.name, s.name, "Scene name") for i,s in enumerate(bpy.data.scenes))#global_vars["scenes"]
-    
-    sceneprop: EnumProperty(items = get_scenes)
-    
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
- 
-    def execute(self, context):
-        props = context.scene.BLStudio
-        index = props.list_index
-        
-        profiles = [compose_profile(index),]
-        
-        context.screen.scene = bpy.data.scenes[self.sceneprop]
-        context.scene.render.engine = 'CYCLES'
-        if not context.scene.BLStudio.initialized:
-            bpy.ops.scene.create_blender_light_studio()
-        
-        parse_profile(context, context.scene.BLStudio, profiles, internal_copy=True)
-        
-        return{'FINISHED'}
-        
-    def invoke(self, context, event):
-        wm = context.window_manager
-        wm.invoke_search_popup(self)
-        return {'FINISHED'}
-    
-
-class CopyProfileMenu(bpy.types.Operator):
-    """ Copy Light Profile """
- 
-    bl_idname = "bls_list.copy_profile_menu"
-    bl_label = "Copy Profile"
-
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
-    
-    def execute(self, context):
-        wm = context.window_manager
-        def draw(self, context):
-            layout = self.layout
-            layout.operator_context='INVOKE_AREA'
-            col = layout.column(align=True)
-            col.operator('bls_list.copy_profile')
-            col.operator('bls_list.copy_profile_to_scene')
-
-        wm.popup_menu(draw, title="Copy Profile")
-        return {'FINISHED'}
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/operators/__init__.py b/skrypt/leomoon_lightstudio/operators/__init__.py
deleted file mode 100644
index e71d203..0000000
--- a/skrypt/leomoon_lightstudio/operators/__init__.py
+++ /dev/null
@@ -1,16 +0,0 @@
-# class UpdateChecker:
-#     def __init__(self):
-#         self.updated
-UPDATED = True
-
-def is_updated():
-    global UPDATED
-    return UPDATED
-
-def update():
-    global UPDATED
-    UPDATED = True
-
-def update_clear():
-    global UPDATED
-    UPDATED = False
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/operators/modal.py b/skrypt/leomoon_lightstudio/operators/modal.py
deleted file mode 100644
index 1022d6b..0000000
--- a/skrypt/leomoon_lightstudio/operators/modal.py
+++ /dev/null
@@ -1,449 +0,0 @@
-import bpy
-
-from mathutils import *
-
-from . modal_utils import *
-from . import *
-
-from .modal_utils import shader2Dcolor
-from gpu_extras.batch import batch_for_shader
-import time
-
-last_time = time.time()
-def draw(self, area):
-    if area != bpy.context.area:
-        return
-
-    shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
-    batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
-    #
-
-    self.panel.draw()
-    for b in Button.buttons:
-        b.draw(self.mouse_x, self.mouse_y)
-    for l in LightImage.lights:
-        l.draw()
-
-class BLS_OT_Rotate(bpy.types.Operator, MouseWidget):
-    bl_idname = "light_studio.rotate"
-    bl_label = "Rotate Light"
-    bl_options = {"REGISTER", "UNDO", "INTERNAL"}
-
-    def __init__(self):
-        super().__init__()
-        self.pivot = Vector((self.mouse_x, self.mouse_y))
-        self.base_object_rotation = 0
-        self.allow_precision_mode = True
-
-    def invoke(self, context, event):
-        super().invoke(context, event)
-        self.base_object_rotation = LightImage.selected_object._bls_mesh.rotation_euler.x
-        return {"RUNNING_MODAL"}
-    
-    def _finish(self, context, event):
-        context.area.header_text_set(text=None)
-
-    def _cancel(self, context, event):
-        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation
-        context.area.header_text_set(text=None)
-
-    def _modal(self, context, event):
-        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
-
-        context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
-
-        return {"PASS_THROUGH"}
-
-class BLS_OT_Scale(bpy.types.Operator, MouseWidget):
-    bl_idname = "light_studio.scale"
-    bl_label = "Scale Light"
-    bl_options = {"GRAB_CURSOR", "BLOCKING", "REGISTER", "UNDO", "INTERNAL"}
-
-    def __init__(self):
-        super().__init__()
-        self.pivot = Vector((self.mouse_x, self.mouse_y))
-        self.base_object_scale = 0
-        self.allow_xy_keys = True
-        self.allow_precision_mode = True
-
-    def invoke(self, context, event):
-        super().invoke(context, event)
-        self.base_object_scale = LightImage.selected_object._bls_mesh.scale.copy()
-        return {"RUNNING_MODAL"}
-    
-    def _cancel(self, context, event):
-        LightImage.selected_object._bls_mesh.scale = self.base_object_scale
-        context.area.header_text_set(text=None)
-
-    def _finish(self, context, event):
-        context.area.header_text_set(text=None)
-
-    def _modal(self, context, event):
-        new_scale = self.base_object_scale * self.delta_length_factor()
-        if self.x_key:
-            new_scale.z = self.base_object_scale.z
-        if self.y_key:
-            new_scale.y = self.base_object_scale.y
-
-        LightImage.selected_object._bls_mesh.scale = new_scale
-
-        context.area.header_text_set(text=f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
-
-        if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
-            return {"RUNNING_MODAL"}
-        return {"PASS_THROUGH"}
-
-GRABBING = False
-class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
-    bl_idname = "light_studio.grab"
-    bl_label = "Grab Light"
-    bl_options = {"GRAB_CURSOR", "BLOCKING", "INTERNAL"}
-
-    canvas_width: bpy.props.FloatProperty()
-    canvas_height: bpy.props.FloatProperty()
-
-    def __init__(self):
-        super().__init__()
-        self.pivot = Vector((self.mouse_x, self.mouse_y))
-        self.base_object_rotation = Vector((0, 0, 0))
-        self.allow_xy_keys = True
-        self.continous = True
-        self.draw_guide = False
-        self.allow_precision_mode = True
-
-    def invoke(self, context, event):
-        super().invoke(context, event)
-        self.base_object_rotation = LightImage.selected_object._bls_actuator.rotation_euler.copy()
-        return {"RUNNING_MODAL"}
-    
-    def _cancel(self, context, event):
-        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation
-        global GRABBING
-        GRABBING = False
-        context.area.header_text_set(text=None)
-
-    def _finish(self, context, event):
-        global GRABBING
-        GRABBING = False
-        context.area.header_text_set(text=None)
-
-    def _modal(self, context, event):
-        dv = self.delta_vector()
-        if self.x_key:
-            dv.y = 0
-        if self.y_key:
-            dv.x = 0
-
-        x_factor = 2*pi / self.canvas_width
-        y_factor = pi / self.canvas_height
-
-        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation.copy()
-        LightImage.selected_object._bls_actuator.rotation_euler.x += dv.x * x_factor
-        LightImage.selected_object._bls_actuator.rotation_euler.y += dv.y * y_factor
-        LightImage.selected_object._bls_actuator.rotation_euler.y = clamp(-pi/2 + 0.000001, LightImage.selected_object._bls_actuator.rotation_euler.y, pi/2 - 0.000001)
-
-        context.area.header_text_set(text=f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
-
-        if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
-            return {"RUNNING_MODAL"}
-        return {"PASS_THROUGH"}
-
-panel_global = None
-running_modals = 0
-class BLS_OT_control_panel(bpy.types.Operator):
-    bl_idname = "light_studio.control_panel"
-    bl_label = "Light Studio Control Panel"
-
-    mouse_x: bpy.props.IntProperty()
-    mouse_y: bpy.props.IntProperty()
-
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-
-    def __init__(self):
-        self.textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale | [Ctrl+Click] Loop overlapping"
-        self.handler = None
-        self.panel = None
-        self.panel_moving = False
-        self.clicked_object = None
-        self.profile_collection = None
-        self.click_manager = ClickManager()
-        self.active_feature = None
-        self.precision_mode = False
-
-    def __del__(self):
-        self._unregister_handler()
-
-    def _unregister_handler(self):
-        global running_modals
-        running_modals = max(0, running_modals-1)
-        try:
-            bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
-        except (ValueError, AttributeError):
-            pass
-
-    def _mouse_event(self, context, event):
-        area_mouse_x = event.mouse_x - context.area.x
-        area_mouse_y = event.mouse_y - context.area.y
-        dx = area_mouse_x - self.mouse_x
-        dy = area_mouse_y - self.mouse_y
-        self.mouse_x = area_mouse_x
-        self.mouse_y = area_mouse_y
-        return dx, dy, area_mouse_x, area_mouse_y
-
-    def invoke(self, context, event):
-        global running_modals
-        running_modals += 1
-        if running_modals > 1:
-            # toggle panel
-            running_modals = 0
-            return {"CANCELLED"}
-
-        self.handler = bpy.types.SpaceView3D.draw_handler_add(draw, (self, context.area), 'WINDOW', 'POST_PIXEL')
-        context.window_manager.modal_handler_add(self)
-
-        aw = context.area.width
-        ah = context.area.height
-        pw = min(aw-60, 600)
-        
-        global panel_global
-        if not panel_global:
-            panel_global = Panel(Vector((30, 25)), pw, pw*(9/16))
-        self.panel = panel_global
-
-        LightImage.default_size = 100
-
-        self.mouse_x = event.mouse_x - context.area.x
-        self.mouse_y = event.mouse_y - context.area.y
-
-        update_light_sets(self.panel, context, always=True)
-
-        context.area.header_text_set(text=self.textinfo)
-
-        self.ctrl = False
-
-        return {"RUNNING_MODAL"}
-    
-    def modal(self, context, event):
-        global running_modals
-        if running_modals < 1:
-            self._unregister_handler()
-            context.area.tag_redraw()
-            return {"FINISHED"}
-
-        # print(event.type, event.value)
-        if not context.area or (context.object and not context.object.mode == 'OBJECT'):
-            self._unregister_handler()
-            return {"CANCELLED"}
-        try:
-            context.area.tag_redraw()
-
-            update_light_sets(self.panel, context)
-            LightImage.refresh()
-
-            if event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
-                dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
-                if self.clicked_object and self.panel_moving:
-                    # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
-                    # self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
-                    if isinstance(self.clicked_object, Panel):
-                        # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
-                        self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
-                    else:
-                        active_object = None
-                        if LightImage.selected_object:
-                            active_object = LightImage.selected_object
-                        if active_object and not GRABBING:
-                            bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
-                            self.panel_moving = False
-                    
-                    return {"RUNNING_MODAL"}
-
-                return {"PASS_THROUGH"}
-            
-            if event.value == "PRESS":
-                if event.type in {"LEFT_CTRL"}:
-                    self.ctrl = True
-
-                if event.type in {"R"}:
-                    active_object = None
-                    if LightImage.selected_object:
-                        active_object = LightImage.selected_object
-                    
-                    if active_object:
-                        bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
-                        return {'RUNNING_MODAL'}
-                elif event.type in {"S"}:
-                    active_object = None
-                    if LightImage.selected_object:
-                        active_object = LightImage.selected_object
-                    
-                    if active_object:
-                        bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
-                        return {'RUNNING_MODAL'}
-
-                elif event.type == "RIGHTMOUSE":
-                    dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
-                    self.clicked_object = self.find_clicked(area_mouse_x, area_mouse_y)
-
-                    if not self.clicked_object:
-                        return {"PASS_THROUGH"}
-                    
-                    if hasattr(self.clicked_object, 'mute'):
-                        muted_count = len([l for l in LightImage.lights if l.mute])
-                        unmuted_count = len(LightImage.lights) - muted_count
-                        if muted_count == 0:
-                            # no muted at start. mute all but selected
-                            for l in LightImage.lights:
-                                l.mute = True
-                            self.clicked_object.mute = False
-                        else:
-                            # some muted.
-                            if unmuted_count == 1 and self.clicked_object.mute == False:
-                                for l in LightImage.lights:
-                                    l.mute = False
-                            else:
-                                for l in LightImage.lights:
-                                    l.mute = True
-                                self.clicked_object.mute = False
-
-                    if hasattr(self.clicked_object, 'select'):
-                        self.clicked_object.select()
-                    
-                    return {"RUNNING_MODAL"}
-
-                # Left mouse button pressed            
-                elif event.type == "LEFTMOUSE":
-                    dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
-
-                    overlapped = self.find_clicked(area_mouse_x, area_mouse_y, overlapping=True)
-                    if type(overlapped) == list:
-                        # List of overlapping lights
-                        self.clicked_object = overlapped[0] if overlapped else None
-                    else:
-                        # Button
-                        self.clicked_object = overlapped
-                    self.panel_moving = self.clicked_object != None
-                    
-                    click_result = self.click_manager.click(self.clicked_object)
-                    if not self.ctrl and hasattr(self.clicked_object, 'mute'):
-                        if click_result == "TRIPLE":
-                            muted_count = len([l for l in LightImage.lights if l.mute]) - 1
-                            unmuted_count = len(LightImage.lights) - muted_count
-                            if muted_count == 0:
-                                # no muted at start. mute all but selected
-                                for l in LightImage.lights:
-                                    l.mute = True
-                                self.clicked_object.mute = False
-                            else:
-                                # some muted.
-                                if unmuted_count == 1 and self.clicked_object.mute == True:
-                                    for l in LightImage.lights:
-                                        l.mute = False
-                                else:
-                                    for l in LightImage.lights:
-                                        l.mute = True
-                                    self.clicked_object.mute = False
-                        elif click_result == "DOUBLE":
-                            self.clicked_object.mute = not self.clicked_object.mute
-
-                    if hasattr(self.clicked_object, 'select'):
-                        self.clicked_object.select()
-                        if self.ctrl and len(overlapped)>1:
-                            send_light_to_bottom(self.clicked_object)
-                            self.find_clicked(area_mouse_x, area_mouse_y).select()
-                        else:
-                            send_light_to_top(self.clicked_object)
-
-
-                    if hasattr(self.clicked_object, 'click'):
-                        result = self.clicked_object.click()
-                        if result == "FINISHED":
-                            context.area.header_text_set(text=None)
-                            self._unregister_handler()
-                            return {"FINISHED"}
-                        return {"RUNNING_MODAL"}
-
-                    if self.clicked_object:
-                        return {"RUNNING_MODAL"}
-                    return {"PASS_THROUGH"}
-
-                elif event.type == "NUMPAD_PLUS":
-                    LightImage.change_default_size(LightImage.default_size+10)
-                    return {'RUNNING_MODAL'}
-                elif event.type == "NUMPAD_MINUS":
-                    LightImage.change_default_size(LightImage.default_size-10)
-                    return {'RUNNING_MODAL'}
-                elif event.type == "LEFT_SHIFT":
-                    self.precision_mode = True
-                    return {'RUNNING_MODAL'}
-                
-                # Return (Enter) key is pressed
-                elif event.type == "RET":
-                    context.area.header_text_set(text=None)
-                    self._unregister_handler()
-                    return {'FINISHED'}
-            
-            if event.value == "RELEASE":
-                context.area.header_text_set(text=self.textinfo)
-                if event.type == "LEFTMOUSE":
-                    self.panel_moving = False
-                elif event.type == "LEFT_SHIFT":
-                    self.precision_mode = False
-                    return {'RUNNING_MODAL'}
-                elif event.type in {"LEFT_CTRL"}:
-                    self.ctrl = False
-
-            if event.value == "CLICK":
-                # Left mouse button clicked
-                if event.type == "LEFTMOUSE":
-                    return {"PASS_THROUGH"}
-        except:
-            self._unregister_handler()
-            import traceback
-            traceback.print_exc()
-            return {"CANCELLED"}
-        
-        return {"PASS_THROUGH"}
-
-    def find_clicked(self, area_mouse_x, area_mouse_y, overlapping=False):
-        overlapped = []
-        for l in reversed(LightImage.lights):
-            if l.is_mouse_over(area_mouse_x, area_mouse_y):
-                if not overlapping:
-                    return l
-                else:
-                    overlapped.append(l)
-
-        if overlapping and overlapped:
-            return overlapped
-        
-        for b in Button.buttons:
-            if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
-                return b
-
-        if is_in_rect(self.panel, Vector((area_mouse_x, area_mouse_y))):
-            return self.panel
-        return None
-
-def update_light_sets(panel, context, always=False):
-    bls_collection, profile_collection = blscol_profilecol(context)
-    if is_updated() or always or len(profile_collection.children) != len(LightImage.lights):
-        bls_lights = set(profile_collection.children)
-        working_set = set((l._collection for l in LightImage.lights))
-
-        to_delete = working_set.difference(bls_lights)
-        to_add =  bls_lights.difference(working_set)
-        
-        for col in to_delete:
-            LightImage.remove(col)
-
-        for col in to_add:
-            LightImage(context, panel, col)
-
-        update_clear()
-
-def close_control_panel():
-    global running_modals
-    running_modals = 0
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/operators/modal_utils.py b/skrypt/leomoon_lightstudio/operators/modal_utils.py
deleted file mode 100644
index 84d4656..0000000
--- a/skrypt/leomoon_lightstudio/operators/modal_utils.py
+++ /dev/null
@@ -1,905 +0,0 @@
-import gpu, bgl, blf
-from gpu_extras.batch import batch_for_shader
-from mathutils import *
-from math import pi, fmod, radians, sin, cos, atan2
-from .. common import *
-from . import *
-import time
-from copy import deepcopy
-
-shader2Dcolor = gpu.shader.from_builtin('2D_UNIFORM_COLOR')
-shader2Dcolor.bind()
-
-vertex_shader = '''
-    uniform mat4 ModelViewProjectionMatrix;
-
-    /* Keep in sync with intern/opencolorio/gpu_shader_display_transform_vertex.glsl */
-    in vec2 pos;
-    in vec2 texCoord;
-    out vec2 texCoord_interp;
-
-    void main()
-    {
-        gl_Position = ModelViewProjectionMatrix * vec4(pos.xy, 0.0f, 1.0f);
-        gl_Position.z = 1.0;
-        texCoord_interp = texCoord;
-    }
-'''
-
-fragment_shader = '''
-    #define PI 3.1415926535897932384626433832795f
-
-    in vec2 texCoord_interp;
-    in vec4 gl_FragCoord;
-
-    layout(location = 0) out vec4 fragColor;
-    layout(location = 1) out vec4 trash;
-
-    uniform sampler2D image;
-    uniform float panel_point_left;
-    uniform float panel_point_right;
-
-    uniform vec4 color_overlay = vec4(0);
-    uniform float intensity = 1;
-    uniform float texture_switch = 1;
-    uniform float color_saturation = 0;
-
-    uniform float mask_bottom_to_top = 0;
-    uniform float mask_diagonal_bottom_left = 0;
-    uniform float mask_diagonal_bottom_right = 0;
-    uniform float mask_diagonal_top_left = 0;
-    uniform float mask_diagonal_top_right = 0;
-    uniform float mask_gradient_amount = 0;
-    uniform float mask_gradient_switch = 0;
-    uniform float mask_gradient_type = 0;
-    uniform float mask_left_to_right = 0;
-    uniform float mask_right_to_left = 0;
-    uniform float mask_ring_inner_radius = 0;
-    uniform float mask_ring_outer_radius = 0;
-    uniform float mask_ring_switch = 0;
-    uniform float mask_top_to_bottom = 0;
-
-    void main()
-    {
-        // Trash output - sum all uniforms to prevent compiler from skipping currently unused ones
-        trash = vec4(panel_point_left+panel_point_right+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
-        
-        // Texture Switch + Intensity
-        // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
-        fragColor = mix(vec4(1.0f), texture(image, texCoord_interp), texture_switch) * log(1+intensity);
-        
-        // Color Overlay
-        float gray = clamp(dot(fragColor.rgb, vec3(0.299, 0.587, 0.114)), 0, 1);
-        vec4 colored = color_overlay * gray;
-        
-        // Color Saturation
-        fragColor = mix(fragColor, colored, color_saturation);
-        fragColor.a = gray;
-        fragColor.rgb *= fragColor.a;
-
-        // MASKS //
-
-        // Vertical gradient + mask_gradient_amount
-        float vg = sqrt(texCoord_interp.y);
-        vg = (texCoord_interp.y <= mask_gradient_amount+.05f) ? mix(0, vg, (texCoord_interp.y-mask_gradient_amount)/.05f) : vg;
-        vg = texCoord_interp.y >= mask_gradient_amount ? vg : 0;
-
-        // Spherical gradient + mask_gradient_amount
-        float d = distance(texCoord_interp.xy, vec2(0.5f, 0.5f));
-        float m = (1.0f-mask_gradient_amount)*.5f;
-        float sg = 1-pow(d*2, 2.f);
-        sg = (d >= m-.05f) ? mix(0, sg, (m-d)/.05f) : sg;
-        sg = (d <= m) ? sg : 0;
-
-        // Gradient Type
-        float grad = mix(sg, vg, mask_gradient_type);
-
-        // Gradient Switch
-        fragColor.a = mix(fragColor.a, grad*fragColor.a, mask_gradient_switch);
-
-        // Gradient Ring Switch
-        float ring = d < (1-mask_ring_outer_radius)*.575f ? 1 : 0;
-        ring = d < (1-mask_ring_inner_radius)*.55f ? 0 : ring;
-        fragColor.a = mix(fragColor.a, fragColor.a*ring, mask_ring_switch);
-        
-        // Top-Bottom
-        fragColor.a = texCoord_interp.y < (1-mask_top_to_bottom) ? fragColor.a : 0;
-        
-        // Bottom-Top
-        fragColor.a = texCoord_interp.y > mask_bottom_to_top ? fragColor.a : 0;
-
-        // Left-Right
-        fragColor.a = texCoord_interp.x > mask_left_to_right ? fragColor.a : 0;
-        
-        // Right-Left
-        fragColor.a = texCoord_interp.x < (1-mask_right_to_left) ? fragColor.a : 0;
-
-        // Diagonal Top-Right
-        fragColor.a = 1-(texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_right ? fragColor.a : 0;
-        
-        // Diagonal Top-Left
-        fragColor.a = 1-(1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_left ? fragColor.a : 0;
-        
-        // Diagonal Bottom-Right
-        fragColor.a = (1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_right ? fragColor.a : 0;
-
-        // Diagonal Bottom-Left
-        fragColor.a = (texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_left ? fragColor.a : 0;
-
-        // Panel bound clipping
-        if(gl_FragCoord.x < panel_point_left || gl_FragCoord.x > panel_point_right)
-            discard;
-    }
-'''
-
-border_vertex_shader= '''
-    uniform mat4 ModelViewProjectionMatrix;
-
-    #ifdef UV_POS
-    in vec2 u;
-    #  define pos u
-    #else
-    in vec2 pos;
-    #endif
-
-    void main()
-    {
-        gl_Position = ModelViewProjectionMatrix * vec4(pos, 0.0, 1.0);
-    }
-'''
-border_fragment_shader= '''
-    uniform vec4 color;
-    uniform vec2 panel_point_lt;
-    uniform vec2 panel_point_rb;
-    in vec4 gl_FragCoord;
-    out vec4 fragColor;
-
-    void main()
-    {
-        fragColor = color;
-
-        if(gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
-            fragColor.rgba = vec4(0);
-    }
-'''
-
-lightIconShader = gpu.types.GPUShader(vertex_shader, fragment_shader)
-lightIconShader.bind()
-
-border_shader2Dcolor = gpu.types.GPUShader(border_vertex_shader, border_fragment_shader)
-border_shader2Dcolor.bind()
-
-class Rectangle:
-    def __init__(self, start_point, width, height):
-        self.point_lt = Vector((
-            min(start_point.x, start_point.x+width),
-            max(start_point.y, start_point.y+height),
-            ))
-        self.point_rb = Vector((
-            max(start_point.x, start_point.x+width),
-            min(start_point.y, start_point.y+height),
-            ))
-
-        self.rot = 0
-
-    @property
-    def loc(self):
-        return (self.point_lt + self.point_rb)/2
-
-    @loc.setter
-    def loc(self, loc):
-        d = loc - self.loc
-        self.point_lt += d
-        self.point_rb += d
-    
-    @property
-    def width(self):
-        return self.point_rb.x - self.point_lt.x
-
-    @width.setter
-    def width(self, width):
-        d = width - self.width
-        self.point_lt.x -= d/2
-        self.point_rb.x = self.point_lt.x + width
-
-    @property
-    def height(self):
-        return self.point_lt.y - self.point_rb.y
-
-    @height.setter
-    def height(self, height):
-        d = height - self.height
-        self.point_lt.y += d/2
-        self.point_rb.y = self.point_lt.y - height
-
-    def get_verts(self):
-        def rotate(x1, y1, offset):
-            x1 -= offset.x
-            y1 -= offset.y
-            x2 = cos(self.rot) * x1 - sin(self.rot) * y1
-            y2 = sin(self.rot) * x1 + cos(self.rot) * y1
-            x2 += offset.x
-            y2 += offset.y
-            return [x2, y2]
-        
-        loc = self.loc # prevent property from recomputing
-        return (
-            rotate(self.point_lt.x, self.point_lt.y, loc),
-            rotate(self.point_lt.x, self.point_rb.y, loc),
-            rotate(self.point_rb.x, self.point_lt.y, loc),
-            rotate(self.point_rb.x, self.point_rb.y, loc),
-        )
-
-    def get_tex_coords(self):
-        return ([0, 1], [0, 0], [1, 1], [1, 0])
-
-    def move(self, loc_diff):
-        rect = self.panel if hasattr(self, 'panel') else self
-
-        new_loc = self.loc + loc_diff
-        new_loc.x = clamp(rect.point_lt.x, new_loc.x, rect.point_rb.x)
-        new_loc.y = clamp(rect.point_rb.y, new_loc.y, rect.point_lt.y)
-        self.loc = new_loc
-
-def send_light_to_bottom(light):
-    light = LightImage.selected_object if not light else light
-    if not light:
-        return
-    lights = LightImage.lights
-    lights.insert(0, lights.pop(lights.index(light)))
-
-def send_light_to_top(light):
-    light = LightImage.selected_object if not light else light
-    if not light:
-        return
-    lights = LightImage.lights
-    lights.append(lights.pop(lights.index(light)))
-
-class Panel(Rectangle):
-    def __init__(self, loc, width, height):
-        super().__init__(loc, width, height)
-        self.button_exit = Button(Vector((0,0)), 'X', 30)
-        self.button_exit.function = lambda x: "FINISHED"
-
-        self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
-        self.button_send_to_bottom.function = send_light_to_bottom
-
-        self._move_buttons()
-
-    def _move_buttons(self):
-        self.button_exit.loc = Vector((
-            self.point_rb.x - self.button_exit.dimensions[0]/4,
-            self.point_lt.y - self.button_exit.dimensions[1]/4,
-        ))
-
-        self.button_send_to_bottom.loc = Vector((
-            self.point_lt.x + self.button_send_to_bottom.dimensions[0]/2,
-            self.point_rb.y - self.button_exit.dimensions[1]/2,
-        ))
-
-    def draw(self):
-        shader2Dcolor.uniform_float("color", (0.05, 0.05, 0.05, 1))
-        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
-
-    def move(self, loc_diff):
-        super().move(loc_diff)
-
-        for l in LightImage.lights:
-            l.update_visual_location()
-        
-        self._move_buttons()
-
-class Button(Rectangle):
-    buttons = []
-    def __init__(self, loc, text, size=15):
-        self.font_size = size
-        self.font_color = (.25, .25, .25, 1)
-        self.bg_color = (.5, .5, .5, 1)
-        self.bg_color_selected = (.7, .7, .7, 1)
-        self.font_id = len(Button.buttons)
-        self.text = text
-        blf.color(self.font_id, *self.font_color)
-        blf.position(self.font_id, *loc, 0)
-        blf.size(self.font_id, self.font_size, 72)
-        self.dimensions = blf.dimensions(self.font_id, text)
-        self.function = lambda args : None
-
-        super().__init__(loc, self.dimensions[0]+5, self.dimensions[1]+5)
-        Button.buttons.append(self)
-
-    def draw(self, mouse_x, mouse_y):
-        # draw something to refresh buffer?
-        shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
-        batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
-
-        if is_in_rect(self, Vector((mouse_x, mouse_y))):
-            shader2Dcolor.uniform_float("color", self.bg_color_selected)
-        else:
-            shader2Dcolor.uniform_float("color", self.bg_color)
-        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
-        blf.size(self.font_id, self.font_size, 72)
-        blf.position(self.font_id, self.point_lt.x + 2.5, self.point_rb.y + 2.5, 0)
-        blf.draw(self.font_id, self.text)
-
-    def click(self, args=None):
-        return self.function(args)
-
-view_layers = []
-
-class Border(Rectangle):
-    weight = 5
-
-    def __init__(self, light_image, color):
-        self.color = color
-        self.light_image = light_image
-        super().__init__(Vector((0, 0)), 100, 100)
-
-    def draw(self):
-        verts = self.get_verts()
-        lleft = min(verts, key=lambda v: v[0])[0]
-        lright = max(verts, key=lambda v: v[0])[0]
-
-        bleft = self.light_image.panel.point_lt[0]
-        bright = self.light_image.panel.point_rb[0]
-
-        from mathutils import Euler
-        rot_translate = Vector((self.weight, 0, 0))
-        rot_translate.rotate(Euler((0,0,self.rot)))
-        rot_translate_ort = Vector((-rot_translate.y, rot_translate.x))
-
-                #       0   1
-        # 0  lt.x, lt.y         0 2
-        # 1  lt.x, rb.y         1 3
-        # 2  rb.x, lt.y
-        # 3  rb.x, rb.y
-
-        left_verts = [
-            verts[0],
-            verts[1],
-            [verts[0][0]+rot_translate.x, verts[0][1]+rot_translate.y],
-            [verts[1][0]+rot_translate.x, verts[1][1]+rot_translate.y]
-        ]
-
-        right_verts = [
-            [verts[2][0]-rot_translate.x, verts[2][1]-rot_translate.y],
-            [verts[3][0]-rot_translate.x, verts[3][1]-rot_translate.y],
-            verts[2],
-            verts[3]
-        ]
-
-        top_verts = [
-            verts[0],
-            [verts[0][0]-rot_translate_ort.x, verts[0][1]-rot_translate_ort.y],
-            verts[2],
-            [verts[2][0]-rot_translate_ort.x, verts[2][1]-rot_translate_ort.y]
-        ]
-
-        bottom_verts = [
-            [verts[1][0]+rot_translate_ort.x, verts[1][1]+rot_translate_ort.y],
-            verts[1],
-            [verts[3][0]+rot_translate_ort.x, verts[3][1]+rot_translate_ort.y],
-            verts[3]
-        ]
-        
-        border_shader2Dcolor.bind()
-        bgl.glEnable(bgl.GL_BLEND);
-        border_shader2Dcolor.uniform_float("color", self.color)
-        border_shader2Dcolor.uniform_float("panel_point_lt", self.light_image.panel.point_lt)
-        border_shader2Dcolor.uniform_float("panel_point_rb", self.light_image.panel.point_rb)
-        if lleft < bleft:
-            left_verts2 = deepcopy(left_verts)
-            for v in left_verts2:
-                v[0] += self.light_image.panel.width
-
-            right_verts2 = deepcopy(right_verts)
-            for v in right_verts2:
-                v[0] += self.light_image.panel.width
-            
-            top_verts2 = deepcopy(top_verts)
-            for v in top_verts2:
-                v[0] += self.light_image.panel.width
-            
-            bottom_verts2 = deepcopy(bottom_verts)
-            for v in bottom_verts2:
-                v[0] += self.light_image.panel.width
-
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(border_shader2Dcolor)
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(border_shader2Dcolor)
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(border_shader2Dcolor)
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(border_shader2Dcolor)
-        elif lright > bright:
-            left_verts2 = deepcopy(left_verts)
-            for v in left_verts2:
-                v[0] -= self.light_image.panel.width
-
-            right_verts2 = deepcopy(right_verts)
-            for v in right_verts2:
-                v[0] -= self.light_image.panel.width
-            
-            top_verts2 = deepcopy(top_verts)
-            for v in top_verts2:
-                v[0] -= self.light_image.panel.width
-            
-            bottom_verts2 = deepcopy(bottom_verts)
-            for v in bottom_verts2:
-                v[0] -= self.light_image.panel.width
-
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(border_shader2Dcolor)
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(border_shader2Dcolor)
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(border_shader2Dcolor)
-            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(border_shader2Dcolor)
-        
-        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(border_shader2Dcolor)
-        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(border_shader2Dcolor)
-        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(border_shader2Dcolor)
-        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(border_shader2Dcolor)
-        bgl.glDisable(bgl.GL_BLEND);
-
-    def get_verts(self):
-        self.point_lt = self.light_image.point_lt.copy()
-        self.point_rb = self.light_image.point_rb.copy()
-
-        self.point_lt.x -= self.weight
-        self.point_lt.y += self.weight
-
-        self.point_rb.x += self.weight
-        self.point_rb.y -= self.weight
-        
-        self.rot = self.light_image.rot
-
-        return super().get_verts()
-
-
-class LightImage(Rectangle):
-    selected_object = None
-    lights = []
-    @classmethod
-    def find_idx(cls, bls_light_collection):
-        for idx, l in enumerate(cls.lights):
-            if l._collection == bls_light_collection:
-                return idx
-        return -1
-    @classmethod
-    def remove(cls, bls_light_collection):
-        del cls.lights[cls.find_idx(bls_light_collection)]
-
-    def delete(self):
-        del LightImage.lights[LightImage.lights.index(self)]
-    
-    @classmethod
-    def refresh(cls):
-        cls.selected_object = None
-        for l in cls.lights:
-            try:
-                if l.update_from_bls():
-                    l.update_visual_location()
-            except ReferenceError:
-                l.delete()
-            
-    
-    default_size = 100
-    @classmethod
-    def change_default_size(cls, value):
-        cls.default_size = value
-        for l in cls.lights:
-            l.width = value * l._scale.y
-            l.height = value * l._scale.z
-        
-    def panel_loc_to_area_px_lt(self):
-        panel_px_loc = Vector((self.panel.width * self.panel_loc.x, -self.panel.height * (1-self.panel_loc.y)))
-        return panel_px_loc + self.panel.point_lt - Vector((LightImage.default_size*self._scale.y/2, LightImage.default_size*self._scale.z/2))
-    
-    def _update_panel_loc(self):
-        self.panel_loc.x = (self._bls_rot.x + pi) % (2*pi) / (2*pi)
-        self.panel_loc.y = fmod(self._bls_rot.y + pi/2, pi) / (pi)
-
-    def update_from_bls(self):
-        if self._bls_mesh.select_get():
-            LightImage.selected_object = self
-
-        updated = False
-        if self._bls_rot != self._bls_actuator.rotation_euler:
-            updated |= True
-            self._bls_rot = self._bls_actuator.rotation_euler.copy()
-        if self.rot != self._bls_mesh.rotation_euler.x:
-            updated |= True
-            self.rot = self._bls_mesh.rotation_euler.x
-        if self._scale != self._bls_mesh.scale:
-            updated |= True
-            self._scale = self._bls_mesh.scale.copy()
-            self.width = LightImage.default_size * self._scale.y
-            self.height = LightImage.default_size * self._scale.z
-        
-        if updated:
-            self._update_panel_loc()
-
-        if self._image_path != self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath:
-            updated |= True
-            self.image = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image
-            self._image_path = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath
-        # this should run when image changes but sometimes Blender looses images... so it's run every time to be safe
-        if self.image.gl_load():
-            raise Exception
-        
-
-        return updated
-
-    def update_bls(self):
-        self._bls_actuator.rotation_euler = self._bls_rot
-        self._bls_mesh.rotation_euler.x = self.rot
-
-    def __init__(self, context, panel, bls_light_collection):
-        self.panel = panel
-        self.__panel_loc = Vector((.5, .5))
-
-        self._collection = bls_light_collection
-        self._bls_mesh = [m for m in bls_light_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
-        self._bls_actuator = self._bls_mesh.parent
-        self._view_layer = find_view_layer(self._collection, context.view_layer.layer_collection)
-        
-        self._image_path = ""
-        self._bls_rot = None
-        self._scale = None
-
-        super().__init__(Vector((0,0)), LightImage.default_size, LightImage.default_size)
-        self.update_from_bls()
-        self.update_visual_location()
-        
-        LightImage.lights.append(self)
-
-        self.mute_border = Border(self, (.7, 0, 0, 1))
-        self.select_border = Border(self, (.2, .9, .2, 1))
-        self.select_border.weight = 2
-    
-    @property
-    def mute(self):
-        return self._view_layer.exclude
-    
-    @mute.setter
-    def mute(self, value):
-        self._view_layer.exclude = value
-
-    @property
-    def panel_loc(self):
-        return self.__panel_loc
-    
-    @panel_loc.setter
-    def panel_loc(self, pos):
-        self.__panel_loc = pos
-        self._bls_rot = Vector((
-            (self.panel_loc.x -.5) * (2*pi),
-            (self.panel_loc.y -.5) * (pi),
-            self._bls_rot.z
-        ))
-        self.update_visual_location() # update self.loc
-
-    def select(self):
-        if self.mute:
-            return
-        bpy.ops.object.select_all(action='DESELECT')
-        bpy.context.view_layer.objects.active = self._bls_mesh
-        self._bls_mesh.select_set(True)
-
-    def is_mouse_over(self, mouse_x, mouse_y):
-        def rotate(x1, y1, offset):
-            x1 -= offset.x
-            y1 -= offset.y
-            x2 = cos(-self.rot) * x1 - sin(-self.rot) * y1
-            y2 = sin(-self.rot) * x1 + cos(-self.rot) * y1
-            x2 += offset.x
-            y2 += offset.y
-            return [x2, y2]
-        
-        bleft = self.panel.point_lt[0]
-        bright = self.panel.point_rb[0]
-
-        if mouse_x > bright or mouse_x < bleft:
-            return False
-
-        tmouse_x, tmouse_y = rotate(mouse_x, mouse_y, self.loc)
-        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
-            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
-            return True
-        
-        tmouse_x, tmouse_y = rotate(bleft-(bright-mouse_x), mouse_y, self.loc)
-        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
-            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
-            return True
-
-        tmouse_x, tmouse_y = rotate(bright+(mouse_x-bleft), mouse_y, self.loc)
-        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
-            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
-            return True
-
-        return False
-
-    def draw(self):
-        try:
-            select = self._bls_mesh.select_get()
-        except ReferenceError:
-            return
-        
-        # draw something to refresh buffer?
-        shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
-        batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
-
-        bleft = self.panel.point_lt[0]
-        bright = self.panel.point_rb[0]
-        
-        verts = self.get_verts()
-        uv_coords = self.get_tex_coords()
-        
-        lleft = min(verts, key=lambda v: v[0])[0]
-        lright = max(verts, key=lambda v: v[0])[0]
-
-        if self.mute:
-            self.mute_border.draw()
-        if select:
-            self.select_border.draw()
-
-        lightIconShader.bind()
-        bgl.glActiveTexture(bgl.GL_TEXTURE0)
-        bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
-        lightIconShader.uniform_int("image", 0)
-
-        lightIconShader.uniform_float("panel_point_left", self.panel.point_lt.x)
-        lightIconShader.uniform_float("panel_point_right", self.panel.point_rb.x)
-
-        try:
-            # material properties
-            bls_node = self._bls_mesh.active_material.node_tree.nodes['Group']
-            intensity = bls_node.inputs['Intensity'].default_value
-
-            texture_switch = bls_node.inputs['Texture Switch'].default_value
-            color_overlay = bls_node.inputs['Color Overlay'].default_value
-            color_saturation = bls_node.inputs['Color Saturation'].default_value
-
-            lightIconShader.uniform_float("intensity", intensity)
-            lightIconShader.uniform_float("texture_switch", texture_switch)
-            lightIconShader.uniform_float("color_overlay", color_overlay)
-            lightIconShader.uniform_float("color_saturation", color_saturation)
-
-            mask_bottom_to_top = bls_node.inputs['Mask - Bottom to Top'].default_value
-            mask_diagonal_bottom_left = bls_node.inputs['Mask - Diagonal Bottom Left'].default_value
-            mask_diagonal_bottom_right = bls_node.inputs['Mask - Diagonal Bottom Right'].default_value
-            mask_diagonal_top_left = bls_node.inputs['Mask - Diagonal Top Left'].default_value
-            mask_diagonal_top_right = bls_node.inputs['Mask - Diagonal Top Right'].default_value
-            mask_gradient_amount = bls_node.inputs['Mask - Gradient Amount'].default_value
-            mask_gradient_switch = bls_node.inputs['Mask - Gradient Switch'].default_value
-            mask_gradient_type = bls_node.inputs['Mask - Gradient Type'].default_value
-            mask_left_to_right = bls_node.inputs['Mask - Left to Right'].default_value
-            mask_right_to_left = bls_node.inputs['Mask - Right to Left'].default_value
-            mask_ring_inner_radius = bls_node.inputs['Mask - Ring Inner Radius'].default_value
-            mask_ring_outer_radius = bls_node.inputs['Mask - Ring Outer Radius'].default_value
-            mask_ring_switch = bls_node.inputs['Mask - Ring Switch'].default_value
-            mask_top_to_bottom = bls_node.inputs['Mask - Top to Bottom'].default_value
-
-            lightIconShader.uniform_float("mask_bottom_to_top", mask_bottom_to_top)
-            lightIconShader.uniform_float("mask_diagonal_bottom_left", mask_diagonal_bottom_left)
-            lightIconShader.uniform_float("mask_diagonal_bottom_right", mask_diagonal_bottom_right)
-            lightIconShader.uniform_float("mask_diagonal_top_left", mask_diagonal_top_left)
-            lightIconShader.uniform_float("mask_diagonal_top_right", mask_diagonal_top_right)
-            lightIconShader.uniform_float("mask_gradient_amount", mask_gradient_amount)
-            lightIconShader.uniform_float("mask_gradient_switch", mask_gradient_switch)
-            lightIconShader.uniform_float("mask_gradient_type", mask_gradient_type)
-            lightIconShader.uniform_float("mask_left_to_right", mask_left_to_right)
-            lightIconShader.uniform_float("mask_right_to_left", mask_right_to_left)
-            lightIconShader.uniform_float("mask_ring_inner_radius", mask_ring_inner_radius)
-            lightIconShader.uniform_float("mask_ring_outer_radius", mask_ring_outer_radius)
-            lightIconShader.uniform_float("mask_ring_switch", mask_ring_switch)
-            lightIconShader.uniform_float("mask_top_to_bottom", mask_top_to_bottom)
-        except:
-            pass
-        bgl.glEnable(bgl.GL_BLEND);
-
-        if lleft < bleft:
-            verts2 = deepcopy(verts)
-            for v in verts2:
-                v[0] += self.panel.width
-
-            batch_for_shader(
-                lightIconShader, 'TRI_STRIP',
-                {
-                    "pos": verts,
-                    "texCoord": uv_coords,
-                }
-            ).draw(lightIconShader)
-
-            batch_for_shader(
-                lightIconShader, 'TRI_STRIP',
-                {
-                    "pos": verts2,
-                    "texCoord": uv_coords,
-                }
-            ).draw(lightIconShader)
-        elif lright > bright:
-            verts2 = deepcopy(verts)
-            for v in verts2:
-                v[0] -= self.panel.width
-
-            batch_for_shader(
-                lightIconShader, 'TRI_STRIP',
-                {
-                    "pos": verts,
-                    "texCoord": uv_coords,
-                }
-            ).draw(lightIconShader)
-
-            batch_for_shader(
-                lightIconShader, 'TRI_STRIP',
-                {
-                    "pos": verts2,
-                    "texCoord": uv_coords,
-                }
-            ).draw(lightIconShader)
-        else:
-            batch_for_shader(
-                lightIconShader, 'TRI_STRIP',
-                {
-                    "pos": verts,
-                    "texCoord": self.get_tex_coords(),
-                }
-            ).draw(lightIconShader)
-        bgl.glDisable(bgl.GL_BLEND);
-
-    def update_visual_location(self):
-        self.loc = self.panel_loc_to_area_px_lt() + Vector((self.width/2, self.height/2))
-
-    def move(self, loc_diff):
-        super().move(loc_diff)
-
-        self.panel_loc = Vector((
-            (self.loc.x-self.panel.loc.x) / self.panel.width +.5,
-            clamp(0.0001, (self.loc.y-self.panel.loc.y) / self.panel.height +.5, 0.9999),
-        ))
-
-        self.update_bls()
-
-def is_in_rect(rect, loc):
-    return (loc.x >= rect.point_lt.x and loc.x <= rect.point_rb.x) and (loc.y >= rect.point_rb.y and loc.y <= rect.point_lt.y)
-
-def clamp(minimum, x, maximum):
-    return max(minimum, min(x, maximum))
-
-class ClickManager:
-    def __init__(self):
-        self.times = [0, 0, 0]
-        self.objects = [None, None, None]
-    
-    def click(self, object):
-        self.times.append(time.time())
-        self.objects.append(object)
-        if len(self.times) > 3:
-            del self.times[0]
-            del self.objects[0]
-        
-        if self.objects[0] == self.objects[1] == self.objects[2]:
-            if self.times[2] - self.times[0] <= .5:
-                return "TRIPLE"
-        if self.objects[1] == self.objects[2]:
-            if self.times[2] - self.times[1] <= .5:
-                return "DOUBLE"
-
-class MouseWidget:
-    mouse_x: bpy.props.IntProperty()
-    mouse_y: bpy.props.IntProperty()
-    
-    def __init__(self):
-        self._start_position = Vector((0, 0))
-        self._end_position = Vector((0, 0))
-        self._reference_end_position = Vector((0, 0))
-        self._base_rotation = 0
-        self.handler = None
-
-        self.draw_guide = True
-
-        self.allow_xy_keys = False
-        self.x_key = False
-        self.y_key = False
-
-        self.continous = False
-
-        self.allow_precision_mode = False
-        self.precision_mode = False
-        self.precision_offset = Vector((0,0))
-
-    def invoke(self, context, event):
-        mouse_x = event.mouse_x - context.area.x
-        mouse_y = event.mouse_y - context.area.y
-
-        self._start_position = Vector((self.mouse_x, self.mouse_y))
-        self._end_position = Vector((mouse_x, mouse_y))
-        self._reference_end_position = self._end_position
-        vec = self._end_position - self._start_position
-        self._base_rotation = atan2(vec.y, vec.x)
-
-        self.handler = bpy.types.SpaceView3D.draw_handler_add(self._draw, (context, event,), 'WINDOW', 'POST_PIXEL')
-        context.window_manager.modal_handler_add(self)
-
-    def _cancel(self, context, event): pass
-    def _finish(self, context, event): pass
-
-    def modal(self, context, event):
-        # print(event.type, event.value)
-        if not context.area:
-            self._unregister_handler()
-            self._cancel(context, event)
-            return {"CANCELLED"}
-
-        if event.type in {"ESC", "RIGHTMOUSE"}:
-            self._unregister_handler()
-            self._cancel(context, event)
-            return {'CANCELLED'}
-
-        if event.type == "RET" or (not self.continous and event.type == "LEFTMOUSE"):
-            self._unregister_handler()
-            self._finish(context, event)
-            return {'FINISHED'}
-
-        if self.continous and event.value == "RELEASE" and event.type == "LEFTMOUSE":
-            self._unregister_handler()
-            self._finish(context, event)
-            return {'FINISHED'}
-
-        self.mouse_x = event.mouse_x - context.area.x
-        self.mouse_y = event.mouse_y - context.area.y
-        self._end_position = Vector((self.mouse_x, self.mouse_y))
-        
-        if self.allow_xy_keys:
-            if event.value == "PRESS":
-                if event.type == "X":
-                    self.x_key = not self.x_key
-                    self.y_key = False
-                if event.type == "Y":
-                    self.y_key = not self.y_key
-                    self.x_key = False
-
-        if self.allow_precision_mode and event.value == "PRESS" and event.type == "LEFT_SHIFT":
-            self.precision_mode = True
-            self._precision_mode_mid_stop = self._end_position.copy()
-        elif self.allow_precision_mode and event.value == "RELEASE" and event.type == "LEFT_SHIFT" and self.precision_mode: #last condition in case when operator invoked with shift already pressed
-            self.precision_mode = False
-            self.precision_offset += self._end_position - self._precision_mode_mid_stop
-
-        return self._modal(context, event)
-
-    def __del__(self):
-        self._unregister_handler()
-
-    def _unregister_handler(self):
-        try:
-            bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
-        except (ValueError, AttributeError):
-            pass
-    
-    def length(self):
-        return (self._start_position - self._reference_end_position - self.delta_vector()).length
-    
-    def delta_vector(self):
-        if self.precision_mode:
-            return self._precision_mode_mid_stop - self._reference_end_position - self.precision_offset*.9 + (self._end_position - self._precision_mode_mid_stop) * .1
-        return self._end_position - self._reference_end_position - self.precision_offset*.9
-    
-    def delta_length_factor(self):
-        return self.length() / ((self._start_position - self._reference_end_position).length)
-
-    def angle(self):
-        vec = self._reference_end_position - self._start_position + self.delta_vector() + self.precision_offset*.9
-        return atan2(vec.y, vec.x) - self._base_rotation
-
-    def _draw(self, context, event):
-        # first draw to reset buffer
-        shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
-        batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0,0), (0,0))}).draw(shader2Dcolor)
-        
-        if self.draw_guide:
-            shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
-            batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position[:]), (self._end_position[:]))}).draw(shader2Dcolor)
-
-        if self.allow_xy_keys:
-            if self.x_key:
-                shader2Dcolor.uniform_float("color", (1, 0, 0, .5))
-                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0, self._start_position.y), (context.area.width, self._start_position.y))}).draw(shader2Dcolor)
-            elif self.y_key:
-                shader2Dcolor.uniform_float("color", (0, 1, 0, .5))
-                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position.x, 0), (self._start_position.x, context.area.height))}).draw(shader2Dcolor)
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Camera Flash 5600K.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Camera Flash 5600K.exr
deleted file mode 100644
index 9ecf821..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Camera Flash 5600K.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube A.hdr b/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube A.hdr
deleted file mode 100644
index 5407508..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube A.hdr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube B.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube B.exr
deleted file mode 100644
index 9953687..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube B.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Soft Box A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Soft Box A.exr
deleted file mode 100644
index 6352164..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Soft Box A.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area A.exr
deleted file mode 100644
index 5e448bf..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area A.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area B.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area B.exr
deleted file mode 100644
index 3dc61b5..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area B.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area C.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area C.exr
deleted file mode 100644
index 46a188c..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area C.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area D.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area D.exr
deleted file mode 100644
index 7f2ce35..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area D.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Disc A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Disc A.exr
deleted file mode 100644
index b0f8bc5..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Disc A.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Octagon A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Octagon A.exr
deleted file mode 100644
index a77bffe..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Octagon A.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring A.exr
deleted file mode 100644
index ea03d03..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring A.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring B.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring B.exr
deleted file mode 100644
index 6c38cfb..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring B.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Television A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Television A.exr
deleted file mode 100644
index a12cc96..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Television A.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Umbrella A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Umbrella A.exr
deleted file mode 100644
index 9d5e73b..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Umbrella A.exr and /dev/null differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Window A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Window A.exr
deleted file mode 100644
index 3c53a77..0000000
Binary files a/skrypt/leomoon_lightstudio/textures_real_lights/Window A.exr and /dev/null differ

commit 78590ba02246a816803fd6a8d63470481193ae19
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri May 8 11:43:36 2020 -0700

    gitignore changes

diff --git a/.gitignore b/.gitignore
index 34ea7d0..b07fc4d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,7 +7,7 @@ __pycache__/
 *.so
 
 # Distribution / packaging
-skrypt/
+/skrypt/
 .Python
 build/
 develop-eggs/

commit ced244f7dc2dc19f7698119d3e7ada169702e37c
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri May 8 11:40:32 2020 -0700

    fixed "backgroudn setup" creating new nodes and added "open textures folder"

diff --git a/src/gui.py b/src/gui.py
index cfcbab8..364e7fc 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -10,11 +10,11 @@ class LLS_PT_Studio(bpy.types.Panel):
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
     bl_category = "LightStudio"
-    
+
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'    
-    
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
+
     def draw(self, context):
         layout = self.layout
         col = layout.column(align=True)
@@ -31,11 +31,11 @@ class LLS_PT_Lights(bpy.types.Panel):
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
     bl_category = "LightStudio"
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.LLStudio.profile_list)
-    
+
     def draw(self, context):
         layout = self.layout
         col = layout.column(align=True)
@@ -50,24 +50,24 @@ class LLS_PT_Selected(bpy.types.Panel):
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
     bl_category = "LightStudio"
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
-    
+
     def draw(self, context):
         if context.active_object and (context.active_object.name.startswith('LLS_CONTROLLER') or context.active_object.name.startswith('LLS_LIGHT_MESH')):
             layout = self.layout
             wm = context.window_manager
-            
+
             col = layout.column(align=True)
             col.operator('lls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
-            
+
             box = layout.box()
             col = box.column()
             col.template_icon_view(wm, "lls_tex_previews", show_labels=True)
             col.label(text=os.path.splitext(wm.lls_tex_previews)[0])
-            
+
             layout.separator()
             try:
                 lls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
@@ -90,26 +90,26 @@ class LLS_PT_ProfileList(bpy.types.Panel):
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
     bl_category = "LightStudio"
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
-            
+
     def draw(self, context):
         layout = self.layout
         scene = context.scene
-        
+
         props = scene.LLStudio
-        
+
         row = layout.row()
         col = row.column()
         col.template_list("LLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
-        
+
         col = row.column(align=True)
         col.operator('lls_list.new_profile', icon='PLUS', text="")
         col.operator('lls_list.delete_profile', icon='TRASH', text="")
         col.operator('lls_list.copy_profile_menu', icon='DUPLICATE', text="")
-        
+
         col.separator()
         col.operator('lls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
         col.operator('lls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
@@ -121,15 +121,15 @@ class LLS_PT_ProfileImportExport(bpy.types.Panel):
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
     bl_category = "LightStudio"
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
-            
+
     def draw(self, context):
         layout = self.layout
         scene = context.scene
-              
+
         col = layout.column(align=True)
         col.operator('lls_list.export_profiles', text="Export Selected Profile")
         col.operator('lls_list.export_profiles', text="Export All Profiles").all=True
@@ -143,19 +143,20 @@ class LLS_PT_Misc(bpy.types.Panel):
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
     bl_category = "LightStudio"
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.LLStudio.initialized
-                
+
     def draw(self, context):
         layout = self.layout
         scene = context.scene
-        
+
         props = scene.LLStudio
-              
+
         col = layout.column(align=True)
         col.operator('lls.find_missing_textures')
+        col.operator('lls.open_textures_folder')
         col.operator('lls.lls_keyingset')
         if context.scene.keying_sets.active and context.scene.keying_sets.active.bl_idname == "BUILTIN_KSI_LightStudio":
             box = col.box()
@@ -170,7 +171,7 @@ class LLSKeyingSet(bpy.types.Operator):
     def poll(self, context):
         """ Enable if there's something in the list """
         return len(context.scene.LLStudio.profile_list)
-    
+
     def execute(self, context):
         context.scene.keying_sets.active = [k for k in context.scene.keying_sets_all if k.bl_idname == "BUILTIN_KSI_LightStudio"][0]
         return {"FINISHED"}
@@ -183,17 +184,17 @@ class LLS_PT_Hotkeys(bpy.types.Panel):
     bl_region_type = "UI"
     bl_category = "LightStudio"
     #bl_options = {'DEFAULT_CLOSED'}
-    
+
     #@classmethod
     #def poll(cls, context):
     #    return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.LLStudio.initialized
-                
+
     def draw(self, context):
         layout = self.layout
         scene = context.scene
-        
+
         props = scene.LLStudio
-        
+
         box = layout.box()
 
         box.label(text="Move light", icon='MOUSE_LMB')
@@ -207,7 +208,7 @@ class LLS_PT_Hotkeys(bpy.types.Panel):
 
         row.label(text="Precision mode", icon='EVENT_SHIFT')
         row = box.row(align=True)
-        
+
         box.label(text="Mute light", icon='MOUSE_LMB_DRAG')
 
         box.label(text="Isolate light", icon='MOUSE_RMB')
diff --git a/src/light_operators.py b/src/light_operators.py
index c2b8462..333aee0 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -9,26 +9,26 @@ _ = os.sep
 
 from . extensions_framework import util as efutil
 from . import bl_info
-    
+
 class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
-    initialized: BoolProperty(default = False)    
-    
+    initialized: BoolProperty(default = False)
+
     ''' Profile List '''
     profile_list: CollectionProperty(type = ListItem)
     list_index: IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
     last_empty: StringProperty(name="Name of last Empty holding profile", default="")
-    
+
 
 class CreateBlenderLightStudio(bpy.types.Operator):
     bl_idname = "scene.create_leomoon_light_studio"
     bl_label = "Create LightStudio"
     bl_description = "Append LeoMoon LightStudio to current scene"
     bl_options = {"REGISTER"}
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and not context.scene.LLStudio.initialized
-    
+
     def execute(self, context):
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
@@ -39,7 +39,7 @@ class CreateBlenderLightStudio(bpy.types.Operator):
         active_collection=False)
 
         bpy.ops.lls_list.new_profile()
-        
+
         context.scene.LLStudio.initialized = True
 
         bpy.context.scene.render.engine = 'CYCLES'
@@ -47,7 +47,7 @@ class CreateBlenderLightStudio(bpy.types.Operator):
         # add the first light
         # bpy.ops.object.select_all(action='DESELECT')
         # bpy.ops.scene.add_leomoon_studio_light()
-        
+
         return {"FINISHED"}
 
 class DeleteBlenderLightStudio(bpy.types.Operator):
@@ -55,23 +55,23 @@ class DeleteBlenderLightStudio(bpy.types.Operator):
     bl_label = "Delete LightStudio"
     bl_description = "Delete LeoMoon LightStudio from current scene"
     bl_options = {"REGISTER"}
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
-    
+
     def execute(self, context):
         scene = context.scene
         scene.LLStudio.initialized = False
-        
+
         # close control panel
         from . operators.modal import close_control_panel
         close_control_panel()
-        
+
         ''' for each profile from this scene: delete objects then remove from list '''
         while len(context.scene.LLStudio.profile_list):
             bpy.ops.lls_list.delete_profile()
-            
+
         obsToRemove = [ob for ob in scene.objects if isFamily(ob)]
         for ob in obsToRemove:
             for c in ob.users_collection:
@@ -79,15 +79,15 @@ class DeleteBlenderLightStudio(bpy.types.Operator):
             ob.user_clear()
             ob.use_fake_user = False
             bpy.data.objects.remove(ob)
-            
+
         context.scene.collection.children.unlink(get_lls_collection(context))
-        
+
         return {"FINISHED"}
-     
+
     def invoke(self, context, event):
         wm = context.window_manager
         return wm.invoke_props_dialog(self)
-    
+
     def draw(self, context):
         layout = self.layout
         col = layout.column(align=True)
@@ -103,9 +103,13 @@ class SetBackground(bpy.types.Operator):
     def poll(self, context):
         """ Enable if there's something in the list """
         return len(context.scene.LLStudio.profile_list)
-    
+
     def execute(self, context):
-        bpy.context.scene.world = bpy.data.worlds.new("LightStudio")
+        if bpy.data.worlds.get('LightStudio') is None:
+            bpy.context.scene.world = bpy.data.worlds.new('LightStudio')
+        else:
+            bpy.context.scene.world = bpy.data.worlds['LightStudio']
+        # bpy.context.scene.world = bpy.data.worlds.new("LightStudio")
         bpy.context.scene.world.use_nodes = True
         bpy.context.scene.world.node_tree.nodes["Background"].inputs[0].default_value = (0.00802319, 0.00802319, 0.00802319, 1)
         bpy.context.scene.world.cycles_visibility.diffuse = False
@@ -118,15 +122,15 @@ class AddBSLight(bpy.types.Operator):
     bl_label = "Add Studio Light"
     bl_description = "Add a new light to studio"
     bl_options = {"REGISTER", "UNDO"}
-    
+
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
-    
+
     def execute(self, context):
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
-        
+
         scene = context.scene
         lls_collection, profile_collection, profile, handle = llscol_profilecol_profile_handle(context)
 
@@ -134,24 +138,24 @@ class AddBSLight(bpy.types.Operator):
         # load a single scene we know the name of.
         with bpy.data.libraries.load(filepath) as (data_from, data_to):
             data_to.collections = ["LLS_Light"]
-            
+
         for collection in data_to.collections:
             if collection is not None:
                 profile_collection.children.link(collection)
                 new_objects = collection.objects
                 for ob in new_objects:
                     ob.use_fake_user = True
-                
+
                 llslight = [l for l in new_objects if l.name.startswith('LLS_LIGHT')][0]
-                llslight.parent = profile 
-                
+                llslight.parent = profile
+
                 bpy.ops.object.select_all(action='DESELECT')
                 light = [p for p in new_objects if p.name.startswith('LLS_LIGHT_MESH')][0]
                 light.select_set(True)
                 context.view_layer.objects.active = light
-        
+
         #####
-        
+
         c = light.constraints.new('COPY_LOCATION')
         c.target = handle
         c.use_x = True
@@ -160,16 +164,16 @@ class AddBSLight(bpy.types.Operator):
         c.use_offset = True
         # scene.frame_current = bpy.context.scene.frame_current # refresh hack
         # refreshMaterials()
-        
+
         operators.update()
         return {"FINISHED"}
-    
+
 class DeleteBSLight(bpy.types.Operator):
     bl_idname = "scene.delete_leomoon_studio_light"
     bl_label = "Delete Studio Light"
     bl_description = "Delete selected light from studio"
     bl_options = {"REGISTER", "UNDO"}
-    
+
     @classmethod
     def poll(cls, context):
         light = context.active_object
@@ -188,14 +192,14 @@ class DeleteBSLight(bpy.types.Operator):
             if collection.name.startswith('LLS_Light'):
                 bpy.ops.object.delete({"selected_objects": collection.objects}, use_global=True)
                 bpy.data.collections.remove(collection)
-                
+
         operators.update()
         return {"FINISHED"}
-    
+
     def invoke(self, context, event):
         wm = context.window_manager
         return wm.invoke_props_dialog(self)
-    
+
     def draw(self, context):
         layout = self.layout
         col = layout.column(align=True)
@@ -220,7 +224,7 @@ class BUILTIN_KSI_LightStudio(bpy.types.KeyingSetInfo):
         lls_collection = get_collection(id_block)
         light_mesh = [m for m in lls_collection.objects if m.name.startswith("LLS_LIGHT_MESH")][0]
         lls_actuator = light_mesh.parent
-        
+
         ks.paths.add(light_mesh, "location", index=0, group_method='KEYINGSET')
         ks.paths.add(light_mesh, "rotation_euler", index=0, group_method='KEYINGSET')
         ks.paths.add(light_mesh, "scale", group_method='KEYINGSET')
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 0a25728..c0c4fd3 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -1,6 +1,6 @@
 import bpy
 from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProperty, EnumProperty
-import os
+import os, sys, subprocess
 from . common import *
 from itertools import chain
 from . operators.modal import close_control_panel
@@ -11,7 +11,7 @@ class ListItem(bpy.types.PropertyGroup):
     """ Group of properties representing an item in the list """
     def update_name(self, context):
         print("{} : {}".format(repr(self.name), repr(context)))
-                
+
     name: StringProperty(
             name="Profile Name",
             default="Untitled")
@@ -20,7 +20,7 @@ class ListItem(bpy.types.PropertyGroup):
             name="Name of Empty that holds the profile",
             description="",
             default="")
-            
+
 class LLS_UL_List(bpy.types.UIList):
     def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
         custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.LLStudio.list_index else 'LIGHT'
@@ -32,14 +32,14 @@ class LLS_UL_List(bpy.types.UIList):
         elif self.layout_type in {'GRID'}:
             layout.alignment = 'CENTER'
             layout.label("", icon = custom_icon)
-            
-            
+
+
 class LIST_OT_NewItem(bpy.types.Operator):
 
     bl_idname = "lls_list.new_profile"
     bl_label = "Add a new profile"
     bl_options = {"INTERNAL"}
-    
+
     handle: BoolProperty(default=True)
 
     def execute(self, context):
@@ -59,28 +59,28 @@ class LIST_OT_NewItem(bpy.types.Operator):
                 id = int(id)
             except ValueError:
                 continue
-            
+
             if id > idx: idx = id
-            
+
         item.name = 'Profile '+str(idx+1)
-        
+
         ''' Add Hierarchy stuff '''
         # before
         A = set(bpy.data.objects[:])
-        
+
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
         bpy.ops.wm.append(filepath=_+'LLS3.blend'+_+'Object'+_,
             directory=os.path.join(dir,"LLS3.blend"+_+"Object"+_),
             filename="LLS_PROFILE.000",
             active_collection=True)
-        
+
         # after operation
         B = set(bpy.data.objects[:])
 
         # whats the difference
         profile = (A ^ B).pop()
-        
+
         profile.parent = [ob for ob in context.scene.objects if ob.name.startswith('LEOMOON_LIGHT_STUDIO')][0]
         profile.use_fake_user = True
         profile_collection = bpy.data.collections.new(profile.name)
@@ -88,9 +88,9 @@ class LIST_OT_NewItem(bpy.types.Operator):
         lls_collection = [c for c in context.scene.collection.children if c.name.startswith('LLS')][0]
         lls_collection.children.link(profile_collection)
         replace_link(profile, profile.name)
-        
+
         item.empty_name = profile.name
-        
+
         handle = None
         if self.handle:
             bpy.ops.object.empty_add()
@@ -101,31 +101,31 @@ class LIST_OT_NewItem(bpy.types.Operator):
             handle.protected = True
             handle.use_fake_user = True
             replace_link(handle, profile.name)
-        
+
         props.last_empty = profile.name
         props.list_index = len(props.profile_list)-1
 
         return{'FINISHED'}
 
 class LIST_OT_DeleteItem(bpy.types.Operator):
- 
+
     bl_idname = "lls_list.delete_profile"
     bl_label = "Delete the selected profile"
     bl_options = {"INTERNAL"}
- 
+
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
         return len(context.scene.LLStudio.profile_list)
- 
+
     def execute(self, context):
         props = context.scene.LLStudio
         index = props.list_index
- 
+
         props.profile_list.remove(index)
-        
+
         ''' Delete/Switch Hierarchy stuff '''
-        #delete objects from current profile           
+        #delete objects from current profile
         obsToRemove = family(context.scene.objects[props.last_empty])
         collectionsToRemove = set()
         for ob in obsToRemove:
@@ -135,23 +135,23 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
         for c in collectionsToRemove:
             if c.name.startswith('LLS_'):
                 bpy.data.collections.remove(c)
-        
+
         # update index
         if index > 0:
             index = index - 1
         props.list_index = index
- 
+
         return{'FINISHED'}
-    
+
 def duplicate_collection(collection, parent_collection):
     new_collection = bpy.data.collections.new(collection.name)
-    
+
     new_names = {}
     matrix_data = {}
-    
+
     for obj in collection.objects:
         new_obj = obj.copy()
-        
+
         new_names[obj.name] = new_obj
         matrix_data[new_obj.name] = {
             "matrix_basis": obj.matrix_basis.copy(),
@@ -159,12 +159,12 @@ def duplicate_collection(collection, parent_collection):
             "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
             "matrix_world": obj.matrix_world.copy()
             }
-        
+
         if new_obj.data:
             new_obj.data = obj.data.copy()
         new_obj.parent = obj.parent
         new_collection.objects.link(new_obj)
-    
+
     for obj in new_collection.objects:
         if obj.parent:
             if obj.parent.name in new_names:
@@ -173,8 +173,8 @@ def duplicate_collection(collection, parent_collection):
             #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
             obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
             #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
-    
-    
+
+
     if parent_collection:
         parent_collection.children.link(new_collection)
 
@@ -183,15 +183,15 @@ def duplicate_collection(collection, parent_collection):
 
     while len(iter_list) > 0:
         new_iter_list = []
-        
+
         for iter in iter_list:
             for collection in iter:
-            
+
                 new_collection = bpy.data.collections.new(collection.name)
-                
+
                 for obj in collection.objects:
                     new_obj = obj.copy()
-                    
+
                     new_names[obj.name] = new_obj
                     matrix_data[new_obj.name] = {
                         "matrix_basis": obj.matrix_basis.copy(),
@@ -199,12 +199,12 @@ def duplicate_collection(collection, parent_collection):
                         "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
                         "matrix_world": obj.matrix_world.copy()
                         }
-                    
+
                     if new_obj.data:
                         new_obj.data = obj.data.copy()
                     new_obj.parent = obj.parent
                     new_collection.objects.link(new_obj)
-                    
+
                 for obj in new_collection.objects:
                     if obj.parent:
                         obj.parent = new_names[obj.parent.name]
@@ -212,9 +212,9 @@ def duplicate_collection(collection, parent_collection):
                         #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
                         obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
                         #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
-                    
+
                 parent_collection.children.link(new_collection)
-                
+
                 if len(collection.children) > 0:
                     new_iter_list.append(collection.children)
 
@@ -236,7 +236,7 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         props = context.scene.LLStudio
         list = props.profile_list
         index = props.list_index
-        
+
         scene = context.scene
 
         lls_collection, profile_collection = llscol_profilecol(context)
@@ -244,7 +244,7 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         profile_copy = duplicate_collection(profile_collection, None)
         profile = [ob for ob in profile_copy.objects if ob.name.startswith('LLS_PROFILE')][0]
         handle = [ob for ob in profile.children if ob.name.startswith('LLS_HANDLE')][0]
-        
+
         for l in [lm for lc in profile_copy.children if lc.name.startswith('LLS_Light') for lm in lc.objects if lm.name.startswith('LLS_LIGHT_MESH')]:
             l.constraints['Copy Location'].target = handle
 
@@ -257,11 +257,11 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         while lastItemId > props.list_index+1:
             list.move(lastItemId-1, lastItemId)
             lastItemId -= 1
-        
+
         return{'FINISHED'}
-    
-    
- 
+
+
+
 class LIST_OT_MoveItem(bpy.types.Operator):
 
     bl_idname = "lls_list.move_profile"
@@ -315,31 +315,31 @@ class LIST_OT_MoveItem(bpy.types.Operator):
 
 def update_list_index(self, context):
     props = context.scene.LLStudio
-    
+
     if len(props.profile_list) == 0: return
-        
+
     selected_profile = props.profile_list[self.list_index]
-    
+
     if selected_profile.empty_name == props.last_empty: return
 
     print('Index update {}'.format(self.list_index))
-        
+
     #unlink current profile
     lls_collection = get_lls_collection(context)
     profile_collection = [c for c in lls_collection.children if c.name.startswith('LLS_PROFILE')]
     profile_collection = profile_collection[0] if profile_collection else None
     if profile_collection:
         lls_collection.children.unlink(profile_collection)
-        
+
     #link selected profile
     lls_collection.children.link(bpy.data.collections[selected_profile.empty_name])
-    
+
     props.last_empty = selected_profile.empty_name
 
     from . operators.modal import update_light_sets, panel_global
     if panel_global:
         update_light_sets(panel_global, bpy.context, always=True)
-        
+
 # import/export
 import json, time
 script_file = os.path.realpath(__file__)
@@ -358,9 +358,9 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             plist[-1].name += ' {}-{:02}-{:02} {:02}:{:02}'.format(str(date.tm_year)[-2:], date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
 
         profile_empty = context.scene.objects[plist[-1].empty_name]
-        
+
         if version > 1:
-            handle = getLightHandle(profile_empty)    
+            handle = getLightHandle(profile_empty)
             handle.location.x = profile['handle_position'][0]
             handle.location.y = profile['handle_position'][1]
             handle.location.z = profile['handle_position'][2]
@@ -368,27 +368,27 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
         for light in profile["lights"]:
             # before
             A = set(profile_empty.children)
-            
+
             bpy.ops.scene.add_leomoon_studio_light()
-            
+
             # after operation
             B = set(profile_empty.children)
-            
+
             # whats the difference
             lgrp = (A ^ B).pop()
 
             actuator = [c for c in family(lgrp) if "LLS_ROTATION" in c.name][0]
             lmesh = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
             lmesh.location.x = light['radius']
-            
+
             actuator.rotation_euler.x = light['position'][0]
             actuator.rotation_euler.y = light['position'][1]
             actuator.rotation_euler.z = 0
-            
+
             lmesh.scale.x = light['scale'][0]
             lmesh.scale.y = light['scale'][1]
             lmesh.scale.z = light['scale'][2]
-            
+
             lmesh.rotation_euler.x = light['rotation']
 
             lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['Texture Switch']
@@ -417,37 +417,37 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
             # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
             # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
-            
+
             if os.path.isabs(light['tex']):
                 lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
             else:
                 lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
-                
+
 class ImportProfiles(bpy.types.Operator):
- 
+
     bl_idname = "lls_list.import_profiles"
     bl_label = "Import profiles"
     bl_description = "Import profiles from file"
     #bl_options = {"INTERNAL"}
-    
+
     filepath: bpy.props.StringProperty(default="*.lls", subtype="FILE_PATH")
- 
+
     @classmethod
     def poll(self, context):
         return True
- 
+
     def execute(self, context):
         props = context.scene.LLStudio
-        
+
         with open(self.filepath, 'r') as f:
             file = f.read()
         f.closed
-        
+
         file = json.loads(file)
         parse_profile(context, props, file["profiles"], float(file["version"]))
- 
+
         return{'FINISHED'}
-    
+
     def invoke(self, context, event):
         context.window_manager.fileselect_add(self)
         return {'RUNNING_MODAL'}
@@ -473,7 +473,7 @@ def compose_profile(list_index):
         # light['mute'] = view_layer.exclude
         texpath = lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
         light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
-        
+
         light['Texture Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
         light['Color Overlay'] = [lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0],
                                   lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1],
@@ -501,36 +501,36 @@ def compose_profile(list_index):
         # light['Falloff'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
         # light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
         # light['Half'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
-        
+
         profile_dict['lights'].append(light)
-        
+
     return profile_dict
-        
+
 class ExportProfiles(bpy.types.Operator):
- 
+
     bl_idname = "lls_list.export_profiles"
     bl_label = "Export profiles to file"
     bl_description = "Export profile(s) to file"
     #bl_options = {"INTERNAL"}
-    
+
     filepath: bpy.props.StringProperty(default="profile.lls", subtype="FILE_PATH")
     all: bpy.props.BoolProperty(default=False, name="Export All Profiles")
- 
+
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
         return len(context.scene.LLStudio.profile_list)
- 
+
     def execute(self, context):
         props = context.scene.LLStudio
         index = props.list_index
-            
+
         export_file = {}
         date = time.localtime()
         export_file['date'] = '{}-{:02}-{:02} {:02}:{:02}'.format(date.tm_year, date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
         export_file['version'] = VERSION
         profiles_to_export = export_file['profiles'] = []
-        
+
         if self.all:
             for p in range(len(props.profile_list)):
                 try:
@@ -542,77 +542,99 @@ class ExportProfiles(bpy.types.Operator):
                 profiles_to_export.append(compose_profile(index))
             except Exception:
                 self.report({'WARNING'}, 'Malformed profile %s. Omitting.' % props.profile_list[index].name)
-        
+
         with open(self.filepath, 'w') as f:
             f.write(json.dumps(export_file, indent=4))
         f.closed
-        
+
         return{'FINISHED'}
-    
+
     def invoke(self, context, event):
         self.filepath = "profile.lls"
         context.window_manager.fileselect_add(self)
         return {'RUNNING_MODAL'}
-    
+
 class FindMissingTextures(bpy.types.Operator):
- 
+
     bl_idname = "lls.find_missing_textures"
     bl_label = "Find Missing Textures"
     bl_description = "Find missing light textures"
     #bl_options = {"INTERNAL"}
-    
+
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
         return len(context.scene.LLStudio.profile_list)
- 
+
     def execute(self, context):
-        bpy.ops.file.find_missing_files(directory=os.path.join(dir, "textures_real_lights"))        
+        bpy.ops.file.find_missing_files(directory=os.path.join(dir, "textures_real_lights"))
         bpy.context.scene.frame_current = bpy.context.scene.frame_current
         return{'FINISHED'}
 
+class OpenTexturesFolder(bpy.types.Operator):
+
+    bl_idname = "lls.open_textures_folder"
+    bl_label = "Open Textures Folder"
+    bl_description = "Open textures folder"
+    #bl_options = {"INTERNAL"}
+
+    #@classmethod
+    #def poll(self, context):
+    #    """ Enable if there's something in the list """
+    #    return len(context.scene.LLStudio.profile_list)
+
+    def execute(self, context):
+        path = os.path.join(dir, "textures_real_lights")
+        if sys.platform == 'darwin':
+            subprocess.Popen(["open", path])
+        elif sys.platform == 'linux2':
+            subprocess.Popen(["xdg-open", path])
+        elif sys.platform == 'win32':
+            subprocess.Popen(["explorer", path])
+        return{'FINISHED'}
+
 class CopyProfileToScene(bpy.types.Operator):
     """ Copy Light Profile to Scene """
- 
+
     bl_idname = "lls_list.copy_profile_to_scene"
     bl_label = "Copy Profile to Scene"
     bl_property = "sceneprop"
-    
+
     def get_scenes(self, context):
         return ((s.name, s.name, "Scene name") for i,s in enumerate(bpy.data.scenes))#global_vars["scenes"]
-    
+
     sceneprop: EnumProperty(items = get_scenes)
-    
+
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
         return len(context.scene.LLStudio.profile_list)
- 
+
     def execute(self, context):
         props = context.scene.LLStudio
         index = props.list_index
-        
+
         profiles = [compose_profile(index),]
-        
+
         context.window.scene = bpy.data.scenes[self.sceneprop]
         context.scene.render.engine = 'CYCLES'
         if not context.scene.LLStudio.initialized:
             bpy.ops.scene.create_leomoon_light_studio()
-        
+
         parse_profile(context, context.scene.LLStudio, profiles, internal_copy=True)
 
         close_control_panel()
-        
+
         return{'FINISHED'}
-        
+
     def invoke(self, context, event):
         wm = context.window_manager
         wm.invoke_search_popup(self)
         return {'FINISHED'}
-    
+
 
 class CopyProfileMenu(bpy.types.Operator):
- 
+
     bl_idname = "lls_list.copy_profile_menu"
     bl_label = "Copy selected profile"
 
@@ -620,7 +642,7 @@ class CopyProfileMenu(bpy.types.Operator):
     def poll(self, context):
         """ Enable if there's something in the list """
         return len(context.scene.LLStudio.profile_list)
-    
+
     def execute(self, context):
         wm = context.window_manager
         def draw(self, context):

commit 7754a43bde6174eb133af2b32474ecfe6e1379f5
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri May 8 11:22:43 2020 -0700

    exludeing skrypt folder

diff --git a/.gitignore b/.gitignore
index 894a44c..34ea7d0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,7 @@ __pycache__/
 *.so
 
 # Distribution / packaging
+skrypt/
 .Python
 build/
 develop-eggs/

commit 9f43241891eff5f07e8d46ad7dc12612d3f7b297
Merge: bb28f41 81baef5
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri May 8 11:18:55 2020 -0700

    Merge pull request #25 from StyriamMZ/master
    
    2.5.1

commit 81baef5a9fef95a9005f74ae44f7f97796d10dea
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri May 8 19:57:11 2020 +0200

    2.5.1

diff --git a/skrypt/leomoon_lightstudio.zip.001 b/skrypt/leomoon_lightstudio.zip.001
new file mode 100644
index 0000000..56fc9e3
Binary files /dev/null and b/skrypt/leomoon_lightstudio.zip.001 differ
diff --git a/skrypt/leomoon_lightstudio.zip.002 b/skrypt/leomoon_lightstudio.zip.002
new file mode 100644
index 0000000..38ef6ae
Binary files /dev/null and b/skrypt/leomoon_lightstudio.zip.002 differ
diff --git a/skrypt/leomoon_lightstudio/BLS3.blend b/skrypt/leomoon_lightstudio/BLS3.blend
new file mode 100644
index 0000000..5939dec
Binary files /dev/null and b/skrypt/leomoon_lightstudio/BLS3.blend differ
diff --git a/skrypt/leomoon_lightstudio/__init__.py b/skrypt/leomoon_lightstudio/__init__.py
new file mode 100644
index 0000000..e9b6f34
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/__init__.py
@@ -0,0 +1,40 @@
+#Created by Striam Sp. z o.o.
+
+bl_info = {
+    "name": "LeoMoon LightStudio",
+    "description": "Easy setup for complex studio lighting",
+    "author": "LeoMoon Studios",
+    "version": (2, 5, 0),
+    "blender": (2, 80, 0),
+    "location": "View3D -> Tools -> Light Studio",
+    "wiki_url": "",
+    "category": "User Interface" }
+    
+    
+import bpy      
+
+# load and reload submodules
+##################################    
+
+from . import auto_load
+
+auto_load.init()
+
+
+# register
+################################## 
+
+from . light_operators import Blender_Light_Studio_Properties
+from . import deleteOperator
+
+def register():
+    auto_load.register()
+
+    bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
+    bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
+    deleteOperator.add_shortkeys()
+    
+
+def unregister():
+    deleteOperator.remove_shortkeys()
+    auto_load.unregister()
diff --git a/skrypt/leomoon_lightstudio/auto_load.py b/skrypt/leomoon_lightstudio/auto_load.py
new file mode 100644
index 0000000..0f930b5
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/auto_load.py
@@ -0,0 +1,184 @@
+import os
+import bpy
+import sys
+import typing
+import inspect
+import pkgutil
+import importlib
+from pathlib import Path
+
+__all__ = (
+    "init",
+    "register",
+    "unregister",
+)
+
+modules = None
+ordered_classes = None
+ignored=[]
+auto_annotations = False
+def init(ignore=[], make_annotations=False):
+    global modules
+    global ordered_classes
+    global ignored    
+    global fifo_cls
+    global auto_annotations
+
+    ignored = ignore
+    modules = get_all_submodules(Path(__file__).parent)
+    ordered_classes = get_ordered_classes_to_register(modules)
+    auto_annotations = make_annotations
+
+def register():
+    for cls in fifo_cls:
+        if auto_annotations:
+            make_annotations(cls)
+        bpy.utils.register_class(cls)
+
+    for cls in ordered_classes:
+        if cls not in fifo_cls:
+            if auto_annotations:
+                make_annotations(cls)
+            bpy.utils.register_class(cls)
+
+    for module in modules:
+        if module.__name__ == __name__:
+            continue
+        if hasattr(module, "register"):
+            module.register()
+
+def unregister():
+    for cls in reversed(ordered_classes):
+        bpy.utils.unregister_class(cls)
+
+    for cls in reversed(fifo_cls):
+        if cls not in ordered_classes:
+            bpy.utils.unregister_class(cls)
+
+    for module in modules:
+        if module.__name__ == __name__:
+            continue
+        if hasattr(module, "unregister"):
+            module.unregister()
+
+
+# Import modules
+#################################################
+
+def get_all_submodules(directory):
+    return list(iter_submodules(directory, directory.name))
+
+def iter_submodules(path, package_name):
+    global ignored
+    for name in sorted(iter_submodule_names(path)):
+        if name in ignored:#("addon_updater", "addon_updater_ops"):
+            continue
+        yield importlib.import_module("." + name, package_name)
+
+def iter_submodule_names(path, root=""):
+    for _, module_name, is_package in pkgutil.iter_modules([str(path)]):
+        if is_package:
+            sub_path = path / module_name
+            sub_root = root + module_name + "."
+            yield from iter_submodule_names(sub_path, sub_root)
+            yield root + module_name
+        else:
+            yield root + module_name
+
+
+# Find classes to register
+#################################################
+
+def get_ordered_classes_to_register(modules):
+    return toposort(get_register_deps_dict(modules))
+
+def get_register_deps_dict(modules):
+    deps_dict = {}
+    classes_to_register = set(iter_classes_to_register(modules))
+    for cls in classes_to_register:
+        deps_dict[cls] = set(iter_own_register_deps(cls, classes_to_register))
+    return deps_dict
+
+def iter_own_register_deps(cls, own_classes):
+    yield from (dep for dep in iter_register_deps(cls) if dep in own_classes)
+
+def iter_register_deps(cls):
+    for value in typing.get_type_hints(cls, {}, {}).values():
+        dependency = get_dependency_from_annotation(value)
+        if dependency is not None:
+            yield dependency
+
+def get_dependency_from_annotation(value):
+    if isinstance(value, tuple) and len(value) == 2:
+        if value[0] in (bpy.props.PointerProperty, bpy.props.CollectionProperty):
+            return value[1]["type"]
+    return None
+
+def iter_classes_to_register(modules):
+    base_types = get_register_base_types()
+    for cls in get_classes_in_modules(modules):
+        if any(base in base_types for base in cls.__bases__):
+            if not getattr(cls, "is_registered", False):
+                yield cls
+
+def get_classes_in_modules(modules):
+    classes = set()
+    for module in modules:
+        for cls in iter_classes_in_module(module):
+            classes.add(cls)
+    return classes
+
+def iter_classes_in_module(module):
+    for value in module.__dict__.values():
+        if inspect.isclass(value):
+            yield value
+
+def get_register_base_types():
+    return set(getattr(bpy.types, name) for name in [
+        "Panel", "Operator", "PropertyGroup",
+        "AddonPreferences", "Header", "Menu",
+        "Node", "NodeSocket", "NodeTree",
+        "UIList", "RenderEngine", "KeyingSetInfo"
+    ])
+
+
+# Find order to register to solve dependencies
+#################################################
+
+def toposort(deps_dict):
+    sorted_list = []
+    sorted_values = set()
+    while len(deps_dict) > 0:
+        unsorted = []
+        for value, deps in deps_dict.items():
+            if len(deps) == 0:
+                sorted_list.append(value)
+                sorted_values.add(value)
+            else:
+                unsorted.append(value)
+        deps_dict = {value : deps_dict[value] - sorted_values for value in unsorted}
+    return sorted_list
+
+
+# Force register classes at FIFO order (decorator).
+#################################################
+# Use for ordering in nesting cases
+fifo_cls = []
+def force_register(cls):
+    global fifo_cls
+    fifo_cls.append(cls)
+    return cls
+
+def make_annotations(cls):
+    """Converts class fields to annotations if running with Blender 2.8"""
+    if bpy.app.version < (2, 80):
+        return cls
+    bl_props = {k: v for k, v in cls.__dict__.items() if isinstance(v, tuple)}
+    if bl_props:
+        if '__annotations__' not in cls.__dict__:
+            setattr(cls, '__annotations__', {})
+        annotations = cls.__dict__['__annotations__']
+        for k, v in bl_props.items():
+            annotations[k] = v
+            delattr(cls, k)
+    return cls
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/common.py b/skrypt/leomoon_lightstudio/common.py
new file mode 100644
index 0000000..67c38d9
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/common.py
@@ -0,0 +1,124 @@
+import bpy
+
+def replace_link(object, collection_name):
+    if isinstance(object, bpy.types.Collection):
+        bpy.context.scene.collection.children.unlink(bpy.context.scene.collection.children[object.name])
+        bpy.data.collections[collection_name].children.link(object)
+    else:
+        object.users_collection[0].objects.unlink(object)
+        bpy.data.collections[collection_name].objects.link(object)
+
+def get_collection(object):
+    return [c for c in object.users_collection if c.name.startswith('BLS')][0]
+
+def get_bls_collection(context):
+    return [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+
+def blscol_profilecol_profile_handle(context):
+    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
+    profile = [ob for ob in profile_collection.objects if ob.name.startswith('BLS_PROFILE')][0]
+    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
+    return bls_collection, profile_collection, profile, handle
+
+def blscol_profilecol(context):
+    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
+    return bls_collection, profile_collection
+
+def find_view_layer(collection, layer_collection):
+    idx = layer_collection.children.find(collection.name)
+    if idx >= 0:
+        return layer_collection.children[idx]
+    else:
+        for vc in layer_collection.children:
+            rcol = find_view_layer(collection, layer_collection=vc)
+            if rcol:
+                return rcol
+            
+def get_view_layers(layer_collection):
+    for lc in layer_collection.children:
+        yield lc
+        for clc in get_view_layers(layer_collection=lc):
+            yield clc
+            
+def isFamily(ob=None):
+    if not ob:
+        ob = bpy.context.scene.objects.active
+
+    if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
+    if not ob.name.startswith('BLS_'): return False
+    while ob.parent:
+        ob = ob.parent
+        if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
+    
+    return False
+
+def family(object):
+    ''' Object + Grand children without ancestors '''
+    family = [object.children[:]+(object,)]
+      
+    def rec(object, family):
+        family[0] += object.children
+        for ob in object.children:
+            rec(ob, family)
+        
+    for ob in object.children:
+        rec(ob, family)
+        
+    return family.pop()
+
+def findLightGrp(ob):
+    while ob and ob.parent:
+        ob = ob.parent
+        if ob.name.startswith('BLS_LIGHT.'): return ob
+    return None
+
+def getLightMesh():
+    #obs = bpy.context.scene.objects
+    #lightGrp = obs.active
+    #light_no = lightGrp.name.split('.')[1]
+    #return obs[obs.find('BLS_LIGHT_MESH.'+light_no)]
+
+    lg = findLightGrp(bpy.context.active_object)
+    lm = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH")]
+    return lm[0] if len(lm) else None
+
+def getLightController():
+    obs = bpy.context.view_layer.objects
+    lightGrp = obs.active
+    light_no = lightGrp.name.split('.')[1]
+    return obs[obs.find('BLS_CONTROLLER.'+light_no)]
+
+
+def findLightProfile(ob):
+    if ob.name.startswith('BLS_PROFILE'):
+        return ob
+    
+    while ob.parent:
+        ob = ob.parent
+        if ob.name.startswith('BLS_PROFILE'): return ob
+        
+    return None
+
+def getLightHandle(ob=None):
+    if not ob:
+        ob = bpy.context.scene.objects.active
+
+    p = findLightProfile(ob)
+    if not p:
+        return None
+    
+    h = [h for h in p.children if h.name.startswith('BLS_HANDLE')]
+    if len(h):
+        return h[0]
+    else:
+        return None
+
+def refreshMaterials():
+    #controllers = [ob for ob in family(findLightGrp(context.active_object).parent) if ob.name.startswith('BLS_CONTROLLER.')]
+    controllers = (ob for ob in bpy.context.scene.objects if ob.name.startswith('BLS_CONTROLLER.') and isFamily(ob))
+    for cntrl in controllers:
+        mat = [m for m in cntrl.data.materials if m.name.startswith('BLS_icon_ctrl')][0]
+        mixNode = mat.node_tree.nodes['Mix Shader'].inputs['Fac']
+        mixNode.default_value = mixNode.default_value
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/deleteOperator.py b/skrypt/leomoon_lightstudio/deleteOperator.py
new file mode 100644
index 0000000..f525d96
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/deleteOperator.py
@@ -0,0 +1,63 @@
+import bpy
+from bpy.props import BoolProperty
+from . common import findLightGrp
+
+class DeleteOperator(bpy.types.Operator):
+    """ Custom delete """
+    bl_idname = "object.delete_custom" 
+    bl_label = "Custom Delete"
+    bl_options = {'REGISTER', 'UNDO'}
+
+    use_global: BoolProperty(default = False)
+
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
+    
+    def execute(self, context):
+        protected_groups = [findLightGrp(ob) for ob in context.selected_objects if ob.protected]
+        protected_objects = (ob for ob in context.selected_objects if ob.protected)
+        
+        for obj in protected_objects:
+            context.view_layer.objects.active = obj
+            if hasattr(obj, 'use_fake_user'):
+                obj.use_fake_user = False
+            ret = bpy.ops.scene.delete_blender_studio_light()
+            if 'CANCELLED' in ret:
+                self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
+        
+        bpy.ops.object.delete(use_global=self.use_global)
+
+        return {'FINISHED'}
+
+    # def invoke(self, context, event):
+    #     wm = context.window_manager
+    #     return wm.invoke_confirm(self, event)
+        
+addon_keymaps = []
+def add_shortkeys():       
+    wm = bpy.context.window_manager
+    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
+    addon_kmi.properties.use_global = False
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
+    addon_kmi.shift = True
+    addon_kmi.properties.use_global = True
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
+    addon_kmi.properties.use_global = False
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
+    addon_kmi.shift = True
+    addon_kmi.properties.use_global = True
+    
+    addon_keymaps.append(addon_km)
+
+def remove_shortkeys():
+    wm = bpy.context.window_manager
+    for km in addon_keymaps:
+        wm.keyconfigs.addon.keymaps.remove(km)
+        
+    addon_keymaps.clear()
diff --git a/skrypt/leomoon_lightstudio/extensions_framework/util.py b/skrypt/leomoon_lightstudio/extensions_framework/util.py
new file mode 100644
index 0000000..2ad450b
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/extensions_framework/util.py
@@ -0,0 +1,270 @@
+# -*- coding: utf-8 -*-
+#
+# ***** BEGIN GPL LICENSE BLOCK *****
+#
+# --------------------------------------------------------------------------
+# Blender 2.5 Extensions Framework
+# --------------------------------------------------------------------------
+#
+# Authors:
+# Doug Hammond
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#
+# ***** END GPL LICENCE BLOCK *****
+#
+import configparser
+import datetime
+import os
+import tempfile
+import threading
+
+import bpy
+
+"""List of possibly appropriate paths to load/save addon config from/to"""
+config_paths = []
+if bpy.utils.user_resource('CONFIG', '') != "": config_paths.append(bpy.utils.user_resource('CONFIG', '', create=True))
+if bpy.utils.user_resource('SCRIPTS', '') != "": config_paths.append(bpy.utils.user_resource('SCRIPTS', '', create=True))
+# want to scan other script paths in reverse order, since the user path comes last
+sp = [p for p in bpy.utils.script_paths() if p != '']
+sp.reverse()
+config_paths.extend(sp)
+
+"""This path is set at the start of export, so that calls to
+path_relative_to_export() can make all exported paths relative to
+this one.
+"""
+export_path = '';
+
+def path_relative_to_export(p):
+    """Return a path that is relative to the export path"""
+    global export_path
+    p = filesystem_path(p)
+    ep = os.path.dirname(export_path)
+
+    if os.sys.platform[:3] == "win":
+        # Prevent an error whereby python thinks C: and c: are different drives
+        if p[1] == ':': p = p[0].lower() + p[1:]
+        if ep[1] == ':': ep = ep[0].lower() + ep[1:]
+
+    try:
+        relp = os.path.relpath(p, ep)
+    except ValueError: # path on different drive on windows
+        relp = p
+
+    return relp.replace('\\', '/')
+
+def filesystem_path(p):
+    """Resolve a relative Blender path to a real filesystem path"""
+    if p.startswith('//'):
+        pout = bpy.path.abspath(p)
+    else:
+        pout = os.path.realpath(p)
+
+    return pout.replace('\\', '/')
+
+# TODO: - somehow specify TYPES to get/set from config
+
+def find_config_value(module, section, key, default):
+    """Attempt to find the configuration value specified by string key
+    in the specified section of module's configuration file. If it is
+    not found, return default.
+
+    """
+    global config_paths
+    fc = []
+    for p in config_paths:
+        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
+            fc.append( '/'.join([p, '%s.cfg' % module]))
+
+    if len(fc) < 1:
+        print('Cannot find %s config file path' % module)
+        return default
+
+    cp = configparser.SafeConfigParser()
+
+    cfg_files = cp.read(fc)
+    if len(cfg_files) > 0:
+        try:
+            val = cp.get(section, key)
+            if val == 'true':
+                return True
+            elif val == 'false':
+                return False
+            else:
+                return val
+        except:
+            return default
+    else:
+        return default
+
+def write_config_value(module, section, key, value):
+    """Attempt to write the configuration value specified by string key
+    in the specified section of module's configuration file.
+
+    """
+    global config_paths
+    fc = []
+    for p in config_paths:
+        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
+            fc.append( '/'.join([p, '%s.cfg' % module]))
+
+    if len(fc) < 1:
+        raise Exception('Cannot find a writable path to store %s config file' %
+            module)
+
+    cp = configparser.SafeConfigParser()
+
+    cfg_files = cp.read(fc)
+
+    if not cp.has_section(section):
+        cp.add_section(section)
+
+    if value == True:
+        cp.set(section, key, 'true')
+    elif value == False:
+        cp.set(section, key, 'false')
+    else:
+        cp.set(section, key, value)
+
+    if len(cfg_files) < 1:
+        cfg_files = fc
+
+    fh=open(cfg_files[0],'w')
+    cp.write(fh)
+    fh.close()
+
+    return True
+
+def scene_filename():
+    """Construct a safe scene filename, using 'untitled' instead of ''"""
+    filename = os.path.splitext(os.path.basename(bpy.data.filepath))[0]
+    if filename == '':
+        filename = 'untitled'
+    return bpy.path.clean_name(filename)
+
+def temp_directory():
+    """Return the system temp directory"""
+    return tempfile.gettempdir()
+
+def temp_file(ext='tmp'):
+    """Get a temporary filename with the given extension. This function
+    will actually attempt to create the file."""
+    tf, fn = tempfile.mkstemp(suffix='.%s'%ext)
+    os.close(tf)
+    return fn
+
+class TimerThread(threading.Thread):
+    """Periodically call self.kick(). The period of time in seconds
+    between calling is given by self.KICK_PERIOD, and the first call
+    may be delayed by setting self.STARTUP_DELAY, also in seconds.
+    self.kick() will continue to be called at regular intervals until
+    self.stop() is called. Since this is a thread, calling self.join()
+    may be wise after calling self.stop() if self.kick() is performing
+    a task necessary for the continuation of the program.
+    The object that creates this TimerThread may pass into it data
+    needed during self.kick() as a dict LocalStorage in __init__().
+
+    """
+    STARTUP_DELAY = 0
+    KICK_PERIOD = 8
+
+    active = True
+    timer = None
+
+    LocalStorage = None
+
+    def __init__(self, LocalStorage=dict()):
+        threading.Thread.__init__(self)
+        self.LocalStorage = LocalStorage
+
+    def set_kick_period(self, period):
+        """Adjust the KICK_PERIOD between __init__() and start()"""
+        self.KICK_PERIOD = period + self.STARTUP_DELAY
+
+    def stop(self):
+        """Stop this timer. This method does not join()"""
+        self.active = False
+        if self.timer is not None:
+            self.timer.cancel()
+
+    def run(self):
+        """Timed Thread loop"""
+        while self.active:
+            self.timer = threading.Timer(self.KICK_PERIOD, self.kick_caller)
+            self.timer.start()
+            if self.timer.isAlive(): self.timer.join()
+
+    def kick_caller(self):
+        """Intermediary between the kick-wait-loop and kick to allow
+        adjustment of the first KICK_PERIOD by STARTUP_DELAY
+
+        """
+        if self.STARTUP_DELAY > 0:
+            self.KICK_PERIOD -= self.STARTUP_DELAY
+            self.STARTUP_DELAY = 0
+
+        self.kick()
+
+    def kick(self):
+        """Sub-classes do their work here"""
+        pass
+
+def format_elapsed_time(t):
+    """Format a duration in seconds as an HH:MM:SS format time"""
+
+    td = datetime.timedelta(seconds=t)
+    min = td.days*1440  + td.seconds/60.0
+    hrs = td.days*24    + td.seconds/3600.0
+
+    return '%i:%02i:%02i' % (hrs, min%60, td.seconds%60)
+
+def getSequenceTexturePath(it, f):
+    import bpy.path
+    import os.path
+    import string
+    fd = it.image_user.frame_duration
+    fs = it.image_user.frame_start
+    fo = it.image_user.frame_offset
+    cyclic = it.image_user.use_cyclic
+    ext = os.path.splitext(it.image.filepath)[-1]
+    fb = bpy.path.display_name_from_filepath(it.image.filepath)
+    dn = os.path.dirname(it.image.filepath)
+    rf = fb[::-1]
+    nl = 0
+    for i in range (len(fb)):
+        if rf[i] in string.digits:
+            nl += 1
+        else:
+            break
+    head = fb[:len(fb)-nl]
+    fnum = f
+    if fs != 1:
+        if f != fs:
+            fnum -= (fs-1)
+        elif f == fs:
+            fnum = 1
+    if fnum <= 0:
+        if cyclic:
+            fnum = fd - abs(fnum) % fd
+        else:
+            fnum = 1
+    elif fnum > fd:
+        if cyclic:
+            fnum = fnum % fd
+        else:
+            fnum = fd
+    fnum += fo
+    return dn + "/" + head + str(fnum).rjust(nl, "0") + ext
diff --git a/skrypt/leomoon_lightstudio/gui.py b/skrypt/leomoon_lightstudio/gui.py
new file mode 100644
index 0000000..9d30015
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/gui.py
@@ -0,0 +1,172 @@
+import bpy
+import os
+from . common import getLightMesh
+from . auto_load import force_register
+
+@force_register
+class BLS_PT_Studio(bpy.types.Panel):
+    bl_idname = "BLS_PT_studio"
+    bl_label = "Studio"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "UI"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'    
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        if not context.scene.BLStudio.initialized: col.operator('scene.create_blender_light_studio')
+        if context.scene.BLStudio.initialized: col.operator('scene.delete_blender_light_studio')
+        col.separator()
+        col.operator('light_studio.control_panel', icon='MENU_PANEL')
+
+@force_register
+class BLS_PT_Lights(bpy.types.Panel):
+    bl_idname = "BLS_PT_lights"
+    bl_label = "Lights"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "UI"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.BLStudio.profile_list)
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        row = col.row(align=True)
+        row.operator('scene.add_blender_studio_light', text='Add Light')
+        row.operator('scene.delete_blender_studio_light', text='Delete Light')
+
+@force_register
+class BLS_PT_Selected(bpy.types.Panel):
+    bl_idname = "BLS_PT_selected"
+    bl_label = "Selected Light"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "UI"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
+    
+    def draw(self, context):
+        if context.active_object and (context.active_object.name.startswith('BLS_CONTROLLER') or context.active_object.name.startswith('BLS_LIGHT_MESH')):
+            layout = self.layout
+            wm = context.window_manager
+            
+            col = layout.column(align=True)
+            col.operator('bls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
+            
+            box = layout.box()
+            col = box.column()
+            col.template_icon_view(wm, "bls_tex_previews", show_labels=True)
+            col.label(text=os.path.splitext(wm.bls_tex_previews)[0])
+            
+            layout.separator()
+            try:
+                bls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
+                for input in bls_inputs[2:]:
+                    if input.type == "RGBA":
+                        layout.prop(input, 'default_value', text=input.name)
+                        col = layout.column(align=True)
+                    else:
+                        col.prop(input, 'default_value', text=input.name)
+            except:
+                col.label(text="BLS_light material is not valid.")
+                #import traceback
+                #traceback.print_exc()
+            col.prop(getLightMesh(), 'location', index=0) #light radius
+
+@force_register
+class BLS_PT_ProfileList(bpy.types.Panel):
+    bl_idname = "BLS_PT_profile_list"
+    bl_label = "Profiles"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "UI"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+            
+    def draw(self, context):
+        layout = self.layout
+        scene = context.scene
+        
+        props = scene.BLStudio
+        
+        row = layout.row()
+        col = row.column()
+        col.template_list("BLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
+        
+        col = row.column(align=True)
+        col.operator('bls_list.new_profile', icon='PLUS', text="")
+        col.operator('bls_list.delete_profile', icon='TRASH', text="")
+        col.operator('bls_list.copy_profile_menu', icon='DUPLICATE', text="")
+        
+        col.separator()
+        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
+        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
+
+@force_register
+class BLS_PT_ProfileImportExport(bpy.types.Panel):
+    bl_idname = "BLS_PT_profile_import_export"
+    bl_label = "Import/Export"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "UI"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+            
+    def draw(self, context):
+        layout = self.layout
+        scene = context.scene
+              
+        col = layout.column(align=True)
+        col.operator('bls_list.export_profiles', text="Export Selected Profile")
+        col.operator('bls_list.export_profiles', text="Export All Profiles").all=True
+        col.operator('bls_list.import_profiles')
+
+from . import bl_info
+@force_register
+class BLS_PT_Misc(bpy.types.Panel):
+    bl_idname = "BLS_PT_misc"
+    bl_label = "Misc"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "UI"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.BLStudio.initialized
+                
+    def draw(self, context):
+        layout = self.layout
+        scene = context.scene
+        
+        props = scene.BLStudio
+              
+        col = layout.column(align=True)
+        col.operator('bls.find_missing_textures')
+        col.operator('bls.bls_keyingset')
+        if context.scene.keying_sets.active and context.scene.keying_sets.active.bl_idname == "BUILTIN_KSI_LightStudio":
+            box = col.box()
+            box.label(text="Keying Set is active")
+
+class BLSKeyingSet(bpy.types.Operator):
+    """Activate Light Studio Keying Set to animate lights"""
+    bl_idname = "bls.bls_keyingset"
+    bl_description = "Activate Light Studio Keying Set to animate lights"
+    bl_label = "Light Studio Keying Set"
+    bl_options = {"INTERNAL", "UNDO"}
+
+    def execute(self, context):
+        context.scene.keying_sets.active = [k for k in context.scene.keying_sets_all if k.bl_idname == "BUILTIN_KSI_LightStudio"][0]
+        return {"FINISHED"}
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_brush.py b/skrypt/leomoon_lightstudio/light_brush.py
new file mode 100644
index 0000000..c30180a
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/light_brush.py
@@ -0,0 +1,168 @@
+import bpy
+from bpy_extras import view3d_utils
+from math import *
+from mathutils.geometry import intersect_line_sphere
+from mathutils import Vector
+from bpy.props import *
+from . common import isFamily, family, findLightGrp, getLightMesh, getLightController
+
+
+           
+def raycast(context, event, diff):
+    """Run this function on left mouse, execute the ray cast"""
+    # get the context arguments
+    scene = context.scene
+    region = context.region
+    rv3d = context.region_data
+    coord = event.mouse_region_x, event.mouse_region_y
+
+    # get the ray from the viewport and mouse
+    view_vector = view3d_utils.region_2d_to_vector_3d(region, rv3d, coord)
+    ray_origin = view3d_utils.region_2d_to_origin_3d(region, rv3d, coord)
+    
+    ray_target = ray_origin + view_vector
+    
+    def visible_objects_and_duplis():
+        """Loop over (object, matrix) pairs (mesh only)"""
+
+        for obj in context.visible_objects:
+            if isFamily(obj):
+                continue
+            
+            if obj.type == 'MESH':
+                yield (obj, obj.matrix_world.copy())
+
+            if obj.instance_type != 'NONE':
+                depsgraph = context.depsgraph
+                for dup in depsgraph.object_instances:
+                    obj_dupli = dup.object
+                    if obj_dupli.type == 'MESH':
+                        yield (obj_dupli, dup.matrix_world.copy())
+
+    def obj_ray_cast(obj, matrix):
+        """Wrapper for ray casting that moves the ray into object space"""
+
+        # get the ray relative to the object
+        matrix_inv = matrix.inverted()
+        ray_origin_obj = matrix_inv @ ray_origin
+        ray_target_obj = matrix_inv @ ray_target
+        ray_direction_obj = ray_target_obj - ray_origin_obj
+
+        # cast the ray
+        success, location, normal, face_index = obj.ray_cast(ray_origin_obj, ray_direction_obj)
+
+        if success:
+            return location, normal, face_index
+        else:
+            return None, None, None
+    
+    # cast rays and find the closest object
+    best_length_squared = -1.0
+    best_obj = None
+    normal = None
+    location = None
+
+    for obj, matrix in visible_objects_and_duplis():
+        if obj.type == 'MESH':
+            hit, hit_normal, face_index = obj_ray_cast(obj, matrix)
+            if hit is not None:
+                hit_world = matrix @ hit
+                length_squared = (hit_world - ray_origin).length_squared
+                if best_obj is None or length_squared < best_length_squared:
+                    best_length_squared = length_squared
+                    best_obj = obj
+                    normal = hit_normal # local space
+                    location = hit_world
+                    
+
+    if best_obj is None:
+        return {'RUNNING_MODAL'}
+    
+    # convert normal from local space to global
+    matrix = best_obj.matrix_world
+    matrix_new = matrix.to_3x3().inverted().transposed()
+    normal = matrix_new @ normal
+    normal.normalize()
+    
+    #####
+    profile = findLightGrp(context.active_object).parent
+    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
+    lightmesh = getLightMesh()
+    actuator = lightmesh.parent
+    position = intersect_line_sphere(
+        location - handle.location,
+        (normal if diff else view_vector.reflect(normal)) + location - handle.location,
+        Vector((0,0,0)),
+        lightmesh.location.x,
+        False,
+        )[0]
+    
+    
+    if not position:
+        return {'RUNNING_MODAL'}
+   
+    # ctrl x
+    x,y,z = position
+    actuator.rotation_euler.x = atan2(x, -y)
+    
+    # ctrl y
+    deg = copysign(degrees(Vector.angle(Vector((x,y,z)), Vector((x,y,0)))), z)
+    actuator.rotation_euler.y = copysign(Vector.angle(Vector((x,y,z)), Vector((x,y,0))), z)
+
+class BLSLightBrush(bpy.types.Operator):
+    """Click on object to position light and reflection"""
+    bl_idname = "bls.light_brush"
+    bl_label = "Light Brush"
+    bl_options = {"UNDO"}
+    
+    aux: BoolProperty(default=False) # is aux operator working
+    diffuse_type: BoolProperty(default=False)
+    
+    @classmethod
+    def poll(cls, context):
+        light = context.active_object
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.BLStudio.initialized and \
+               light and \
+               isFamily(light) and \
+               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+
+    def modal(self, context, event):
+        print(event.type, event.value)
+        if self.aux:
+            if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
+                self.aux = False
+            return {'RUNNING_MODAL'}
+        
+        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.diffuse_type else '[Reflection] | Normal'}")
+        
+        if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'Z', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
+            # allow navigation
+            return {'PASS_THROUGH'}
+        elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
+            context.area.header_text_set(text=None)
+            return {'FINISHED'}
+        elif event.type == 'LEFTMOUSE':
+            if event.value == 'PRESS':
+                raycast(context, event, self.diffuse_type)
+                return {'RUNNING_MODAL'}
+            elif event.value == 'RELEASE':
+                return {'PASS_THROUGH'}
+        elif event.type == 'MOUSEMOVE':
+            if event.value == 'PRESS':
+                raycast(context, event, self.diffuse_type)
+                return {'PASS_THROUGH'}
+        elif event.type == 'N' and event.value == 'PRESS':
+            self.diffuse_type = not self.diffuse_type
+
+        #return {'PASS_THROUGH'}
+        return {'RUNNING_MODAL'}
+
+    def invoke(self, context, event):
+        if context.space_data.type == 'VIEW_3D':
+            context.window_manager.modal_handler_add(self)
+            return {'RUNNING_MODAL'}
+        else:
+            self.report({'WARNING'}, "Active space must be a View3d")
+            return {'CANCELLED'}
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_operators.py b/skrypt/leomoon_lightstudio/light_operators.py
new file mode 100644
index 0000000..746c383
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/light_operators.py
@@ -0,0 +1,208 @@
+import bpy
+from bpy.props import BoolProperty, PointerProperty, FloatProperty, CollectionProperty, IntProperty, StringProperty
+from . light_profiles import ListItem, update_list_index
+from . common import *
+import os
+from . import operators
+
+_ = os.sep
+
+from . extensions_framework import util as efutil
+from . import bl_info
+    
+class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
+    initialized: BoolProperty(default = False)    
+    
+    ''' Profile List '''
+    profile_list: CollectionProperty(type = ListItem)
+    list_index: IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
+    last_empty: StringProperty(name="Name of last Empty holding profile", default="")
+    
+
+class CreateBlenderLightStudio(bpy.types.Operator):
+    bl_idname = "scene.create_blender_light_studio"
+    bl_label = "Create Light Studio"
+    bl_description = "Append Blender Light Studio to current scene"
+    bl_options = {"REGISTER"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and not context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        script_file = os.path.realpath(__file__)
+        dir = os.path.dirname(script_file)
+
+        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Collection'+_,
+        directory=os.path.join(dir,"BLS3.blend"+_+"Collection"+_),
+        filename="BLS",
+        active_collection=False)
+
+        bpy.ops.bls_list.new_profile()
+        
+        context.scene.BLStudio.initialized = True
+
+        bpy.context.scene.render.engine = 'CYCLES'
+
+        # add the first light
+        # bpy.ops.object.select_all(action='DESELECT')
+        # bpy.ops.scene.add_blender_studio_light()
+        
+        return {"FINISHED"}
+  
+class DeleteBlenderLightStudio(bpy.types.Operator):
+    bl_idname = "scene.delete_blender_light_studio"
+    bl_label = "Delete Studio"
+    bl_description = "Delete Blender Light Studio from current scene"
+    bl_options = {"REGISTER"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        scene = context.scene
+        scene.BLStudio.initialized = False
+
+        # close control panel
+        from . operators.modal import close_control_panel
+        close_control_panel()
+        
+        ''' for each profile from this scene: delete objects then remove from list '''
+        while len(context.scene.BLStudio.profile_list):
+            bpy.ops.bls_list.delete_profile()
+            
+        obsToRemove = [ob for ob in scene.objects if isFamily(ob)]
+        for ob in obsToRemove:
+            for c in ob.users_collection:
+                c.objects.unlink(ob)
+            ob.user_clear()
+            ob.use_fake_user = False
+            bpy.data.objects.remove(ob)
+            
+        context.scene.collection.children.unlink(get_bls_collection(context))
+        
+        return {"FINISHED"}
+     
+    def invoke(self, context, event):
+        wm = context.window_manager
+        return wm.invoke_props_dialog(self)
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        col.label(text="Deleting Studio is irreversible!")
+        col.label(text="Your lighting setup will be lost.")
+
+class AddBSLight(bpy.types.Operator):
+    bl_idname = "scene.add_blender_studio_light"
+    bl_label = "Add Studio Light"
+    bl_description = "Add Light to Studio"
+    bl_options = {"REGISTER", "UNDO"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        script_file = os.path.realpath(__file__)
+        dir = os.path.dirname(script_file)
+        
+        scene = context.scene
+        bls_collection, profile_collection, profile, handle = blscol_profilecol_profile_handle(context)
+
+        filepath = os.path.join(dir,"BLS3.blend")
+        # load a single scene we know the name of.
+        with bpy.data.libraries.load(filepath) as (data_from, data_to):
+            data_to.collections = ["BLS_Light"]
+            
+        for collection in data_to.collections:
+            if collection is not None:
+                profile_collection.children.link(collection)
+                new_objects = collection.objects
+                for ob in new_objects:
+                    ob.use_fake_user = True
+                
+                blslight = [l for l in new_objects if l.name.startswith('BLS_LIGHT')][0]
+                blslight.parent = profile 
+                
+                bpy.ops.object.select_all(action='DESELECT')
+                light = [p for p in new_objects if p.name.startswith('BLS_LIGHT_MESH')][0]
+                light.select_set(True)
+                context.view_layer.objects.active = light
+        
+        #####
+        
+        c = light.constraints.new('COPY_LOCATION')
+        c.target = handle
+        c.use_x = True
+        c.use_y = True
+        c.use_z = True
+        c.use_offset = True
+        # scene.frame_current = bpy.context.scene.frame_current # refresh hack
+        # refreshMaterials()
+        
+        operators.update()
+        return {"FINISHED"}
+    
+class DeleteBSLight(bpy.types.Operator):
+    bl_idname = "scene.delete_blender_studio_light"
+    bl_label = "Delete BLS Light"
+    bl_description = "Delete selected Light from Studio"
+    bl_options = {"REGISTER", "UNDO"}
+    
+    @classmethod
+    def poll(cls, context):
+        light = context.active_object
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.BLStudio.initialized and \
+               light and \
+               light.name.startswith('BLS_LIGHT') and \
+               not light.name.startswith('BLS_PROFILE')
+
+    def execute(self, context):
+        scene = context.scene
+        light = context.object
+
+        for collection in light.users_collection:
+            if collection.name.startswith('BLS_Light'):
+                bpy.ops.object.delete({"selected_objects": collection.objects}, use_global=True)
+                bpy.data.collections.remove(collection)
+                
+        operators.update()
+        return {"FINISHED"}
+    
+    def invoke(self, context, event):
+        wm = context.window_manager
+        return wm.invoke_props_dialog(self)
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        col.label(text="OK?")
+
+class BUILTIN_KSI_LightStudio(bpy.types.KeyingSetInfo):
+    bl_label = "LightStudio KeyingSet"
+
+    # poll - test for whether Keying Set can be used at all
+    def poll(ksi, context):
+        return context.active_object or context.selected_objects and context.scene.BLStudio.initialized
+
+    # iterator - go over all relevant data, calling generate()
+    def iterator(ksi, context, ks):
+        for ob in (l for l in context.selected_objects if l.name.startswith("BLS_LIGHT")):
+            ksi.generate(context, ks, ob)
+
+    # generator - populate Keying Set with property paths to use
+    def generate(ksi, context, ks, data):
+        id_block = data.id_data
+
+        bls_collection = get_collection(id_block)
+        light_mesh = [m for m in bls_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
+        bls_actuator = light_mesh.parent
+        
+        ks.paths.add(light_mesh, "location", index=0, group_method='KEYINGSET')
+        ks.paths.add(light_mesh, "rotation_euler", index=0, group_method='KEYINGSET')
+        ks.paths.add(light_mesh, "scale", group_method='KEYINGSET')
+        ks.paths.add(bls_actuator, "rotation_euler", group_method='KEYINGSET')
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_preview_list.py b/skrypt/leomoon_lightstudio/light_preview_list.py
new file mode 100644
index 0000000..60bf71c
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/light_preview_list.py
@@ -0,0 +1,107 @@
+import os
+from time import time
+import bpy
+from . common import getLightMesh, isFamily
+
+_ = os.sep
+script_file = os.path.realpath(__file__)
+dir = os.path.dirname(script_file)
+directory=os.path.join(dir,"textures_real_lights")
+    
+def enum_previews_from_directory_items(self, context):
+    """EnumProperty callback"""
+    enum_items = []
+
+    if context is None:
+        return enum_items
+
+    wm = context.window_manager
+    
+    script_file = os.path.realpath(__file__)
+    dir = os.path.dirname(script_file)
+    directory=os.path.join(dir,"textures_real_lights"+_)
+
+    # Get the preview collection (defined in register func).
+    pcoll = preview_collections["main"]
+    
+    dir_up = os.path.getmtime(directory)
+    if pcoll.initiated and dir_up <= pcoll.dir_update_time:
+        return pcoll.tex_previews
+    pcoll.dir_update_time = dir_up
+    
+    pcoll.clear()
+
+    print("Scanning directory: %s" % directory)
+
+    if directory and os.path.exists(directory):
+        # Scan the directory for png files
+        image_paths = []
+        for fn in os.listdir(directory):
+            if os.path.splitext(fn)[1] in (".tif", ".exr", ".hdr"):
+                image_paths.append(fn)
+
+        for i, name in enumerate(image_paths):
+            # generates a thumbnail preview for a file.
+            filepath = os.path.join(directory, name)
+            thumb = pcoll.load(filepath, filepath, 'IMAGE', True)
+            basename = os.path.splitext(name)[0]
+            enum_items.append((name, basename, name, thumb.icon_id, i))
+
+    pcoll.tex_previews = enum_items
+    pcoll.initiated = True
+    return pcoll.tex_previews
+
+
+# We can store multiple preview collections here,
+# however in this example we only store "main"
+preview_collections = {}
+
+def preview_enum_get(wm):
+    nodes = getLightMesh().active_material.node_tree.nodes
+    if not "Light Texture" in nodes:
+        return -1
+    
+    tex = nodes["Light Texture"].image.filepath
+    tex = os.path.split(tex)[1]
+    names = (p[0] for p in preview_collections["main"].tex_previews)
+    
+    for i, name in enumerate(names):
+        if name == tex:
+            return i
+    return -1
+    
+def preview_enum_set(wm, context):
+    print("Set preview = %s" % context)
+    name = preview_collections["main"].tex_previews[context][0]
+    
+    light = getLightMesh()
+    light.active_material.node_tree.nodes["Light Texture"].image = bpy.data.images.load(os.path.join(directory, name), check_existing=True)
+    
+    return None
+
+def register():
+    from bpy.types import WindowManager
+    from bpy.props import EnumProperty
+
+    WindowManager.bls_tex_previews = EnumProperty(
+            items=enum_previews_from_directory_items,
+            get=preview_enum_get,
+            set=preview_enum_set,
+            )
+    import bpy.utils.previews
+    pcoll = bpy.utils.previews.new()
+    pcoll.bls_tex_previews = ()
+    pcoll.initiated = False
+    pcoll.dir_update_time = os.path.getmtime(directory)
+
+    preview_collections["main"] = pcoll
+
+def unregister():
+    from bpy.types import WindowManager
+
+    del WindowManager.bls_tex_previews
+
+    for pcoll in preview_collections.values():
+        bpy.utils.previews.remove(pcoll)
+        pcoll.clear()
+    preview_collections.clear()
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/light_profiles.py b/skrypt/leomoon_lightstudio/light_profiles.py
new file mode 100644
index 0000000..7f25ed8
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/light_profiles.py
@@ -0,0 +1,634 @@
+import bpy
+from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProperty, EnumProperty
+import os
+from . common import *
+from itertools import chain
+
+_ = os.sep
+
+class ListItem(bpy.types.PropertyGroup):
+    """ Group of properties representing an item in the list """
+    def update_name(self, context):
+        print("{} : {}".format(repr(self.name), repr(context)))
+                
+    name: StringProperty(
+            name="Profile Name",
+            default="Untitled")
+
+    empty_name: StringProperty(
+            name="Name of Empty that holds the profile",
+            description="",
+            default="")
+            
+class BLS_UL_List(bpy.types.UIList):
+    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
+        custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.BLStudio.list_index else 'LIGHT'
+
+        # Make sure your code supports all 3 layout types
+        if self.layout_type in {'DEFAULT', 'COMPACT'}:
+            layout.prop(item, 'name', text='', icon = custom_icon, emboss=False, translate=False)
+
+        elif self.layout_type in {'GRID'}:
+            layout.alignment = 'CENTER'
+            layout.label("", icon = custom_icon)
+            
+            
+class LIST_OT_NewItem(bpy.types.Operator):
+    """ Add a new profile to the list """
+
+    bl_idname = "bls_list.new_profile"
+    bl_label = "Add a new Profile"
+    bl_options = {"INTERNAL"}
+    
+    handle: BoolProperty(default=True)
+
+    def execute(self, context):
+        props = context.scene.BLStudio
+        item = props.profile_list.add()
+        bls_collection = get_bls_collection(context)
+
+        # unlink existing profiles
+        for profile in (prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)):
+            profile_collection = profile.users_collection[0]
+            bls_collection.children.unlink(profile_collection)
+        #
+
+        idx = 0
+        for id in (i.name.split('Profile ')[1] for i in props.profile_list if i.name.startswith('Profile ')):
+            try:
+                id = int(id)
+            except ValueError:
+                continue
+            
+            if id > idx: idx = id
+            
+        item.name = 'Profile '+str(idx+1)
+        
+        ''' Add Hierarchy stuff '''
+        # before
+        A = set(bpy.data.objects[:])
+        
+        script_file = os.path.realpath(__file__)
+        dir = os.path.dirname(script_file)
+        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Object'+_,
+            directory=os.path.join(dir,"BLS3.blend"+_+"Object"+_),
+            filename="BLS_PROFILE.000",
+            active_collection=True)
+        
+        # after operation
+        B = set(bpy.data.objects[:])
+
+        # whats the difference
+        profile = (A ^ B).pop()
+        
+        profile.parent = [ob for ob in context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
+        profile.use_fake_user = True
+        profile_collection = bpy.data.collections.new(profile.name)
+        profile_collection.use_fake_user = True
+        bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+        bls_collection.children.link(profile_collection)
+        replace_link(profile, profile.name)
+        
+        item.empty_name = profile.name
+        
+        handle = None
+        if self.handle:
+            bpy.ops.object.empty_add()
+            handle = context.active_object
+            handle.name = "BLS_HANDLE"
+            handle.empty_display_type = 'SPHERE'
+            handle.parent = profile
+            handle.protected = True
+            handle.use_fake_user = True
+            replace_link(handle, profile.name)
+        
+        props.last_empty = profile.name
+        props.list_index = len(props.profile_list)-1
+
+        return{'FINISHED'}
+
+class LIST_OT_DeleteItem(bpy.types.Operator):
+    """ Delete the selected profile from the list """
+ 
+    bl_idname = "bls_list.delete_profile"
+    bl_label = "Deletes an profile"
+    bl_options = {"INTERNAL"}
+ 
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        index = props.list_index
+ 
+        props.profile_list.remove(index)
+        
+        ''' Delete/Switch Hierarchy stuff '''
+        #delete objects from current profile           
+        obsToRemove = family(context.scene.objects[props.last_empty])
+        collectionsToRemove = set()
+        for ob in obsToRemove:
+            collectionsToRemove.update(ob.users_collection)
+            ob.use_fake_user = False
+        bpy.ops.object.delete({"selected_objects": obsToRemove}, use_global=True)
+        for c in collectionsToRemove:
+            if c.name.startswith('BLS_'):
+                bpy.data.collections.remove(c)
+        
+        # update index
+        if index > 0:
+            index = index - 1
+        props.list_index = index
+ 
+        return{'FINISHED'}
+    
+
+class LIST_OT_CopyItem(bpy.types.Operator):
+    """ Copy an item in the list """
+
+    bl_idname = "bls_list.copy_profile"
+    bl_label = "Copy profile"
+    bl_options = {"INTERNAL"}
+
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list. """
+        return len(context.scene.BLStudio.profile_list)
+
+    def execute(self, context):
+        props = context.scene.BLStudio
+        list = props.profile_list
+        index = props.list_index
+        
+        scene = context.scene
+        
+        # all objects on all layers visible
+        oldlaysArea = context.area.spaces[0].layers[:]
+        oldlaysScene = context.scene.layers[:]
+        context.area.spaces[0].layers = [True]*20
+        context.scene.layers = [True]*20
+        
+        obsToCopy = family(context.scene.objects[props.last_empty])
+        
+        for ob in context.selected_objects: ob.select = False
+        for ob in obsToCopy:
+            if ob.name.startswith('BLS_PROFILE.'): continue
+            ob.hide_select = False
+            ob.hide = False
+            ob.select = True
+            
+            
+        # before
+        A = set(scene.objects[:])
+        
+        bpy.ops.object.duplicate()
+        
+        # after operation
+        B = set(scene.objects[:])
+
+        # whats the difference
+        new_objects = (A ^ B)
+        
+        # make light material single user and update selection drivers]
+        bpy.ops.group.objects_remove_all()
+        bpy.ops.group.create(name='BLS_Light')
+        
+        for lg in new_objects:
+            if lg.name.startswith('BLS_LIGHT_GRP.'):
+                controller = [c for c in family(lg) if c.name.startswith("BLS_CONTROLLER.")][0]
+                lmesh = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH.")][0]
+                
+                light_mat = None
+                for id, mat in enumerate(controller.data.materials):
+                    if mat.name.startswith('BLS_icon_ctrl'):
+                        mat = mat.copy()
+                        controller.data.materials[id] = mat
+                        
+                        for d in mat.animation_data.drivers:
+                            d.driver.variables[0].targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
+                        
+                        for d in mat.node_tree.animation_data.drivers:
+                            for v in d.driver.variables:
+                                v.targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
+                                
+                    elif mat.name.startswith('BLS_light'):
+                        #mat = mat.copy()
+                        light_mat = mat.copy()
+                        controller.data.materials[id] = light_mat
+                        light_mat.node_tree.nodes['Light Texture'].image = light_mat.node_tree.nodes['Light Texture'].image.copy()
+                        
+                for id, mat in enumerate(lmesh.data.materials):
+                    if mat.name.startswith('BLS_light'):
+                        lmesh.data.materials[id] = light_mat               
+                            
+        # revert visibility
+        for ob in chain(obsToCopy, new_objects):
+            ob.hide = True
+            ob.hide_select = True
+            
+            if ob.name.startswith('BLS_LIGHT_MESH.') or \
+               ob.name.startswith('BLS_HANDLE') or \
+               ob.name.startswith('BLS_CONTROLLER.'):
+                ob.hide = False
+                ob.hide_select = False
+                
+        profileName = props.profile_list[props.list_index].name
+        
+        bpy.ops.bls_list.new_profile(handle=False)
+        lastItemId = len(props.profile_list)-1
+        
+        # parent objects to new profile
+        for ob in new_objects:
+            scene.objects.unlink(ob)
+            if ob.name.startswith('BLS_LIGHT_GRP.'):
+                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
+            elif ob.name.startswith('BLS_HANDLE.'):
+                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
+                
+            
+        props.profile_list[len(props.profile_list)-1].name = profileName + ' Copy'
+        
+        
+        # place copied profile next to source profile
+        while lastItemId > props.list_index+1:
+            list.move(lastItemId-1, lastItemId)
+            lastItemId -= 1
+        
+        context.area.spaces[0].layers = oldlaysArea
+        context.scene.layers = oldlaysScene
+        
+        return{'FINISHED'}
+    
+    
+ 
+class LIST_OT_MoveItem(bpy.types.Operator):
+    """ Move an item in the list """
+
+    bl_idname = "bls_list.move_profile"
+    bl_label = "Move profile in the list"
+    bl_options = {"INTERNAL"}
+
+    direction: bpy.props.EnumProperty(
+                items=(
+                    ('UP', 'Up', ""),
+                    ('DOWN', 'Down', ""),))
+
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list. """
+        return len(context.scene.BLStudio.profile_list)
+
+
+    def move_index(self, context):
+        """ Move index of an item render queue while clamping it. """
+        props = context.scene.BLStudio
+        index = props.list_index
+        list_length = len(props.profile_list) - 1 # (index starts at 0)
+        new_index = 0
+
+        if self.direction == 'UP':
+            new_index = index - 1
+        elif self.direction == 'DOWN':
+            new_index = index + 1
+
+        new_index = max(0, min(new_index, list_length))
+        props.list_index = new_index
+
+
+    def execute(self, context):
+        props = context.scene.BLStudio
+        list = props.profile_list
+        index = props.list_index
+
+        if self.direction == 'DOWN':
+            neighbor = index + 1
+            list.move(index,neighbor)
+        elif self.direction == 'UP':
+            neighbor = index - 1
+            list.move(neighbor, index)
+        else:
+            return{'CANCELLED'}
+        self.move_index(context)
+
+        return{'FINISHED'}
+
+
+def update_list_index(self, context):
+    props = context.scene.BLStudio
+    bls_collection = get_bls_collection(context)
+    
+    if len(props.profile_list) == 0: return
+        
+    selected_profile = props.profile_list[self.list_index]
+    
+    if selected_profile.empty_name == props.last_empty: return
+
+    print('Index update {}'.format(self.list_index))
+        
+    #unlink current profile
+    prof_idx = context.scene.objects.find(props.last_empty)
+    if prof_idx > -1: # in case of update after deletion
+        profile_collection = context.scene.objects[prof_idx].users_collection[0]
+        bls_collection.children.unlink(profile_collection)
+        
+    #link selected profile
+    bls_collection.children.link(bpy.data.collections[selected_profile.empty_name])
+    
+    props.last_empty = selected_profile.empty_name
+
+    from . operators.modal import update_light_sets, panel_global
+    update_light_sets(panel_global, bpy.context, always=True)
+        
+# import/export
+import json, time
+script_file = os.path.realpath(__file__)
+dir = os.path.dirname(script_file)
+
+VERSION = 2.00
+def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
+    plist = props.profile_list
+    for profile in profiles:
+        print(profile)
+        bpy.ops.bls_list.new_profile()
+        props.list_index = len(plist)-1
+        plist[-1].name = profile["name"]
+        if not internal_copy:
+            date = time.localtime()
+            plist[-1].name += ' {}-{:02}-{:02} {:02}:{:02}'.format(str(date.tm_year)[-2:], date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
+
+        profile_empty = context.scene.objects[plist[-1].empty_name]
+        
+        if version > 1:
+            handle = getLightHandle(profile_empty)    
+            handle.location.x = profile['handle_position'][0]
+            handle.location.y = profile['handle_position'][1]
+            handle.location.z = profile['handle_position'][2]
+
+        for light in profile["lights"]:
+            # before
+            A = set(profile_empty.children)
+            
+            bpy.ops.scene.add_blender_studio_light()
+            
+            # after operation
+            B = set(profile_empty.children)
+            
+            # whats the difference
+            lgrp = (A ^ B).pop()
+
+            actuator = [c for c in family(lgrp) if "BLS_ROTATION" in c.name][0]
+            lmesh = [c for c in family(lgrp) if "BLS_LIGHT_MESH" in c.name][0]
+            lmesh.location.x = light['radius']
+            
+            actuator.rotation_euler.x = light['position'][0]
+            actuator.rotation_euler.y = light['position'][1]
+            actuator.rotation_euler.z = 0
+            
+            lmesh.scale.x = light['scale'][0]
+            lmesh.scale.y = light['scale'][1]
+            lmesh.scale.z = light['scale'][2]
+            
+            lmesh.rotation_euler.x = light['rotation']
+
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['Texture Switch']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1] = light['Color Overlay'][1]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2] = light['Color Overlay'][2]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3] = light['Color Overlay'][3]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Color Saturation']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Intensity']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Mask - Gradient Switch']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value = light['Mask - Gradient Type']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value = light['Mask - Gradient Amount']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value = light['Mask - Ring Switch']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value = light['Mask - Ring Inner Radius']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value = light['Mask - Ring Outer Radius']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value = light['Mask - Top to Bottom']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value = light['Mask - Bottom to Top']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value = light['Mask - Left to Right']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value = light['Mask - Right to Left']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value = light['Mask - Diagonal Top Left']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value = light['Mask - Diagonal Top Right']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value = light['Mask - Diagonal Bottom Right']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value = light['Mask - Diagonal Bottom Left']
+
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
+            
+            if os.path.isabs(light['tex']):
+                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
+            else:
+                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
+                
+class ImportProfiles(bpy.types.Operator):
+    """ Import Profiles from File """
+ 
+    bl_idname = "bls_list.import_profiles"
+    bl_label = "Import Profiles"
+    #bl_options = {"INTERNAL"}
+    
+    filepath: bpy.props.StringProperty(default="*.bls", subtype="FILE_PATH")
+ 
+    @classmethod
+    def poll(self, context):
+        return True
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        
+        with open(self.filepath, 'r') as f:
+            file = f.read()
+        f.closed
+        
+        file = json.loads(file)
+        parse_profile(context, props, file["profiles"], float(file["version"]))
+ 
+        return{'FINISHED'}
+    
+    def invoke(self, context, event):
+        context.window_manager.fileselect_add(self)
+        return {'RUNNING_MODAL'}
+
+def compose_profile(list_index):
+    props = bpy.context.scene.BLStudio
+    profile_dict = {}
+    profile_dict['name'] = props.profile_list[list_index].name
+    profile_dict['lights']= []
+    profile = bpy.data.objects[props.profile_list[list_index].empty_name]
+    profile_collection = get_collection(profile)
+    handle = getLightHandle(profile)
+    profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
+    for light_collection in profile_collection.children:
+        lmesh = [ob for ob in light_collection.objects if ob.name.startswith('BLS_LIGHT_MESH')][0]
+        actuator = [ob for ob in light_collection.objects if ob.name.startswith('BLS_ROTATION')][0]
+        light = {}
+        light['radius'] = lmesh.location.x
+        light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
+        light['scale'] = [lmesh.scale.x, lmesh.scale.y, lmesh.scale.z]
+        light['rotation'] = lmesh.rotation_euler.x
+        # view_layer = find_view_layer(light_collection, bpy.context.view_layer.layer_collection)
+        # light['mute'] = view_layer.exclude
+        texpath = lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
+        light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
+        
+        light['Texture Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
+        light['Color Overlay'] = [lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0],
+                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1],
+                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2],
+                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3]]
+        light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
+        light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
+        light['Mask - Gradient Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
+        light['Mask - Gradient Type'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value
+        light['Mask - Gradient Amount'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value
+        light['Mask - Ring Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value
+        light['Mask - Ring Inner Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value
+        light['Mask - Ring Outer Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value
+        light['Mask - Top to Bottom'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value
+        light['Mask - Bottom to Top'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value
+        light['Mask - Left to Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value
+        light['Mask - Right to Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value
+        light['Mask - Diagonal Top Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value
+        light['Mask - Diagonal Top Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value
+        light['Mask - Diagonal Bottom Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value
+        light['Mask - Diagonal Bottom Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value
+
+        # light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
+        # light['Opacity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value
+        # light['Falloff'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
+        # light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
+        # light['Half'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
+        
+        profile_dict['lights'].append(light)
+        
+    return profile_dict
+        
+class ExportProfiles(bpy.types.Operator):
+    """ Export Profiles to File """
+ 
+    bl_idname = "bls_list.export_profiles"
+    bl_label = "Export"
+    #bl_options = {"INTERNAL"}
+    
+    filepath: bpy.props.StringProperty(default="profile.bls", subtype="FILE_PATH")
+    all: bpy.props.BoolProperty(default=False, name="Export All Profiles")
+ 
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        index = props.list_index
+            
+        export_file = {}
+        date = time.localtime()
+        export_file['date'] = '{}-{:02}-{:02} {:02}:{:02}'.format(date.tm_year, date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
+        export_file['version'] = VERSION
+        profiles_to_export = export_file['profiles'] = []
+        
+        if self.all:
+            for p in range(len(props.profile_list)):
+                try:
+                    profiles_to_export.append(compose_profile(p))
+                except Exception:
+                    self.report({'WARNING'}, 'Malformed profile %s. Omitting.' % props.profile_list[p].name)
+        else:
+            try:
+                profiles_to_export.append(compose_profile(index))
+            except Exception:
+                self.report({'WARNING'}, 'Malformed profile %s. Omitting.' % props.profile_list[index].name)
+        
+        with open(self.filepath, 'w') as f:
+            f.write(json.dumps(export_file, indent=4))
+        f.closed
+        
+        return{'FINISHED'}
+    
+    def invoke(self, context, event):
+        self.filepath = "profile.bls"
+        context.window_manager.fileselect_add(self)
+        return {'RUNNING_MODAL'}
+    
+class FindMissingTextures(bpy.types.Operator):
+    """ Find Missing Textures """
+ 
+    bl_idname = "bls.find_missing_textures"
+    bl_label = "Find Missing Textures"
+    #bl_options = {"INTERNAL"}
+    
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        bpy.ops.file.find_missing_files(directory=os.path.join(dir, "textures_real_lights"))        
+        bpy.context.scene.frame_current = bpy.context.scene.frame_current
+        return{'FINISHED'}
+
+class CopyProfileToScene(bpy.types.Operator):
+    """ Copy Light Profile to Scene """
+ 
+    bl_idname = "bls_list.copy_profile_to_scene"
+    bl_label = "Copy Profile to Scene"
+    bl_property = "sceneprop"
+    
+    def get_scenes(self, context):
+        return ((s.name, s.name, "Scene name") for i,s in enumerate(bpy.data.scenes))#global_vars["scenes"]
+    
+    sceneprop: EnumProperty(items = get_scenes)
+    
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        index = props.list_index
+        
+        profiles = [compose_profile(index),]
+        
+        context.screen.scene = bpy.data.scenes[self.sceneprop]
+        context.scene.render.engine = 'CYCLES'
+        if not context.scene.BLStudio.initialized:
+            bpy.ops.scene.create_blender_light_studio()
+        
+        parse_profile(context, context.scene.BLStudio, profiles, internal_copy=True)
+        
+        return{'FINISHED'}
+        
+    def invoke(self, context, event):
+        wm = context.window_manager
+        wm.invoke_search_popup(self)
+        return {'FINISHED'}
+    
+
+class CopyProfileMenu(bpy.types.Operator):
+    """ Copy Light Profile """
+ 
+    bl_idname = "bls_list.copy_profile_menu"
+    bl_label = "Copy Profile"
+
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+    
+    def execute(self, context):
+        wm = context.window_manager
+        def draw(self, context):
+            layout = self.layout
+            layout.operator_context='INVOKE_AREA'
+            col = layout.column(align=True)
+            col.operator('bls_list.copy_profile')
+            col.operator('bls_list.copy_profile_to_scene')
+
+        wm.popup_menu(draw, title="Copy Profile")
+        return {'FINISHED'}
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/operators/__init__.py b/skrypt/leomoon_lightstudio/operators/__init__.py
new file mode 100644
index 0000000..e71d203
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/operators/__init__.py
@@ -0,0 +1,16 @@
+# class UpdateChecker:
+#     def __init__(self):
+#         self.updated
+UPDATED = True
+
+def is_updated():
+    global UPDATED
+    return UPDATED
+
+def update():
+    global UPDATED
+    UPDATED = True
+
+def update_clear():
+    global UPDATED
+    UPDATED = False
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/operators/modal.py b/skrypt/leomoon_lightstudio/operators/modal.py
new file mode 100644
index 0000000..1022d6b
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/operators/modal.py
@@ -0,0 +1,449 @@
+import bpy
+
+from mathutils import *
+
+from . modal_utils import *
+from . import *
+
+from .modal_utils import shader2Dcolor
+from gpu_extras.batch import batch_for_shader
+import time
+
+last_time = time.time()
+def draw(self, area):
+    if area != bpy.context.area:
+        return
+
+    shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
+    batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
+    #
+
+    self.panel.draw()
+    for b in Button.buttons:
+        b.draw(self.mouse_x, self.mouse_y)
+    for l in LightImage.lights:
+        l.draw()
+
+class BLS_OT_Rotate(bpy.types.Operator, MouseWidget):
+    bl_idname = "light_studio.rotate"
+    bl_label = "Rotate Light"
+    bl_options = {"REGISTER", "UNDO", "INTERNAL"}
+
+    def __init__(self):
+        super().__init__()
+        self.pivot = Vector((self.mouse_x, self.mouse_y))
+        self.base_object_rotation = 0
+        self.allow_precision_mode = True
+
+    def invoke(self, context, event):
+        super().invoke(context, event)
+        self.base_object_rotation = LightImage.selected_object._bls_mesh.rotation_euler.x
+        return {"RUNNING_MODAL"}
+    
+    def _finish(self, context, event):
+        context.area.header_text_set(text=None)
+
+    def _cancel(self, context, event):
+        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation
+        context.area.header_text_set(text=None)
+
+    def _modal(self, context, event):
+        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
+
+        context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
+
+        return {"PASS_THROUGH"}
+
+class BLS_OT_Scale(bpy.types.Operator, MouseWidget):
+    bl_idname = "light_studio.scale"
+    bl_label = "Scale Light"
+    bl_options = {"GRAB_CURSOR", "BLOCKING", "REGISTER", "UNDO", "INTERNAL"}
+
+    def __init__(self):
+        super().__init__()
+        self.pivot = Vector((self.mouse_x, self.mouse_y))
+        self.base_object_scale = 0
+        self.allow_xy_keys = True
+        self.allow_precision_mode = True
+
+    def invoke(self, context, event):
+        super().invoke(context, event)
+        self.base_object_scale = LightImage.selected_object._bls_mesh.scale.copy()
+        return {"RUNNING_MODAL"}
+    
+    def _cancel(self, context, event):
+        LightImage.selected_object._bls_mesh.scale = self.base_object_scale
+        context.area.header_text_set(text=None)
+
+    def _finish(self, context, event):
+        context.area.header_text_set(text=None)
+
+    def _modal(self, context, event):
+        new_scale = self.base_object_scale * self.delta_length_factor()
+        if self.x_key:
+            new_scale.z = self.base_object_scale.z
+        if self.y_key:
+            new_scale.y = self.base_object_scale.y
+
+        LightImage.selected_object._bls_mesh.scale = new_scale
+
+        context.area.header_text_set(text=f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
+
+        if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+            return {"RUNNING_MODAL"}
+        return {"PASS_THROUGH"}
+
+GRABBING = False
+class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
+    bl_idname = "light_studio.grab"
+    bl_label = "Grab Light"
+    bl_options = {"GRAB_CURSOR", "BLOCKING", "INTERNAL"}
+
+    canvas_width: bpy.props.FloatProperty()
+    canvas_height: bpy.props.FloatProperty()
+
+    def __init__(self):
+        super().__init__()
+        self.pivot = Vector((self.mouse_x, self.mouse_y))
+        self.base_object_rotation = Vector((0, 0, 0))
+        self.allow_xy_keys = True
+        self.continous = True
+        self.draw_guide = False
+        self.allow_precision_mode = True
+
+    def invoke(self, context, event):
+        super().invoke(context, event)
+        self.base_object_rotation = LightImage.selected_object._bls_actuator.rotation_euler.copy()
+        return {"RUNNING_MODAL"}
+    
+    def _cancel(self, context, event):
+        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation
+        global GRABBING
+        GRABBING = False
+        context.area.header_text_set(text=None)
+
+    def _finish(self, context, event):
+        global GRABBING
+        GRABBING = False
+        context.area.header_text_set(text=None)
+
+    def _modal(self, context, event):
+        dv = self.delta_vector()
+        if self.x_key:
+            dv.y = 0
+        if self.y_key:
+            dv.x = 0
+
+        x_factor = 2*pi / self.canvas_width
+        y_factor = pi / self.canvas_height
+
+        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation.copy()
+        LightImage.selected_object._bls_actuator.rotation_euler.x += dv.x * x_factor
+        LightImage.selected_object._bls_actuator.rotation_euler.y += dv.y * y_factor
+        LightImage.selected_object._bls_actuator.rotation_euler.y = clamp(-pi/2 + 0.000001, LightImage.selected_object._bls_actuator.rotation_euler.y, pi/2 - 0.000001)
+
+        context.area.header_text_set(text=f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
+
+        if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+            return {"RUNNING_MODAL"}
+        return {"PASS_THROUGH"}
+
+panel_global = None
+running_modals = 0
+class BLS_OT_control_panel(bpy.types.Operator):
+    bl_idname = "light_studio.control_panel"
+    bl_label = "Light Studio Control Panel"
+
+    mouse_x: bpy.props.IntProperty()
+    mouse_y: bpy.props.IntProperty()
+
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+
+    def __init__(self):
+        self.textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale | [Ctrl+Click] Loop overlapping"
+        self.handler = None
+        self.panel = None
+        self.panel_moving = False
+        self.clicked_object = None
+        self.profile_collection = None
+        self.click_manager = ClickManager()
+        self.active_feature = None
+        self.precision_mode = False
+
+    def __del__(self):
+        self._unregister_handler()
+
+    def _unregister_handler(self):
+        global running_modals
+        running_modals = max(0, running_modals-1)
+        try:
+            bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
+        except (ValueError, AttributeError):
+            pass
+
+    def _mouse_event(self, context, event):
+        area_mouse_x = event.mouse_x - context.area.x
+        area_mouse_y = event.mouse_y - context.area.y
+        dx = area_mouse_x - self.mouse_x
+        dy = area_mouse_y - self.mouse_y
+        self.mouse_x = area_mouse_x
+        self.mouse_y = area_mouse_y
+        return dx, dy, area_mouse_x, area_mouse_y
+
+    def invoke(self, context, event):
+        global running_modals
+        running_modals += 1
+        if running_modals > 1:
+            # toggle panel
+            running_modals = 0
+            return {"CANCELLED"}
+
+        self.handler = bpy.types.SpaceView3D.draw_handler_add(draw, (self, context.area), 'WINDOW', 'POST_PIXEL')
+        context.window_manager.modal_handler_add(self)
+
+        aw = context.area.width
+        ah = context.area.height
+        pw = min(aw-60, 600)
+        
+        global panel_global
+        if not panel_global:
+            panel_global = Panel(Vector((30, 25)), pw, pw*(9/16))
+        self.panel = panel_global
+
+        LightImage.default_size = 100
+
+        self.mouse_x = event.mouse_x - context.area.x
+        self.mouse_y = event.mouse_y - context.area.y
+
+        update_light_sets(self.panel, context, always=True)
+
+        context.area.header_text_set(text=self.textinfo)
+
+        self.ctrl = False
+
+        return {"RUNNING_MODAL"}
+    
+    def modal(self, context, event):
+        global running_modals
+        if running_modals < 1:
+            self._unregister_handler()
+            context.area.tag_redraw()
+            return {"FINISHED"}
+
+        # print(event.type, event.value)
+        if not context.area or (context.object and not context.object.mode == 'OBJECT'):
+            self._unregister_handler()
+            return {"CANCELLED"}
+        try:
+            context.area.tag_redraw()
+
+            update_light_sets(self.panel, context)
+            LightImage.refresh()
+
+            if event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+                dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                if self.clicked_object and self.panel_moving:
+                    # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                    # self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
+                    if isinstance(self.clicked_object, Panel):
+                        # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                        self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
+                    else:
+                        active_object = None
+                        if LightImage.selected_object:
+                            active_object = LightImage.selected_object
+                        if active_object and not GRABBING:
+                            bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
+                            self.panel_moving = False
+                    
+                    return {"RUNNING_MODAL"}
+
+                return {"PASS_THROUGH"}
+            
+            if event.value == "PRESS":
+                if event.type in {"LEFT_CTRL"}:
+                    self.ctrl = True
+
+                if event.type in {"R"}:
+                    active_object = None
+                    if LightImage.selected_object:
+                        active_object = LightImage.selected_object
+                    
+                    if active_object:
+                        bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
+                        return {'RUNNING_MODAL'}
+                elif event.type in {"S"}:
+                    active_object = None
+                    if LightImage.selected_object:
+                        active_object = LightImage.selected_object
+                    
+                    if active_object:
+                        bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
+                        return {'RUNNING_MODAL'}
+
+                elif event.type == "RIGHTMOUSE":
+                    dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                    self.clicked_object = self.find_clicked(area_mouse_x, area_mouse_y)
+
+                    if not self.clicked_object:
+                        return {"PASS_THROUGH"}
+                    
+                    if hasattr(self.clicked_object, 'mute'):
+                        muted_count = len([l for l in LightImage.lights if l.mute])
+                        unmuted_count = len(LightImage.lights) - muted_count
+                        if muted_count == 0:
+                            # no muted at start. mute all but selected
+                            for l in LightImage.lights:
+                                l.mute = True
+                            self.clicked_object.mute = False
+                        else:
+                            # some muted.
+                            if unmuted_count == 1 and self.clicked_object.mute == False:
+                                for l in LightImage.lights:
+                                    l.mute = False
+                            else:
+                                for l in LightImage.lights:
+                                    l.mute = True
+                                self.clicked_object.mute = False
+
+                    if hasattr(self.clicked_object, 'select'):
+                        self.clicked_object.select()
+                    
+                    return {"RUNNING_MODAL"}
+
+                # Left mouse button pressed            
+                elif event.type == "LEFTMOUSE":
+                    dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+
+                    overlapped = self.find_clicked(area_mouse_x, area_mouse_y, overlapping=True)
+                    if type(overlapped) == list:
+                        # List of overlapping lights
+                        self.clicked_object = overlapped[0] if overlapped else None
+                    else:
+                        # Button
+                        self.clicked_object = overlapped
+                    self.panel_moving = self.clicked_object != None
+                    
+                    click_result = self.click_manager.click(self.clicked_object)
+                    if not self.ctrl and hasattr(self.clicked_object, 'mute'):
+                        if click_result == "TRIPLE":
+                            muted_count = len([l for l in LightImage.lights if l.mute]) - 1
+                            unmuted_count = len(LightImage.lights) - muted_count
+                            if muted_count == 0:
+                                # no muted at start. mute all but selected
+                                for l in LightImage.lights:
+                                    l.mute = True
+                                self.clicked_object.mute = False
+                            else:
+                                # some muted.
+                                if unmuted_count == 1 and self.clicked_object.mute == True:
+                                    for l in LightImage.lights:
+                                        l.mute = False
+                                else:
+                                    for l in LightImage.lights:
+                                        l.mute = True
+                                    self.clicked_object.mute = False
+                        elif click_result == "DOUBLE":
+                            self.clicked_object.mute = not self.clicked_object.mute
+
+                    if hasattr(self.clicked_object, 'select'):
+                        self.clicked_object.select()
+                        if self.ctrl and len(overlapped)>1:
+                            send_light_to_bottom(self.clicked_object)
+                            self.find_clicked(area_mouse_x, area_mouse_y).select()
+                        else:
+                            send_light_to_top(self.clicked_object)
+
+
+                    if hasattr(self.clicked_object, 'click'):
+                        result = self.clicked_object.click()
+                        if result == "FINISHED":
+                            context.area.header_text_set(text=None)
+                            self._unregister_handler()
+                            return {"FINISHED"}
+                        return {"RUNNING_MODAL"}
+
+                    if self.clicked_object:
+                        return {"RUNNING_MODAL"}
+                    return {"PASS_THROUGH"}
+
+                elif event.type == "NUMPAD_PLUS":
+                    LightImage.change_default_size(LightImage.default_size+10)
+                    return {'RUNNING_MODAL'}
+                elif event.type == "NUMPAD_MINUS":
+                    LightImage.change_default_size(LightImage.default_size-10)
+                    return {'RUNNING_MODAL'}
+                elif event.type == "LEFT_SHIFT":
+                    self.precision_mode = True
+                    return {'RUNNING_MODAL'}
+                
+                # Return (Enter) key is pressed
+                elif event.type == "RET":
+                    context.area.header_text_set(text=None)
+                    self._unregister_handler()
+                    return {'FINISHED'}
+            
+            if event.value == "RELEASE":
+                context.area.header_text_set(text=self.textinfo)
+                if event.type == "LEFTMOUSE":
+                    self.panel_moving = False
+                elif event.type == "LEFT_SHIFT":
+                    self.precision_mode = False
+                    return {'RUNNING_MODAL'}
+                elif event.type in {"LEFT_CTRL"}:
+                    self.ctrl = False
+
+            if event.value == "CLICK":
+                # Left mouse button clicked
+                if event.type == "LEFTMOUSE":
+                    return {"PASS_THROUGH"}
+        except:
+            self._unregister_handler()
+            import traceback
+            traceback.print_exc()
+            return {"CANCELLED"}
+        
+        return {"PASS_THROUGH"}
+
+    def find_clicked(self, area_mouse_x, area_mouse_y, overlapping=False):
+        overlapped = []
+        for l in reversed(LightImage.lights):
+            if l.is_mouse_over(area_mouse_x, area_mouse_y):
+                if not overlapping:
+                    return l
+                else:
+                    overlapped.append(l)
+
+        if overlapping and overlapped:
+            return overlapped
+        
+        for b in Button.buttons:
+            if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
+                return b
+
+        if is_in_rect(self.panel, Vector((area_mouse_x, area_mouse_y))):
+            return self.panel
+        return None
+
+def update_light_sets(panel, context, always=False):
+    bls_collection, profile_collection = blscol_profilecol(context)
+    if is_updated() or always or len(profile_collection.children) != len(LightImage.lights):
+        bls_lights = set(profile_collection.children)
+        working_set = set((l._collection for l in LightImage.lights))
+
+        to_delete = working_set.difference(bls_lights)
+        to_add =  bls_lights.difference(working_set)
+        
+        for col in to_delete:
+            LightImage.remove(col)
+
+        for col in to_add:
+            LightImage(context, panel, col)
+
+        update_clear()
+
+def close_control_panel():
+    global running_modals
+    running_modals = 0
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/operators/modal_utils.py b/skrypt/leomoon_lightstudio/operators/modal_utils.py
new file mode 100644
index 0000000..84d4656
--- /dev/null
+++ b/skrypt/leomoon_lightstudio/operators/modal_utils.py
@@ -0,0 +1,905 @@
+import gpu, bgl, blf
+from gpu_extras.batch import batch_for_shader
+from mathutils import *
+from math import pi, fmod, radians, sin, cos, atan2
+from .. common import *
+from . import *
+import time
+from copy import deepcopy
+
+shader2Dcolor = gpu.shader.from_builtin('2D_UNIFORM_COLOR')
+shader2Dcolor.bind()
+
+vertex_shader = '''
+    uniform mat4 ModelViewProjectionMatrix;
+
+    /* Keep in sync with intern/opencolorio/gpu_shader_display_transform_vertex.glsl */
+    in vec2 pos;
+    in vec2 texCoord;
+    out vec2 texCoord_interp;
+
+    void main()
+    {
+        gl_Position = ModelViewProjectionMatrix * vec4(pos.xy, 0.0f, 1.0f);
+        gl_Position.z = 1.0;
+        texCoord_interp = texCoord;
+    }
+'''
+
+fragment_shader = '''
+    #define PI 3.1415926535897932384626433832795f
+
+    in vec2 texCoord_interp;
+    in vec4 gl_FragCoord;
+
+    layout(location = 0) out vec4 fragColor;
+    layout(location = 1) out vec4 trash;
+
+    uniform sampler2D image;
+    uniform float panel_point_left;
+    uniform float panel_point_right;
+
+    uniform vec4 color_overlay = vec4(0);
+    uniform float intensity = 1;
+    uniform float texture_switch = 1;
+    uniform float color_saturation = 0;
+
+    uniform float mask_bottom_to_top = 0;
+    uniform float mask_diagonal_bottom_left = 0;
+    uniform float mask_diagonal_bottom_right = 0;
+    uniform float mask_diagonal_top_left = 0;
+    uniform float mask_diagonal_top_right = 0;
+    uniform float mask_gradient_amount = 0;
+    uniform float mask_gradient_switch = 0;
+    uniform float mask_gradient_type = 0;
+    uniform float mask_left_to_right = 0;
+    uniform float mask_right_to_left = 0;
+    uniform float mask_ring_inner_radius = 0;
+    uniform float mask_ring_outer_radius = 0;
+    uniform float mask_ring_switch = 0;
+    uniform float mask_top_to_bottom = 0;
+
+    void main()
+    {
+        // Trash output - sum all uniforms to prevent compiler from skipping currently unused ones
+        trash = vec4(panel_point_left+panel_point_right+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
+        
+        // Texture Switch + Intensity
+        // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
+        fragColor = mix(vec4(1.0f), texture(image, texCoord_interp), texture_switch) * log(1+intensity);
+        
+        // Color Overlay
+        float gray = clamp(dot(fragColor.rgb, vec3(0.299, 0.587, 0.114)), 0, 1);
+        vec4 colored = color_overlay * gray;
+        
+        // Color Saturation
+        fragColor = mix(fragColor, colored, color_saturation);
+        fragColor.a = gray;
+        fragColor.rgb *= fragColor.a;
+
+        // MASKS //
+
+        // Vertical gradient + mask_gradient_amount
+        float vg = sqrt(texCoord_interp.y);
+        vg = (texCoord_interp.y <= mask_gradient_amount+.05f) ? mix(0, vg, (texCoord_interp.y-mask_gradient_amount)/.05f) : vg;
+        vg = texCoord_interp.y >= mask_gradient_amount ? vg : 0;
+
+        // Spherical gradient + mask_gradient_amount
+        float d = distance(texCoord_interp.xy, vec2(0.5f, 0.5f));
+        float m = (1.0f-mask_gradient_amount)*.5f;
+        float sg = 1-pow(d*2, 2.f);
+        sg = (d >= m-.05f) ? mix(0, sg, (m-d)/.05f) : sg;
+        sg = (d <= m) ? sg : 0;
+
+        // Gradient Type
+        float grad = mix(sg, vg, mask_gradient_type);
+
+        // Gradient Switch
+        fragColor.a = mix(fragColor.a, grad*fragColor.a, mask_gradient_switch);
+
+        // Gradient Ring Switch
+        float ring = d < (1-mask_ring_outer_radius)*.575f ? 1 : 0;
+        ring = d < (1-mask_ring_inner_radius)*.55f ? 0 : ring;
+        fragColor.a = mix(fragColor.a, fragColor.a*ring, mask_ring_switch);
+        
+        // Top-Bottom
+        fragColor.a = texCoord_interp.y < (1-mask_top_to_bottom) ? fragColor.a : 0;
+        
+        // Bottom-Top
+        fragColor.a = texCoord_interp.y > mask_bottom_to_top ? fragColor.a : 0;
+
+        // Left-Right
+        fragColor.a = texCoord_interp.x > mask_left_to_right ? fragColor.a : 0;
+        
+        // Right-Left
+        fragColor.a = texCoord_interp.x < (1-mask_right_to_left) ? fragColor.a : 0;
+
+        // Diagonal Top-Right
+        fragColor.a = 1-(texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_right ? fragColor.a : 0;
+        
+        // Diagonal Top-Left
+        fragColor.a = 1-(1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_left ? fragColor.a : 0;
+        
+        // Diagonal Bottom-Right
+        fragColor.a = (1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_right ? fragColor.a : 0;
+
+        // Diagonal Bottom-Left
+        fragColor.a = (texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_left ? fragColor.a : 0;
+
+        // Panel bound clipping
+        if(gl_FragCoord.x < panel_point_left || gl_FragCoord.x > panel_point_right)
+            discard;
+    }
+'''
+
+border_vertex_shader= '''
+    uniform mat4 ModelViewProjectionMatrix;
+
+    #ifdef UV_POS
+    in vec2 u;
+    #  define pos u
+    #else
+    in vec2 pos;
+    #endif
+
+    void main()
+    {
+        gl_Position = ModelViewProjectionMatrix * vec4(pos, 0.0, 1.0);
+    }
+'''
+border_fragment_shader= '''
+    uniform vec4 color;
+    uniform vec2 panel_point_lt;
+    uniform vec2 panel_point_rb;
+    in vec4 gl_FragCoord;
+    out vec4 fragColor;
+
+    void main()
+    {
+        fragColor = color;
+
+        if(gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
+            fragColor.rgba = vec4(0);
+    }
+'''
+
+lightIconShader = gpu.types.GPUShader(vertex_shader, fragment_shader)
+lightIconShader.bind()
+
+border_shader2Dcolor = gpu.types.GPUShader(border_vertex_shader, border_fragment_shader)
+border_shader2Dcolor.bind()
+
+class Rectangle:
+    def __init__(self, start_point, width, height):
+        self.point_lt = Vector((
+            min(start_point.x, start_point.x+width),
+            max(start_point.y, start_point.y+height),
+            ))
+        self.point_rb = Vector((
+            max(start_point.x, start_point.x+width),
+            min(start_point.y, start_point.y+height),
+            ))
+
+        self.rot = 0
+
+    @property
+    def loc(self):
+        return (self.point_lt + self.point_rb)/2
+
+    @loc.setter
+    def loc(self, loc):
+        d = loc - self.loc
+        self.point_lt += d
+        self.point_rb += d
+    
+    @property
+    def width(self):
+        return self.point_rb.x - self.point_lt.x
+
+    @width.setter
+    def width(self, width):
+        d = width - self.width
+        self.point_lt.x -= d/2
+        self.point_rb.x = self.point_lt.x + width
+
+    @property
+    def height(self):
+        return self.point_lt.y - self.point_rb.y
+
+    @height.setter
+    def height(self, height):
+        d = height - self.height
+        self.point_lt.y += d/2
+        self.point_rb.y = self.point_lt.y - height
+
+    def get_verts(self):
+        def rotate(x1, y1, offset):
+            x1 -= offset.x
+            y1 -= offset.y
+            x2 = cos(self.rot) * x1 - sin(self.rot) * y1
+            y2 = sin(self.rot) * x1 + cos(self.rot) * y1
+            x2 += offset.x
+            y2 += offset.y
+            return [x2, y2]
+        
+        loc = self.loc # prevent property from recomputing
+        return (
+            rotate(self.point_lt.x, self.point_lt.y, loc),
+            rotate(self.point_lt.x, self.point_rb.y, loc),
+            rotate(self.point_rb.x, self.point_lt.y, loc),
+            rotate(self.point_rb.x, self.point_rb.y, loc),
+        )
+
+    def get_tex_coords(self):
+        return ([0, 1], [0, 0], [1, 1], [1, 0])
+
+    def move(self, loc_diff):
+        rect = self.panel if hasattr(self, 'panel') else self
+
+        new_loc = self.loc + loc_diff
+        new_loc.x = clamp(rect.point_lt.x, new_loc.x, rect.point_rb.x)
+        new_loc.y = clamp(rect.point_rb.y, new_loc.y, rect.point_lt.y)
+        self.loc = new_loc
+
+def send_light_to_bottom(light):
+    light = LightImage.selected_object if not light else light
+    if not light:
+        return
+    lights = LightImage.lights
+    lights.insert(0, lights.pop(lights.index(light)))
+
+def send_light_to_top(light):
+    light = LightImage.selected_object if not light else light
+    if not light:
+        return
+    lights = LightImage.lights
+    lights.append(lights.pop(lights.index(light)))
+
+class Panel(Rectangle):
+    def __init__(self, loc, width, height):
+        super().__init__(loc, width, height)
+        self.button_exit = Button(Vector((0,0)), 'X', 30)
+        self.button_exit.function = lambda x: "FINISHED"
+
+        self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
+        self.button_send_to_bottom.function = send_light_to_bottom
+
+        self._move_buttons()
+
+    def _move_buttons(self):
+        self.button_exit.loc = Vector((
+            self.point_rb.x - self.button_exit.dimensions[0]/4,
+            self.point_lt.y - self.button_exit.dimensions[1]/4,
+        ))
+
+        self.button_send_to_bottom.loc = Vector((
+            self.point_lt.x + self.button_send_to_bottom.dimensions[0]/2,
+            self.point_rb.y - self.button_exit.dimensions[1]/2,
+        ))
+
+    def draw(self):
+        shader2Dcolor.uniform_float("color", (0.05, 0.05, 0.05, 1))
+        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
+
+    def move(self, loc_diff):
+        super().move(loc_diff)
+
+        for l in LightImage.lights:
+            l.update_visual_location()
+        
+        self._move_buttons()
+
+class Button(Rectangle):
+    buttons = []
+    def __init__(self, loc, text, size=15):
+        self.font_size = size
+        self.font_color = (.25, .25, .25, 1)
+        self.bg_color = (.5, .5, .5, 1)
+        self.bg_color_selected = (.7, .7, .7, 1)
+        self.font_id = len(Button.buttons)
+        self.text = text
+        blf.color(self.font_id, *self.font_color)
+        blf.position(self.font_id, *loc, 0)
+        blf.size(self.font_id, self.font_size, 72)
+        self.dimensions = blf.dimensions(self.font_id, text)
+        self.function = lambda args : None
+
+        super().__init__(loc, self.dimensions[0]+5, self.dimensions[1]+5)
+        Button.buttons.append(self)
+
+    def draw(self, mouse_x, mouse_y):
+        # draw something to refresh buffer?
+        shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
+        batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
+
+        if is_in_rect(self, Vector((mouse_x, mouse_y))):
+            shader2Dcolor.uniform_float("color", self.bg_color_selected)
+        else:
+            shader2Dcolor.uniform_float("color", self.bg_color)
+        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
+        blf.size(self.font_id, self.font_size, 72)
+        blf.position(self.font_id, self.point_lt.x + 2.5, self.point_rb.y + 2.5, 0)
+        blf.draw(self.font_id, self.text)
+
+    def click(self, args=None):
+        return self.function(args)
+
+view_layers = []
+
+class Border(Rectangle):
+    weight = 5
+
+    def __init__(self, light_image, color):
+        self.color = color
+        self.light_image = light_image
+        super().__init__(Vector((0, 0)), 100, 100)
+
+    def draw(self):
+        verts = self.get_verts()
+        lleft = min(verts, key=lambda v: v[0])[0]
+        lright = max(verts, key=lambda v: v[0])[0]
+
+        bleft = self.light_image.panel.point_lt[0]
+        bright = self.light_image.panel.point_rb[0]
+
+        from mathutils import Euler
+        rot_translate = Vector((self.weight, 0, 0))
+        rot_translate.rotate(Euler((0,0,self.rot)))
+        rot_translate_ort = Vector((-rot_translate.y, rot_translate.x))
+
+                #       0   1
+        # 0  lt.x, lt.y         0 2
+        # 1  lt.x, rb.y         1 3
+        # 2  rb.x, lt.y
+        # 3  rb.x, rb.y
+
+        left_verts = [
+            verts[0],
+            verts[1],
+            [verts[0][0]+rot_translate.x, verts[0][1]+rot_translate.y],
+            [verts[1][0]+rot_translate.x, verts[1][1]+rot_translate.y]
+        ]
+
+        right_verts = [
+            [verts[2][0]-rot_translate.x, verts[2][1]-rot_translate.y],
+            [verts[3][0]-rot_translate.x, verts[3][1]-rot_translate.y],
+            verts[2],
+            verts[3]
+        ]
+
+        top_verts = [
+            verts[0],
+            [verts[0][0]-rot_translate_ort.x, verts[0][1]-rot_translate_ort.y],
+            verts[2],
+            [verts[2][0]-rot_translate_ort.x, verts[2][1]-rot_translate_ort.y]
+        ]
+
+        bottom_verts = [
+            [verts[1][0]+rot_translate_ort.x, verts[1][1]+rot_translate_ort.y],
+            verts[1],
+            [verts[3][0]+rot_translate_ort.x, verts[3][1]+rot_translate_ort.y],
+            verts[3]
+        ]
+        
+        border_shader2Dcolor.bind()
+        bgl.glEnable(bgl.GL_BLEND);
+        border_shader2Dcolor.uniform_float("color", self.color)
+        border_shader2Dcolor.uniform_float("panel_point_lt", self.light_image.panel.point_lt)
+        border_shader2Dcolor.uniform_float("panel_point_rb", self.light_image.panel.point_rb)
+        if lleft < bleft:
+            left_verts2 = deepcopy(left_verts)
+            for v in left_verts2:
+                v[0] += self.light_image.panel.width
+
+            right_verts2 = deepcopy(right_verts)
+            for v in right_verts2:
+                v[0] += self.light_image.panel.width
+            
+            top_verts2 = deepcopy(top_verts)
+            for v in top_verts2:
+                v[0] += self.light_image.panel.width
+            
+            bottom_verts2 = deepcopy(bottom_verts)
+            for v in bottom_verts2:
+                v[0] += self.light_image.panel.width
+
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(border_shader2Dcolor)
+        elif lright > bright:
+            left_verts2 = deepcopy(left_verts)
+            for v in left_verts2:
+                v[0] -= self.light_image.panel.width
+
+            right_verts2 = deepcopy(right_verts)
+            for v in right_verts2:
+                v[0] -= self.light_image.panel.width
+            
+            top_verts2 = deepcopy(top_verts)
+            for v in top_verts2:
+                v[0] -= self.light_image.panel.width
+            
+            bottom_verts2 = deepcopy(bottom_verts)
+            for v in bottom_verts2:
+                v[0] -= self.light_image.panel.width
+
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(border_shader2Dcolor)
+        
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(border_shader2Dcolor)
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(border_shader2Dcolor)
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(border_shader2Dcolor)
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(border_shader2Dcolor)
+        bgl.glDisable(bgl.GL_BLEND);
+
+    def get_verts(self):
+        self.point_lt = self.light_image.point_lt.copy()
+        self.point_rb = self.light_image.point_rb.copy()
+
+        self.point_lt.x -= self.weight
+        self.point_lt.y += self.weight
+
+        self.point_rb.x += self.weight
+        self.point_rb.y -= self.weight
+        
+        self.rot = self.light_image.rot
+
+        return super().get_verts()
+
+
+class LightImage(Rectangle):
+    selected_object = None
+    lights = []
+    @classmethod
+    def find_idx(cls, bls_light_collection):
+        for idx, l in enumerate(cls.lights):
+            if l._collection == bls_light_collection:
+                return idx
+        return -1
+    @classmethod
+    def remove(cls, bls_light_collection):
+        del cls.lights[cls.find_idx(bls_light_collection)]
+
+    def delete(self):
+        del LightImage.lights[LightImage.lights.index(self)]
+    
+    @classmethod
+    def refresh(cls):
+        cls.selected_object = None
+        for l in cls.lights:
+            try:
+                if l.update_from_bls():
+                    l.update_visual_location()
+            except ReferenceError:
+                l.delete()
+            
+    
+    default_size = 100
+    @classmethod
+    def change_default_size(cls, value):
+        cls.default_size = value
+        for l in cls.lights:
+            l.width = value * l._scale.y
+            l.height = value * l._scale.z
+        
+    def panel_loc_to_area_px_lt(self):
+        panel_px_loc = Vector((self.panel.width * self.panel_loc.x, -self.panel.height * (1-self.panel_loc.y)))
+        return panel_px_loc + self.panel.point_lt - Vector((LightImage.default_size*self._scale.y/2, LightImage.default_size*self._scale.z/2))
+    
+    def _update_panel_loc(self):
+        self.panel_loc.x = (self._bls_rot.x + pi) % (2*pi) / (2*pi)
+        self.panel_loc.y = fmod(self._bls_rot.y + pi/2, pi) / (pi)
+
+    def update_from_bls(self):
+        if self._bls_mesh.select_get():
+            LightImage.selected_object = self
+
+        updated = False
+        if self._bls_rot != self._bls_actuator.rotation_euler:
+            updated |= True
+            self._bls_rot = self._bls_actuator.rotation_euler.copy()
+        if self.rot != self._bls_mesh.rotation_euler.x:
+            updated |= True
+            self.rot = self._bls_mesh.rotation_euler.x
+        if self._scale != self._bls_mesh.scale:
+            updated |= True
+            self._scale = self._bls_mesh.scale.copy()
+            self.width = LightImage.default_size * self._scale.y
+            self.height = LightImage.default_size * self._scale.z
+        
+        if updated:
+            self._update_panel_loc()
+
+        if self._image_path != self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath:
+            updated |= True
+            self.image = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image
+            self._image_path = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath
+        # this should run when image changes but sometimes Blender looses images... so it's run every time to be safe
+        if self.image.gl_load():
+            raise Exception
+        
+
+        return updated
+
+    def update_bls(self):
+        self._bls_actuator.rotation_euler = self._bls_rot
+        self._bls_mesh.rotation_euler.x = self.rot
+
+    def __init__(self, context, panel, bls_light_collection):
+        self.panel = panel
+        self.__panel_loc = Vector((.5, .5))
+
+        self._collection = bls_light_collection
+        self._bls_mesh = [m for m in bls_light_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
+        self._bls_actuator = self._bls_mesh.parent
+        self._view_layer = find_view_layer(self._collection, context.view_layer.layer_collection)
+        
+        self._image_path = ""
+        self._bls_rot = None
+        self._scale = None
+
+        super().__init__(Vector((0,0)), LightImage.default_size, LightImage.default_size)
+        self.update_from_bls()
+        self.update_visual_location()
+        
+        LightImage.lights.append(self)
+
+        self.mute_border = Border(self, (.7, 0, 0, 1))
+        self.select_border = Border(self, (.2, .9, .2, 1))
+        self.select_border.weight = 2
+    
+    @property
+    def mute(self):
+        return self._view_layer.exclude
+    
+    @mute.setter
+    def mute(self, value):
+        self._view_layer.exclude = value
+
+    @property
+    def panel_loc(self):
+        return self.__panel_loc
+    
+    @panel_loc.setter
+    def panel_loc(self, pos):
+        self.__panel_loc = pos
+        self._bls_rot = Vector((
+            (self.panel_loc.x -.5) * (2*pi),
+            (self.panel_loc.y -.5) * (pi),
+            self._bls_rot.z
+        ))
+        self.update_visual_location() # update self.loc
+
+    def select(self):
+        if self.mute:
+            return
+        bpy.ops.object.select_all(action='DESELECT')
+        bpy.context.view_layer.objects.active = self._bls_mesh
+        self._bls_mesh.select_set(True)
+
+    def is_mouse_over(self, mouse_x, mouse_y):
+        def rotate(x1, y1, offset):
+            x1 -= offset.x
+            y1 -= offset.y
+            x2 = cos(-self.rot) * x1 - sin(-self.rot) * y1
+            y2 = sin(-self.rot) * x1 + cos(-self.rot) * y1
+            x2 += offset.x
+            y2 += offset.y
+            return [x2, y2]
+        
+        bleft = self.panel.point_lt[0]
+        bright = self.panel.point_rb[0]
+
+        if mouse_x > bright or mouse_x < bleft:
+            return False
+
+        tmouse_x, tmouse_y = rotate(mouse_x, mouse_y, self.loc)
+        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
+            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
+            return True
+        
+        tmouse_x, tmouse_y = rotate(bleft-(bright-mouse_x), mouse_y, self.loc)
+        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
+            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
+            return True
+
+        tmouse_x, tmouse_y = rotate(bright+(mouse_x-bleft), mouse_y, self.loc)
+        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
+            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
+            return True
+
+        return False
+
+    def draw(self):
+        try:
+            select = self._bls_mesh.select_get()
+        except ReferenceError:
+            return
+        
+        # draw something to refresh buffer?
+        shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
+        batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
+
+        bleft = self.panel.point_lt[0]
+        bright = self.panel.point_rb[0]
+        
+        verts = self.get_verts()
+        uv_coords = self.get_tex_coords()
+        
+        lleft = min(verts, key=lambda v: v[0])[0]
+        lright = max(verts, key=lambda v: v[0])[0]
+
+        if self.mute:
+            self.mute_border.draw()
+        if select:
+            self.select_border.draw()
+
+        lightIconShader.bind()
+        bgl.glActiveTexture(bgl.GL_TEXTURE0)
+        bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
+        lightIconShader.uniform_int("image", 0)
+
+        lightIconShader.uniform_float("panel_point_left", self.panel.point_lt.x)
+        lightIconShader.uniform_float("panel_point_right", self.panel.point_rb.x)
+
+        try:
+            # material properties
+            bls_node = self._bls_mesh.active_material.node_tree.nodes['Group']
+            intensity = bls_node.inputs['Intensity'].default_value
+
+            texture_switch = bls_node.inputs['Texture Switch'].default_value
+            color_overlay = bls_node.inputs['Color Overlay'].default_value
+            color_saturation = bls_node.inputs['Color Saturation'].default_value
+
+            lightIconShader.uniform_float("intensity", intensity)
+            lightIconShader.uniform_float("texture_switch", texture_switch)
+            lightIconShader.uniform_float("color_overlay", color_overlay)
+            lightIconShader.uniform_float("color_saturation", color_saturation)
+
+            mask_bottom_to_top = bls_node.inputs['Mask - Bottom to Top'].default_value
+            mask_diagonal_bottom_left = bls_node.inputs['Mask - Diagonal Bottom Left'].default_value
+            mask_diagonal_bottom_right = bls_node.inputs['Mask - Diagonal Bottom Right'].default_value
+            mask_diagonal_top_left = bls_node.inputs['Mask - Diagonal Top Left'].default_value
+            mask_diagonal_top_right = bls_node.inputs['Mask - Diagonal Top Right'].default_value
+            mask_gradient_amount = bls_node.inputs['Mask - Gradient Amount'].default_value
+            mask_gradient_switch = bls_node.inputs['Mask - Gradient Switch'].default_value
+            mask_gradient_type = bls_node.inputs['Mask - Gradient Type'].default_value
+            mask_left_to_right = bls_node.inputs['Mask - Left to Right'].default_value
+            mask_right_to_left = bls_node.inputs['Mask - Right to Left'].default_value
+            mask_ring_inner_radius = bls_node.inputs['Mask - Ring Inner Radius'].default_value
+            mask_ring_outer_radius = bls_node.inputs['Mask - Ring Outer Radius'].default_value
+            mask_ring_switch = bls_node.inputs['Mask - Ring Switch'].default_value
+            mask_top_to_bottom = bls_node.inputs['Mask - Top to Bottom'].default_value
+
+            lightIconShader.uniform_float("mask_bottom_to_top", mask_bottom_to_top)
+            lightIconShader.uniform_float("mask_diagonal_bottom_left", mask_diagonal_bottom_left)
+            lightIconShader.uniform_float("mask_diagonal_bottom_right", mask_diagonal_bottom_right)
+            lightIconShader.uniform_float("mask_diagonal_top_left", mask_diagonal_top_left)
+            lightIconShader.uniform_float("mask_diagonal_top_right", mask_diagonal_top_right)
+            lightIconShader.uniform_float("mask_gradient_amount", mask_gradient_amount)
+            lightIconShader.uniform_float("mask_gradient_switch", mask_gradient_switch)
+            lightIconShader.uniform_float("mask_gradient_type", mask_gradient_type)
+            lightIconShader.uniform_float("mask_left_to_right", mask_left_to_right)
+            lightIconShader.uniform_float("mask_right_to_left", mask_right_to_left)
+            lightIconShader.uniform_float("mask_ring_inner_radius", mask_ring_inner_radius)
+            lightIconShader.uniform_float("mask_ring_outer_radius", mask_ring_outer_radius)
+            lightIconShader.uniform_float("mask_ring_switch", mask_ring_switch)
+            lightIconShader.uniform_float("mask_top_to_bottom", mask_top_to_bottom)
+        except:
+            pass
+        bgl.glEnable(bgl.GL_BLEND);
+
+        if lleft < bleft:
+            verts2 = deepcopy(verts)
+            for v in verts2:
+                v[0] += self.panel.width
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts,
+                    "texCoord": uv_coords,
+                }
+            ).draw(lightIconShader)
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts2,
+                    "texCoord": uv_coords,
+                }
+            ).draw(lightIconShader)
+        elif lright > bright:
+            verts2 = deepcopy(verts)
+            for v in verts2:
+                v[0] -= self.panel.width
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts,
+                    "texCoord": uv_coords,
+                }
+            ).draw(lightIconShader)
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts2,
+                    "texCoord": uv_coords,
+                }
+            ).draw(lightIconShader)
+        else:
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts,
+                    "texCoord": self.get_tex_coords(),
+                }
+            ).draw(lightIconShader)
+        bgl.glDisable(bgl.GL_BLEND);
+
+    def update_visual_location(self):
+        self.loc = self.panel_loc_to_area_px_lt() + Vector((self.width/2, self.height/2))
+
+    def move(self, loc_diff):
+        super().move(loc_diff)
+
+        self.panel_loc = Vector((
+            (self.loc.x-self.panel.loc.x) / self.panel.width +.5,
+            clamp(0.0001, (self.loc.y-self.panel.loc.y) / self.panel.height +.5, 0.9999),
+        ))
+
+        self.update_bls()
+
+def is_in_rect(rect, loc):
+    return (loc.x >= rect.point_lt.x and loc.x <= rect.point_rb.x) and (loc.y >= rect.point_rb.y and loc.y <= rect.point_lt.y)
+
+def clamp(minimum, x, maximum):
+    return max(minimum, min(x, maximum))
+
+class ClickManager:
+    def __init__(self):
+        self.times = [0, 0, 0]
+        self.objects = [None, None, None]
+    
+    def click(self, object):
+        self.times.append(time.time())
+        self.objects.append(object)
+        if len(self.times) > 3:
+            del self.times[0]
+            del self.objects[0]
+        
+        if self.objects[0] == self.objects[1] == self.objects[2]:
+            if self.times[2] - self.times[0] <= .5:
+                return "TRIPLE"
+        if self.objects[1] == self.objects[2]:
+            if self.times[2] - self.times[1] <= .5:
+                return "DOUBLE"
+
+class MouseWidget:
+    mouse_x: bpy.props.IntProperty()
+    mouse_y: bpy.props.IntProperty()
+    
+    def __init__(self):
+        self._start_position = Vector((0, 0))
+        self._end_position = Vector((0, 0))
+        self._reference_end_position = Vector((0, 0))
+        self._base_rotation = 0
+        self.handler = None
+
+        self.draw_guide = True
+
+        self.allow_xy_keys = False
+        self.x_key = False
+        self.y_key = False
+
+        self.continous = False
+
+        self.allow_precision_mode = False
+        self.precision_mode = False
+        self.precision_offset = Vector((0,0))
+
+    def invoke(self, context, event):
+        mouse_x = event.mouse_x - context.area.x
+        mouse_y = event.mouse_y - context.area.y
+
+        self._start_position = Vector((self.mouse_x, self.mouse_y))
+        self._end_position = Vector((mouse_x, mouse_y))
+        self._reference_end_position = self._end_position
+        vec = self._end_position - self._start_position
+        self._base_rotation = atan2(vec.y, vec.x)
+
+        self.handler = bpy.types.SpaceView3D.draw_handler_add(self._draw, (context, event,), 'WINDOW', 'POST_PIXEL')
+        context.window_manager.modal_handler_add(self)
+
+    def _cancel(self, context, event): pass
+    def _finish(self, context, event): pass
+
+    def modal(self, context, event):
+        # print(event.type, event.value)
+        if not context.area:
+            self._unregister_handler()
+            self._cancel(context, event)
+            return {"CANCELLED"}
+
+        if event.type in {"ESC", "RIGHTMOUSE"}:
+            self._unregister_handler()
+            self._cancel(context, event)
+            return {'CANCELLED'}
+
+        if event.type == "RET" or (not self.continous and event.type == "LEFTMOUSE"):
+            self._unregister_handler()
+            self._finish(context, event)
+            return {'FINISHED'}
+
+        if self.continous and event.value == "RELEASE" and event.type == "LEFTMOUSE":
+            self._unregister_handler()
+            self._finish(context, event)
+            return {'FINISHED'}
+
+        self.mouse_x = event.mouse_x - context.area.x
+        self.mouse_y = event.mouse_y - context.area.y
+        self._end_position = Vector((self.mouse_x, self.mouse_y))
+        
+        if self.allow_xy_keys:
+            if event.value == "PRESS":
+                if event.type == "X":
+                    self.x_key = not self.x_key
+                    self.y_key = False
+                if event.type == "Y":
+                    self.y_key = not self.y_key
+                    self.x_key = False
+
+        if self.allow_precision_mode and event.value == "PRESS" and event.type == "LEFT_SHIFT":
+            self.precision_mode = True
+            self._precision_mode_mid_stop = self._end_position.copy()
+        elif self.allow_precision_mode and event.value == "RELEASE" and event.type == "LEFT_SHIFT" and self.precision_mode: #last condition in case when operator invoked with shift already pressed
+            self.precision_mode = False
+            self.precision_offset += self._end_position - self._precision_mode_mid_stop
+
+        return self._modal(context, event)
+
+    def __del__(self):
+        self._unregister_handler()
+
+    def _unregister_handler(self):
+        try:
+            bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
+        except (ValueError, AttributeError):
+            pass
+    
+    def length(self):
+        return (self._start_position - self._reference_end_position - self.delta_vector()).length
+    
+    def delta_vector(self):
+        if self.precision_mode:
+            return self._precision_mode_mid_stop - self._reference_end_position - self.precision_offset*.9 + (self._end_position - self._precision_mode_mid_stop) * .1
+        return self._end_position - self._reference_end_position - self.precision_offset*.9
+    
+    def delta_length_factor(self):
+        return self.length() / ((self._start_position - self._reference_end_position).length)
+
+    def angle(self):
+        vec = self._reference_end_position - self._start_position + self.delta_vector() + self.precision_offset*.9
+        return atan2(vec.y, vec.x) - self._base_rotation
+
+    def _draw(self, context, event):
+        # first draw to reset buffer
+        shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
+        batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0,0), (0,0))}).draw(shader2Dcolor)
+        
+        if self.draw_guide:
+            shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
+            batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position[:]), (self._end_position[:]))}).draw(shader2Dcolor)
+
+        if self.allow_xy_keys:
+            if self.x_key:
+                shader2Dcolor.uniform_float("color", (1, 0, 0, .5))
+                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0, self._start_position.y), (context.area.width, self._start_position.y))}).draw(shader2Dcolor)
+            elif self.y_key:
+                shader2Dcolor.uniform_float("color", (0, 1, 0, .5))
+                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position.x, 0), (self._start_position.x, context.area.height))}).draw(shader2Dcolor)
\ No newline at end of file
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Camera Flash 5600K.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Camera Flash 5600K.exr
new file mode 100644
index 0000000..9ecf821
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Camera Flash 5600K.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube A.hdr b/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube A.hdr
new file mode 100644
index 0000000..5407508
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube A.hdr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube B.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube B.exr
new file mode 100644
index 0000000..9953687
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Fluorescent Tube B.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Soft Box A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Soft Box A.exr
new file mode 100644
index 0000000..6352164
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Soft Box A.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area A.exr
new file mode 100644
index 0000000..5e448bf
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area A.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area B.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area B.exr
new file mode 100644
index 0000000..3dc61b5
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area B.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area C.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area C.exr
new file mode 100644
index 0000000..46a188c
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area C.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area D.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area D.exr
new file mode 100644
index 0000000..7f2ce35
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Area D.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Disc A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Disc A.exr
new file mode 100644
index 0000000..b0f8bc5
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Disc A.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Octagon A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Octagon A.exr
new file mode 100644
index 0000000..a77bffe
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Octagon A.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring A.exr
new file mode 100644
index 0000000..ea03d03
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring A.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring B.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring B.exr
new file mode 100644
index 0000000..6c38cfb
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Synthetic Ring B.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Television A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Television A.exr
new file mode 100644
index 0000000..a12cc96
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Television A.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Umbrella A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Umbrella A.exr
new file mode 100644
index 0000000..9d5e73b
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Umbrella A.exr differ
diff --git a/skrypt/leomoon_lightstudio/textures_real_lights/Window A.exr b/skrypt/leomoon_lightstudio/textures_real_lights/Window A.exr
new file mode 100644
index 0000000..3c53a77
Binary files /dev/null and b/skrypt/leomoon_lightstudio/textures_real_lights/Window A.exr differ
diff --git a/src/__init__.py b/src/__init__.py
index f514c72..d5d96fd 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -4,7 +4,7 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 5, 0),
+    "version": (2, 5, 1),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
diff --git a/src/light_profiles.py b/src/light_profiles.py
index e87064d..0a25728 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -3,6 +3,7 @@ from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProper
 import os
 from . common import *
 from itertools import chain
+from . operators.modal import close_control_panel
 
 _ = os.sep
 
@@ -142,6 +143,83 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
  
         return{'FINISHED'}
     
+def duplicate_collection(collection, parent_collection):
+    new_collection = bpy.data.collections.new(collection.name)
+    
+    new_names = {}
+    matrix_data = {}
+    
+    for obj in collection.objects:
+        new_obj = obj.copy()
+        
+        new_names[obj.name] = new_obj
+        matrix_data[new_obj.name] = {
+            "matrix_basis": obj.matrix_basis.copy(),
+            "matrix_local": obj.matrix_local.copy(),
+            "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
+            "matrix_world": obj.matrix_world.copy()
+            }
+        
+        if new_obj.data:
+            new_obj.data = obj.data.copy()
+        new_obj.parent = obj.parent
+        new_collection.objects.link(new_obj)
+    
+    for obj in new_collection.objects:
+        if obj.parent:
+            if obj.parent.name in new_names:
+                obj.parent = new_names[obj.parent.name]
+            obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
+            #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
+            obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
+            #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
+    
+    
+    if parent_collection:
+        parent_collection.children.link(new_collection)
+
+    iter_list = [collection.children]
+    parent_collection = new_collection
+
+    while len(iter_list) > 0:
+        new_iter_list = []
+        
+        for iter in iter_list:
+            for collection in iter:
+            
+                new_collection = bpy.data.collections.new(collection.name)
+                
+                for obj in collection.objects:
+                    new_obj = obj.copy()
+                    
+                    new_names[obj.name] = new_obj
+                    matrix_data[new_obj.name] = {
+                        "matrix_basis": obj.matrix_basis.copy(),
+                        "matrix_local": obj.matrix_local.copy(),
+                        "matrix_parent_inverse": obj.matrix_parent_inverse.copy(),
+                        "matrix_world": obj.matrix_world.copy()
+                        }
+                    
+                    if new_obj.data:
+                        new_obj.data = obj.data.copy()
+                    new_obj.parent = obj.parent
+                    new_collection.objects.link(new_obj)
+                    
+                for obj in new_collection.objects:
+                    if obj.parent:
+                        obj.parent = new_names[obj.parent.name]
+                        obj.matrix_basis = matrix_data[obj.name]["matrix_basis"]
+                        #obj.matrix_local = matrix_data[obj.name]["matrix_local"]
+                        obj.matrix_parent_inverse = matrix_data[obj.name]["matrix_parent_inverse"]
+                        #obj.matrix_world = matrix_data[obj.name]["matrix_world"]
+                    
+                parent_collection.children.link(new_collection)
+                
+                if len(collection.children) > 0:
+                    new_iter_list.append(collection.children)
+
+        iter_list = new_iter_list
+    return parent_collection
 
 class LIST_OT_CopyItem(bpy.types.Operator):
 
@@ -160,102 +238,26 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         index = props.list_index
         
         scene = context.scene
-        
-        # all objects on all layers visible
-        oldlaysArea = context.area.spaces[0].layers[:]
-        oldlaysScene = context.scene.layers[:]
-        context.area.spaces[0].layers = [True]*20
-        context.scene.layers = [True]*20
-        
-        obsToCopy = family(context.scene.objects[props.last_empty])
-        
-        for ob in context.selected_objects: ob.select = False
-        for ob in obsToCopy:
-            if ob.name.startswith('LLS_PROFILE.'): continue
-            ob.hide_select = False
-            ob.hide = False
-            ob.select = True
-            
-            
-        # before
-        A = set(scene.objects[:])
-        
-        bpy.ops.object.duplicate()
-        
-        # after operation
-        B = set(scene.objects[:])
 
-        # whats the difference
-        new_objects = (A ^ B)
-        
-        # make light material single user and update selection drivers]
-        bpy.ops.group.objects_remove_all()
-        bpy.ops.group.create(name='LLS_Light')
-        
-        for lg in new_objects:
-            if lg.name.startswith('LLS_LIGHT_GRP.'):
-                controller = [c for c in family(lg) if c.name.startswith("LLS_CONTROLLER.")][0]
-                lmesh = [l for l in family(lg) if l.name.startswith("LLS_LIGHT_MESH.")][0]
-                
-                light_mat = None
-                for id, mat in enumerate(controller.data.materials):
-                    if mat.name.startswith('LLS_icon_ctrl'):
-                        mat = mat.copy()
-                        controller.data.materials[id] = mat
-                        
-                        for d in mat.animation_data.drivers:
-                            d.driver.variables[0].targets[0].id = scene.objects['LLS_LIGHT_MESH.'+controller.name.split('.')[1]]
-                        
-                        for d in mat.node_tree.animation_data.drivers:
-                            for v in d.driver.variables:
-                                v.targets[0].id = scene.objects['LLS_LIGHT_MESH.'+controller.name.split('.')[1]]
-                                
-                    elif mat.name.startswith('LLS_light'):
-                        #mat = mat.copy()
-                        light_mat = mat.copy()
-                        controller.data.materials[id] = light_mat
-                        light_mat.node_tree.nodes['Light Texture'].image = light_mat.node_tree.nodes['Light Texture'].image.copy()
-                        
-                for id, mat in enumerate(lmesh.data.materials):
-                    if mat.name.startswith('LLS_light'):
-                        lmesh.data.materials[id] = light_mat               
-                            
-        # revert visibility
-        for ob in chain(obsToCopy, new_objects):
-            ob.hide = True
-            ob.hide_select = True
-            
-            if ob.name.startswith('LLS_LIGHT_MESH.') or \
-               ob.name.startswith('LLS_HANDLE') or \
-               ob.name.startswith('LLS_CONTROLLER.'):
-                ob.hide = False
-                ob.hide_select = False
-                
-        profileName = props.profile_list[props.list_index].name
-        
-        bpy.ops.lls_list.new_profile(handle=False)
-        lastItemId = len(props.profile_list)-1
-        
-        # parent objects to new profile
-        for ob in new_objects:
-            scene.objects.unlink(ob)
-            if ob.name.startswith('LLS_LIGHT_GRP.'):
-                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
-            elif ob.name.startswith('LLS_HANDLE.'):
-                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
-                
-            
-        props.profile_list[len(props.profile_list)-1].name = profileName + ' Copy'
-        
+        lls_collection, profile_collection = llscol_profilecol(context)
+
+        profile_copy = duplicate_collection(profile_collection, None)
+        profile = [ob for ob in profile_copy.objects if ob.name.startswith('LLS_PROFILE')][0]
+        handle = [ob for ob in profile.children if ob.name.startswith('LLS_HANDLE')][0]
         
+        for l in [lm for lc in profile_copy.children if lc.name.startswith('LLS_Light') for lm in lc.objects if lm.name.startswith('LLS_LIGHT_MESH')]:
+            l.constraints['Copy Location'].target = handle
+
+        new_list_item = props.profile_list.add()
+        new_list_item.empty_name = profile_copy.name_full
+        new_list_item.name = props.profile_list[props.list_index].name + ' Copy'
+
         # place copied profile next to source profile
+        lastItemId = len(props.profile_list)-1
         while lastItemId > props.list_index+1:
             list.move(lastItemId-1, lastItemId)
             lastItemId -= 1
         
-        context.area.spaces[0].layers = oldlaysArea
-        context.scene.layers = oldlaysScene
-        
         return{'FINISHED'}
     
     
@@ -313,7 +315,6 @@ class LIST_OT_MoveItem(bpy.types.Operator):
 
 def update_list_index(self, context):
     props = context.scene.LLStudio
-    lls_collection = get_lls_collection(context)
     
     if len(props.profile_list) == 0: return
         
@@ -324,9 +325,10 @@ def update_list_index(self, context):
     print('Index update {}'.format(self.list_index))
         
     #unlink current profile
-    prof_idx = context.scene.objects.find(props.last_empty)
-    if prof_idx > -1: # in case of update after deletion
-        profile_collection = context.scene.objects[prof_idx].users_collection[0]
+    lls_collection = get_lls_collection(context)
+    profile_collection = [c for c in lls_collection.children if c.name.startswith('LLS_PROFILE')]
+    profile_collection = profile_collection[0] if profile_collection else None
+    if profile_collection:
         lls_collection.children.unlink(profile_collection)
         
     #link selected profile
@@ -335,7 +337,8 @@ def update_list_index(self, context):
     props.last_empty = selected_profile.empty_name
 
     from . operators.modal import update_light_sets, panel_global
-    update_light_sets(panel_global, bpy.context, always=True)
+    if panel_global:
+        update_light_sets(panel_global, bpy.context, always=True)
         
 # import/export
 import json, time
@@ -591,12 +594,14 @@ class CopyProfileToScene(bpy.types.Operator):
         
         profiles = [compose_profile(index),]
         
-        context.screen.scene = bpy.data.scenes[self.sceneprop]
+        context.window.scene = bpy.data.scenes[self.sceneprop]
         context.scene.render.engine = 'CYCLES'
         if not context.scene.LLStudio.initialized:
             bpy.ops.scene.create_leomoon_light_studio()
         
         parse_profile(context, context.scene.LLStudio, profiles, internal_copy=True)
+
+        close_control_panel()
         
         return{'FINISHED'}
         
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 629d31c..3ce8307 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -355,7 +355,12 @@ class LLS_OT_control_panel(bpy.types.Operator):
                             self.clicked_object.mute = not self.clicked_object.mute
 
                     if hasattr(self.clicked_object, 'select'):
-                        self.clicked_object.select()
+                        try:
+                            self.clicked_object.select()
+                        except RuntimeError:
+                            print("Stale panel context. Panel closed.")
+                            close_control_panel()
+
                         if self.ctrl and len(overlapped)>1:
                             send_light_to_bottom(self.clicked_object)
                             self.find_clicked(area_mouse_x, area_mouse_y).select()

commit 4e2609a34dbc0a5d13e6d327441dc94c0c37450e
Merge: e8aeacd bb28f41
Author: StyriamMZ <47333958+StyriamMZ@users.noreply.github.com>
Date:   Fri May 8 19:02:52 2020 +0200

    Merge pull request #1 from leomoon-studios/master
    
    Merged

commit bb28f41fc61edbf1152393716deca4a93b35a1e9
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Apr 17 14:18:18 2020 -0700

    fxied release date in readme

diff --git a/README.md b/README.md
index abb1ecb..d6b892f 100644
--- a/README.md
+++ b/README.md
@@ -43,7 +43,7 @@ If you think this plugin speeds up your workflow, consider funding the developme
 Thank you.
 
 ## Changelog
-### 2.5.0 2019-03-23:
+### 2.5.0 2020-03-23:
 * Fixed LightStudio error when opening Bledner 2.8x
 * Fixed LightStudio error when deleting studio
 * Fixed strange behaviour when clicking LightStudio Control Panel multiple times

commit f494833e10a023e72cd753c580f6d4f1deaf38e2
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Apr 17 14:11:10 2020 -0700

    changed readme

diff --git a/README.md b/README.md
index 24c8c0c..abb1ecb 100644
--- a/README.md
+++ b/README.md
@@ -1,9 +1,9 @@
 # LeoMoon LightStudio
 ## Important Notice
-LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)**. You can **[download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)** and use it without any limitations. The purpose of this product page is to raise funds to fix the bugs, improve the user interface and add new features.
+LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)**. You can **[download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)** and use it without any limitations.
 
 ## Development Fund
-If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
+If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**. This will help to fix bugs, improve user interface and add new features.
 
 ## Introduction
 [![LeoMoon LightStudio 2.5.0 Demo](https://img.youtube.com/vi/XT_m2E_qsaU/sddefault.jpg)](https://www.youtube.com/watch?v=XT_m2E_qsaU)

commit f0a82480206dad1e2e31b8716aa316c8958fb470
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Mar 23 11:11:29 2020 -0700

    updated youtube link in readme.md

diff --git a/README.md b/README.md
index ea8a566..24c8c0c 100644
--- a/README.md
+++ b/README.md
@@ -6,7 +6,7 @@ LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and
 If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
 
 ## Introduction
-[![LeoMoon LightStudio 2.4.1 Beta Demo](https://img.youtube.com/vi/jwirtdK7cpQ/sddefault.jpg)](https://www.youtube.com/watch?v=jwirtdK7cpQ)
+[![LeoMoon LightStudio 2.5.0 Demo](https://img.youtube.com/vi/XT_m2E_qsaU/sddefault.jpg)](https://www.youtube.com/watch?v=XT_m2E_qsaU)
 
 LeoMoon LightStudio (formerly known as Blender Light Studio) is the easiest, fastest and most advanced lighting system for Blender 2.8x. LeoMoon LightStudio is packed with features and the new Light Node has so many options so you can customize each light exactly the way you want.
 

commit 47f588a3f2a7ce6f343b103b9ecac9be7935c77c
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Mar 23 09:58:10 2020 -0700

    added back readme

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..ea8a566
--- /dev/null
+++ b/README.md
@@ -0,0 +1,67 @@
+# LeoMoon LightStudio
+## Important Notice
+LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)**. You can **[download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)** and use it without any limitations. The purpose of this product page is to raise funds to fix the bugs, improve the user interface and add new features.
+
+## Development Fund
+If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
+
+## Introduction
+[![LeoMoon LightStudio 2.4.1 Beta Demo](https://img.youtube.com/vi/jwirtdK7cpQ/sddefault.jpg)](https://www.youtube.com/watch?v=jwirtdK7cpQ)
+
+LeoMoon LightStudio (formerly known as Blender Light Studio) is the easiest, fastest and most advanced lighting system for Blender 2.8x. LeoMoon LightStudio is packed with features and the new Light Node has so many options so you can customize each light exactly the way you want.
+
+Video below shows the options that are available per light.
+
+[![New Light Node](https://img.youtube.com/vi/bKVe2n2tGvs/sddefault.jpg)](https://www.youtube.com/watch?v=bKVe2n2tGvs)
+
+## Features
+* Add/Remove lights around objects
+* Add multiple light profiles
+* Easily switch between light profiles with a single click
+* Each light has many options to customize
+* All options per light can be animated
+* Each light can have a different light texture
+* Fastest render update while lighting
+* 15 Realistic HDR light textures included
+* Easy 2D manipulation of lights in the LightStudio Control Panel which translates to positioning of that light in 3D space
+* Toggle a light by double clicking on it in the LightPanel
+* Isolate a light by right clicking on it in the LightPanel
+* Lights can be added to different renders layers
+* Import/Export light profiles
+
+## Limitations
+LeoMoon LightStudio uses mesh lights and currently, EEVEE does not support mesh lights in real-time. Rendering is only supported in Cycles.
+
+## Background HDR vs Manual Lighting
+Why not use the other background HDR light plugins? That's because template based light plugins are predictable and limited. For product renders, you want lots of options and control, NOT templates! However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
+
+## Why Are You Selling This "Free" Plugin?
+Me and some generous donors, we've been funding LightStudio so far. This plugin is getting harder to develop and we need your help.
+
+If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
+
+Thank you.
+
+## Changelog
+### 2.5.0 2019-03-23:
+* Fixed LightStudio error when opening Bledner 2.8x
+* Fixed LightStudio error when deleting studio
+* Fixed strange behaviour when clicking LightStudio Control Panel multiple times
+* Fixed the ordering of LightStudio side panel
+* Improved the light node
+* Added all the light effect previews to the LightStudio Control Panel
+* Added light preview options for each light to the LightStudio Control Panel
+* Added LightStudio Keying Set to animate lights
+* Added Background Setup button to quickly setup the background optimized for lighting
+* Added missing/changed descriptions for a few buttons
+* Added a darker green border when lights are not selected
+* Moved rotate, move, and scale text from top to bottom where the info is usually displayed
+* Moved hotkeys help text to Hotkeys section in the side panel
+
+### 2.4.1 beta 2019-01-19:
+* Many bugfixes
+* LightStudio Control Panel is now using OpenGL
+
+### 2.4.0 beta:
+* Ported to Blender 2.8x
+* Added the new LightStudio Control Panel

commit cdbbfff7506675cdf6c0dd18158140c0387e61da
Merge: e8aeacd da6d40f
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Mar 23 09:56:25 2020 -0700

    merged from beta

commit da6d40fe45b08bb512cbff61aa4614dc6a564771
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Mar 23 09:28:59 2020 -0700

    lots of small improvements

diff --git a/README.md b/README.md
index e6a1bdb..ea8a566 100644
--- a/README.md
+++ b/README.md
@@ -5,16 +5,10 @@ LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and
 ## Development Fund
 If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
 
-**This plugin is currently in beta for Blender 2.8x. You might encounter bugs.**
-
 ## Introduction
 [![LeoMoon LightStudio 2.4.1 Beta Demo](https://img.youtube.com/vi/jwirtdK7cpQ/sddefault.jpg)](https://www.youtube.com/watch?v=jwirtdK7cpQ)
 
-LeoMoon LightStudio is the easiest, fastest and most advanced lighting system for Blender 2.8x.
-
-With Blender 2.8x we had to add a new OpenGL based LightPanel which makes the development much harder. We are now trying to add light previews.
-
-LeoMoon LightStudio is packed with features and the new Light Node has so many options so you can customize each light exactly the way you want.
+LeoMoon LightStudio (formerly known as Blender Light Studio) is the easiest, fastest and most advanced lighting system for Blender 2.8x. LeoMoon LightStudio is packed with features and the new Light Node has so many options so you can customize each light exactly the way you want.
 
 Video below shows the options that are available per light.
 
@@ -23,15 +17,15 @@ Video below shows the options that are available per light.
 ## Features
 * Add/Remove lights around objects
 * Add multiple light profiles
-* Each light has many options to customize
 * Easily switch between light profiles with a single click
+* Each light has many options to customize
 * All options per light can be animated
-* Each light can have different light texture
+* Each light can have a different light texture
 * Fastest render update while lighting
-* Realistic HDR light textures included
-* Easy 2D manipulation of light in the LightPanel which translates to 3D positioning of that light
-* Toggle light by double clicking on it in the LightPanel
-* Isolate light by right clicking on it in the LightPanel
+* 15 Realistic HDR light textures included
+* Easy 2D manipulation of lights in the LightStudio Control Panel which translates to positioning of that light in 3D space
+* Toggle a light by double clicking on it in the LightPanel
+* Isolate a light by right clicking on it in the LightPanel
 * Lights can be added to different renders layers
 * Import/Export light profiles
 
@@ -39,13 +33,35 @@ Video below shows the options that are available per light.
 LeoMoon LightStudio uses mesh lights and currently, EEVEE does not support mesh lights in real-time. Rendering is only supported in Cycles.
 
 ## Background HDR vs Manual Lighting
-Why not use the other background HDR light plugins? It's simple. Template based light plugins are for noobs! They are predictable and limited. For product renders, you want lots of options and control, NOT templates!
-
-However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
+Why not use the other background HDR light plugins? That's because template based light plugins are predictable and limited. For product renders, you want lots of options and control, NOT templates! However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
 
 ## Why Are You Selling This "Free" Plugin?
 Me and some generous donors, we've been funding LightStudio so far. This plugin is getting harder to develop and we need your help.
 
 If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
 
-Thank you.
\ No newline at end of file
+Thank you.
+
+## Changelog
+### 2.5.0 2019-03-23:
+* Fixed LightStudio error when opening Bledner 2.8x
+* Fixed LightStudio error when deleting studio
+* Fixed strange behaviour when clicking LightStudio Control Panel multiple times
+* Fixed the ordering of LightStudio side panel
+* Improved the light node
+* Added all the light effect previews to the LightStudio Control Panel
+* Added light preview options for each light to the LightStudio Control Panel
+* Added LightStudio Keying Set to animate lights
+* Added Background Setup button to quickly setup the background optimized for lighting
+* Added missing/changed descriptions for a few buttons
+* Added a darker green border when lights are not selected
+* Moved rotate, move, and scale text from top to bottom where the info is usually displayed
+* Moved hotkeys help text to Hotkeys section in the side panel
+
+### 2.4.1 beta 2019-01-19:
+* Many bugfixes
+* LightStudio Control Panel is now using OpenGL
+
+### 2.4.0 beta:
+* Ported to Blender 2.8x
+* Added the new LightStudio Control Panel
diff --git a/src/BLS3.blend b/src/BLS3.blend
deleted file mode 100644
index 5939dec..0000000
Binary files a/src/BLS3.blend and /dev/null differ
diff --git a/src/LLS3.blend b/src/LLS3.blend
new file mode 100644
index 0000000..1ec5e5c
Binary files /dev/null and b/src/LLS3.blend differ
diff --git a/src/__init__.py b/src/__init__.py
index e9b6f34..f514c72 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -6,7 +6,7 @@ bl_info = {
     "author": "LeoMoon Studios",
     "version": (2, 5, 0),
     "blender": (2, 80, 0),
-    "location": "View3D -> Tools -> Light Studio",
+    "location": "View3D -> Tools -> LightStudio",
     "wiki_url": "",
     "category": "User Interface" }
     
@@ -24,13 +24,13 @@ auto_load.init()
 # register
 ################################## 
 
-from . light_operators import Blender_Light_Studio_Properties
+from . light_operators import LeoMoon_Light_Studio_Properties
 from . import deleteOperator
 
 def register():
     auto_load.register()
 
-    bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
+    bpy.types.Scene.LLStudio = bpy.props.PointerProperty(name="LeoMoon LightStudio Properties", type = LeoMoon_Light_Studio_Properties)
     bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
     deleteOperator.add_shortkeys()
     
diff --git a/src/common.py b/src/common.py
index 67c38d9..f3d0e0a 100644
--- a/src/common.py
+++ b/src/common.py
@@ -9,22 +9,25 @@ def replace_link(object, collection_name):
         bpy.data.collections[collection_name].objects.link(object)
 
 def get_collection(object):
-    return [c for c in object.users_collection if c.name.startswith('BLS')][0]
-
-def get_bls_collection(context):
-    return [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-
-def blscol_profilecol_profile_handle(context):
-    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
-    profile = [ob for ob in profile_collection.objects if ob.name.startswith('BLS_PROFILE')][0]
-    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
-    return bls_collection, profile_collection, profile, handle
-
-def blscol_profilecol(context):
-    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
-    return bls_collection, profile_collection
+    return [c for c in object.users_collection if c.name.startswith('LLS')][0]
+
+def get_lls_collection(context):
+    return [c for c in context.scene.collection.children if c.name.startswith('LLS')][0]
+
+def llscol_profilecol_profile_handle(context):
+    lls_collection = [c for c in context.scene.collection.children if c.name.startswith('LLS')][0]
+    profile_collection = [c for c in lls_collection.children if c.name.startswith('LLS_PROFILE')][0]
+    profile = [ob for ob in profile_collection.objects if ob.name.startswith('LLS_PROFILE')][0]
+    handle = [ob for ob in profile.children if ob.name.startswith('LLS_HANDLE')][0]
+    return lls_collection, profile_collection, profile, handle
+
+def llscol_profilecol(context):
+    try:
+        lls_collection = [c for c in context.scene.collection.children if c.name.startswith('LLS')][0]
+        profile_collection = [c for c in lls_collection.children if c.name.startswith('LLS_PROFILE')][0]
+        return lls_collection, profile_collection
+    except IndexError:
+        return (None, None)
 
 def find_view_layer(collection, layer_collection):
     idx = layer_collection.children.find(collection.name)
@@ -46,11 +49,11 @@ def isFamily(ob=None):
     if not ob:
         ob = bpy.context.scene.objects.active
 
-    if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
-    if not ob.name.startswith('BLS_'): return False
+    if ob.name.startswith('LEOMOON_LIGHT_STUDIO'): return True
+    if not ob.name.startswith('LLS_'): return False
     while ob.parent:
         ob = ob.parent
-        if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
+        if ob.name.startswith('LEOMOON_LIGHT_STUDIO'): return True
     
     return False
 
@@ -71,33 +74,33 @@ def family(object):
 def findLightGrp(ob):
     while ob and ob.parent:
         ob = ob.parent
-        if ob.name.startswith('BLS_LIGHT.'): return ob
+        if ob.name.startswith('LLS_LIGHT.'): return ob
     return None
 
 def getLightMesh():
     #obs = bpy.context.scene.objects
     #lightGrp = obs.active
     #light_no = lightGrp.name.split('.')[1]
-    #return obs[obs.find('BLS_LIGHT_MESH.'+light_no)]
+    #return obs[obs.find('LLS_LIGHT_MESH.'+light_no)]
 
     lg = findLightGrp(bpy.context.active_object)
-    lm = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH")]
+    lm = [l for l in family(lg) if l.name.startswith("LLS_LIGHT_MESH")]
     return lm[0] if len(lm) else None
 
 def getLightController():
     obs = bpy.context.view_layer.objects
     lightGrp = obs.active
     light_no = lightGrp.name.split('.')[1]
-    return obs[obs.find('BLS_CONTROLLER.'+light_no)]
+    return obs[obs.find('LLS_CONTROLLER.'+light_no)]
 
 
 def findLightProfile(ob):
-    if ob.name.startswith('BLS_PROFILE'):
+    if ob.name.startswith('LLS_PROFILE'):
         return ob
     
     while ob.parent:
         ob = ob.parent
-        if ob.name.startswith('BLS_PROFILE'): return ob
+        if ob.name.startswith('LLS_PROFILE'): return ob
         
     return None
 
@@ -109,16 +112,16 @@ def getLightHandle(ob=None):
     if not p:
         return None
     
-    h = [h for h in p.children if h.name.startswith('BLS_HANDLE')]
+    h = [h for h in p.children if h.name.startswith('LLS_HANDLE')]
     if len(h):
         return h[0]
     else:
         return None
 
 def refreshMaterials():
-    #controllers = [ob for ob in family(findLightGrp(context.active_object).parent) if ob.name.startswith('BLS_CONTROLLER.')]
-    controllers = (ob for ob in bpy.context.scene.objects if ob.name.startswith('BLS_CONTROLLER.') and isFamily(ob))
+    #controllers = [ob for ob in family(findLightGrp(context.active_object).parent) if ob.name.startswith('LLS_CONTROLLER.')]
+    controllers = (ob for ob in bpy.context.scene.objects if ob.name.startswith('LLS_CONTROLLER.') and isFamily(ob))
     for cntrl in controllers:
-        mat = [m for m in cntrl.data.materials if m.name.startswith('BLS_icon_ctrl')][0]
+        mat = [m for m in cntrl.data.materials if m.name.startswith('LLS_icon_ctrl')][0]
         mixNode = mat.node_tree.nodes['Mix Shader'].inputs['Fac']
         mixNode.default_value = mixNode.default_value
\ No newline at end of file
diff --git a/src/deleteOperator.py b/src/deleteOperator.py
index f525d96..3d32825 100644
--- a/src/deleteOperator.py
+++ b/src/deleteOperator.py
@@ -22,7 +22,7 @@ class DeleteOperator(bpy.types.Operator):
             context.view_layer.objects.active = obj
             if hasattr(obj, 'use_fake_user'):
                 obj.use_fake_user = False
-            ret = bpy.ops.scene.delete_blender_studio_light()
+            ret = bpy.ops.scene.delete_leomoon_studio_light()
             if 'CANCELLED' in ret:
                 self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
         
diff --git a/src/gui.py b/src/gui.py
index 9d30015..cfcbab8 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -4,12 +4,12 @@ from . common import getLightMesh
 from . auto_load import force_register
 
 @force_register
-class BLS_PT_Studio(bpy.types.Panel):
-    bl_idname = "BLS_PT_studio"
+class LLS_PT_Studio(bpy.types.Panel):
+    bl_idname = "LLS_PT_studio"
     bl_label = "Studio"
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
-    bl_category = "Light Studio"
+    bl_category = "LightStudio"
     
     @classmethod
     def poll(cls, context):
@@ -18,155 +18,205 @@ class BLS_PT_Studio(bpy.types.Panel):
     def draw(self, context):
         layout = self.layout
         col = layout.column(align=True)
-        if not context.scene.BLStudio.initialized: col.operator('scene.create_blender_light_studio')
-        if context.scene.BLStudio.initialized: col.operator('scene.delete_blender_light_studio')
+        if not context.scene.LLStudio.initialized: col.operator('scene.create_leomoon_light_studio')
+        if context.scene.LLStudio.initialized: col.operator('scene.delete_leomoon_light_studio')
         col.separator()
         col.operator('light_studio.control_panel', icon='MENU_PANEL')
+        col.operator('scene.set_light_studio_background')
 
 @force_register
-class BLS_PT_Lights(bpy.types.Panel):
-    bl_idname = "BLS_PT_lights"
+class LLS_PT_Lights(bpy.types.Panel):
+    bl_idname = "LLS_PT_lights"
     bl_label = "Lights"
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
-    bl_category = "Light Studio"
+    bl_category = "LightStudio"
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.BLStudio.profile_list)
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.LLStudio.profile_list)
     
     def draw(self, context):
         layout = self.layout
         col = layout.column(align=True)
         row = col.row(align=True)
-        row.operator('scene.add_blender_studio_light', text='Add Light')
-        row.operator('scene.delete_blender_studio_light', text='Delete Light')
+        row.operator('scene.add_leomoon_studio_light', text='Add Light')
+        row.operator('scene.delete_leomoon_studio_light', text='Delete Light')
 
 @force_register
-class BLS_PT_Selected(bpy.types.Panel):
-    bl_idname = "BLS_PT_selected"
+class LLS_PT_Selected(bpy.types.Panel):
+    bl_idname = "LLS_PT_selected"
     bl_label = "Selected Light"
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
-    bl_category = "Light Studio"
+    bl_category = "LightStudio"
     
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
     
     def draw(self, context):
-        if context.active_object and (context.active_object.name.startswith('BLS_CONTROLLER') or context.active_object.name.startswith('BLS_LIGHT_MESH')):
+        if context.active_object and (context.active_object.name.startswith('LLS_CONTROLLER') or context.active_object.name.startswith('LLS_LIGHT_MESH')):
             layout = self.layout
             wm = context.window_manager
             
             col = layout.column(align=True)
-            col.operator('bls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
+            col.operator('lls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
             
             box = layout.box()
             col = box.column()
-            col.template_icon_view(wm, "bls_tex_previews", show_labels=True)
-            col.label(text=os.path.splitext(wm.bls_tex_previews)[0])
+            col.template_icon_view(wm, "lls_tex_previews", show_labels=True)
+            col.label(text=os.path.splitext(wm.lls_tex_previews)[0])
             
             layout.separator()
             try:
-                bls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
-                for input in bls_inputs[2:]:
+                lls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
+                for input in lls_inputs[2:]:
                     if input.type == "RGBA":
                         layout.prop(input, 'default_value', text=input.name)
                         col = layout.column(align=True)
                     else:
                         col.prop(input, 'default_value', text=input.name)
             except:
-                col.label(text="BLS_light material is not valid.")
+                col.label(text="LLS_light material is not valid.")
                 #import traceback
                 #traceback.print_exc()
             col.prop(getLightMesh(), 'location', index=0) #light radius
 
 @force_register
-class BLS_PT_ProfileList(bpy.types.Panel):
-    bl_idname = "BLS_PT_profile_list"
+class LLS_PT_ProfileList(bpy.types.Panel):
+    bl_idname = "LLS_PT_profile_list"
     bl_label = "Profiles"
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
-    bl_category = "Light Studio"
+    bl_category = "LightStudio"
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
             
     def draw(self, context):
         layout = self.layout
         scene = context.scene
         
-        props = scene.BLStudio
+        props = scene.LLStudio
         
         row = layout.row()
         col = row.column()
-        col.template_list("BLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
+        col.template_list("LLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
         
         col = row.column(align=True)
-        col.operator('bls_list.new_profile', icon='PLUS', text="")
-        col.operator('bls_list.delete_profile', icon='TRASH', text="")
-        col.operator('bls_list.copy_profile_menu', icon='DUPLICATE', text="")
+        col.operator('lls_list.new_profile', icon='PLUS', text="")
+        col.operator('lls_list.delete_profile', icon='TRASH', text="")
+        col.operator('lls_list.copy_profile_menu', icon='DUPLICATE', text="")
         
         col.separator()
-        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
-        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
+        col.operator('lls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
+        col.operator('lls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
 
 @force_register
-class BLS_PT_ProfileImportExport(bpy.types.Panel):
-    bl_idname = "BLS_PT_profile_import_export"
+class LLS_PT_ProfileImportExport(bpy.types.Panel):
+    bl_idname = "LLS_PT_profile_import_export"
     bl_label = "Import/Export"
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
-    bl_category = "Light Studio"
+    bl_category = "LightStudio"
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
             
     def draw(self, context):
         layout = self.layout
         scene = context.scene
               
         col = layout.column(align=True)
-        col.operator('bls_list.export_profiles', text="Export Selected Profile")
-        col.operator('bls_list.export_profiles', text="Export All Profiles").all=True
-        col.operator('bls_list.import_profiles')
+        col.operator('lls_list.export_profiles', text="Export Selected Profile")
+        col.operator('lls_list.export_profiles', text="Export All Profiles").all=True
+        col.operator('lls_list.import_profiles')
 
 from . import bl_info
 @force_register
-class BLS_PT_Misc(bpy.types.Panel):
-    bl_idname = "BLS_PT_misc"
+class LLS_PT_Misc(bpy.types.Panel):
+    bl_idname = "LLS_PT_misc"
     bl_label = "Misc"
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
-    bl_category = "Light Studio"
+    bl_category = "LightStudio"
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.LLStudio.initialized
                 
     def draw(self, context):
         layout = self.layout
         scene = context.scene
         
-        props = scene.BLStudio
+        props = scene.LLStudio
               
         col = layout.column(align=True)
-        col.operator('bls.find_missing_textures')
-        col.operator('bls.bls_keyingset')
+        col.operator('lls.find_missing_textures')
+        col.operator('lls.lls_keyingset')
         if context.scene.keying_sets.active and context.scene.keying_sets.active.bl_idname == "BUILTIN_KSI_LightStudio":
             box = col.box()
             box.label(text="Keying Set is active")
 
-class BLSKeyingSet(bpy.types.Operator):
-    """Activate Light Studio Keying Set to animate lights"""
-    bl_idname = "bls.bls_keyingset"
-    bl_description = "Activate Light Studio Keying Set to animate lights"
-    bl_label = "Light Studio Keying Set"
+class LLSKeyingSet(bpy.types.Operator):
+    bl_idname = "lls.lls_keyingset"
+    bl_description = "Activate LightStudio Keying Set to animate lights"
+    bl_label = "LightStudio Keying Set"
     bl_options = {"INTERNAL", "UNDO"}
-
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.LLStudio.profile_list)
+    
     def execute(self, context):
         context.scene.keying_sets.active = [k for k in context.scene.keying_sets_all if k.bl_idname == "BUILTIN_KSI_LightStudio"][0]
-        return {"FINISHED"}
\ No newline at end of file
+        return {"FINISHED"}
+
+@force_register
+class LLS_PT_Hotkeys(bpy.types.Panel):
+    bl_idname = "LLS_PT_hotkeys"
+    bl_label = "Hotkeys"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "UI"
+    bl_category = "LightStudio"
+    #bl_options = {'DEFAULT_CLOSED'}
+    
+    #@classmethod
+    #def poll(cls, context):
+    #    return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.LLStudio.initialized
+                
+    def draw(self, context):
+        layout = self.layout
+        scene = context.scene
+        
+        props = scene.LLStudio
+        
+        box = layout.box()
+
+        box.label(text="Move light", icon='MOUSE_LMB')
+        row = box.row(align=True)
+
+        row.label(text="Scale light", icon='EVENT_S')
+        row = box.row(align=True)
+
+        row.label(text="Rotate light", icon='EVENT_R')
+        row = box.row(align=True)
+
+        row.label(text="Precision mode", icon='EVENT_SHIFT')
+        row = box.row(align=True)
+        
+        box.label(text="Mute light", icon='MOUSE_LMB_DRAG')
+
+        box.label(text="Isolate light", icon='MOUSE_RMB')
+        row = box.row(align=True)
+
+        row.label(text="", icon='EVENT_CTRL')
+        row.label(text="Loop overlapping lights", icon='MOUSE_LMB')
+        row = box.row(align=True)
+
+        box.label(text="(numpad) Icon scale up", icon='ADD')
+
+        box.label(text="(numpad) Icon scale down", icon='REMOVE')
diff --git a/src/light_brush.py b/src/light_brush.py
index c30180a..0b3cc7f 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -86,7 +86,7 @@ def raycast(context, event, diff):
     
     #####
     profile = findLightGrp(context.active_object).parent
-    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
+    handle = [ob for ob in profile.children if ob.name.startswith('LLS_HANDLE')][0]
     lightmesh = getLightMesh()
     actuator = lightmesh.parent
     position = intersect_line_sphere(
@@ -109,9 +109,9 @@ def raycast(context, event, diff):
     deg = copysign(degrees(Vector.angle(Vector((x,y,z)), Vector((x,y,0)))), z)
     actuator.rotation_euler.y = copysign(Vector.angle(Vector((x,y,z)), Vector((x,y,0))), z)
 
-class BLSLightBrush(bpy.types.Operator):
+class LLSLightBrush(bpy.types.Operator):
     """Click on object to position light and reflection"""
-    bl_idname = "bls.light_brush"
+    bl_idname = "lls.light_brush"
     bl_label = "Light Brush"
     bl_options = {"UNDO"}
     
@@ -123,10 +123,10 @@ class BLSLightBrush(bpy.types.Operator):
         light = context.active_object
         return context.area.type == 'VIEW_3D' and \
                context.mode == 'OBJECT' and \
-               context.scene.BLStudio.initialized and \
+               context.scene.LLStudio.initialized and \
                light and \
                isFamily(light) and \
-               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+               not (light.name.startswith('LLS_PANEL') or light.name.startswith('LLS_PROFILE') or light.name.startswith('LLS_LIGHT_GRP'))
 
     def modal(self, context, event):
         print(event.type, event.value)
diff --git a/src/light_operators.py b/src/light_operators.py
index 746c383..c2b8462 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -10,7 +10,7 @@ _ = os.sep
 from . extensions_framework import util as efutil
 from . import bl_info
     
-class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
+class LeoMoon_Light_Studio_Properties(bpy.types.PropertyGroup):
     initialized: BoolProperty(default = False)    
     
     ''' Profile List '''
@@ -20,57 +20,57 @@ class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     
 
 class CreateBlenderLightStudio(bpy.types.Operator):
-    bl_idname = "scene.create_blender_light_studio"
-    bl_label = "Create Light Studio"
-    bl_description = "Append Blender Light Studio to current scene"
+    bl_idname = "scene.create_leomoon_light_studio"
+    bl_label = "Create LightStudio"
+    bl_description = "Append LeoMoon LightStudio to current scene"
     bl_options = {"REGISTER"}
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and not context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and not context.scene.LLStudio.initialized
     
     def execute(self, context):
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
 
-        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Collection'+_,
-        directory=os.path.join(dir,"BLS3.blend"+_+"Collection"+_),
-        filename="BLS",
+        bpy.ops.wm.append(filepath=_+'LLS3.blend'+_+'Collection'+_,
+        directory=os.path.join(dir,"LLS3.blend"+_+"Collection"+_),
+        filename="LLS",
         active_collection=False)
 
-        bpy.ops.bls_list.new_profile()
+        bpy.ops.lls_list.new_profile()
         
-        context.scene.BLStudio.initialized = True
+        context.scene.LLStudio.initialized = True
 
         bpy.context.scene.render.engine = 'CYCLES'
 
         # add the first light
         # bpy.ops.object.select_all(action='DESELECT')
-        # bpy.ops.scene.add_blender_studio_light()
+        # bpy.ops.scene.add_leomoon_studio_light()
         
         return {"FINISHED"}
-  
+
 class DeleteBlenderLightStudio(bpy.types.Operator):
-    bl_idname = "scene.delete_blender_light_studio"
-    bl_label = "Delete Studio"
-    bl_description = "Delete Blender Light Studio from current scene"
+    bl_idname = "scene.delete_leomoon_light_studio"
+    bl_label = "Delete LightStudio"
+    bl_description = "Delete LeoMoon LightStudio from current scene"
     bl_options = {"REGISTER"}
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
     
     def execute(self, context):
         scene = context.scene
-        scene.BLStudio.initialized = False
-
+        scene.LLStudio.initialized = False
+        
         # close control panel
         from . operators.modal import close_control_panel
         close_control_panel()
         
         ''' for each profile from this scene: delete objects then remove from list '''
-        while len(context.scene.BLStudio.profile_list):
-            bpy.ops.bls_list.delete_profile()
+        while len(context.scene.LLStudio.profile_list):
+            bpy.ops.lls_list.delete_profile()
             
         obsToRemove = [ob for ob in scene.objects if isFamily(ob)]
         for ob in obsToRemove:
@@ -80,7 +80,7 @@ class DeleteBlenderLightStudio(bpy.types.Operator):
             ob.use_fake_user = False
             bpy.data.objects.remove(ob)
             
-        context.scene.collection.children.unlink(get_bls_collection(context))
+        context.scene.collection.children.unlink(get_lls_collection(context))
         
         return {"FINISHED"}
      
@@ -91,30 +91,49 @@ class DeleteBlenderLightStudio(bpy.types.Operator):
     def draw(self, context):
         layout = self.layout
         col = layout.column(align=True)
-        col.label(text="Deleting Studio is irreversible!")
+        col.label(text="Deleting LightStudio is irreversible!")
         col.label(text="Your lighting setup will be lost.")
 
+class SetBackground(bpy.types.Operator):
+    bl_idname = "scene.set_light_studio_background"
+    bl_description = "Darken background and disable background influence"
+    bl_label = "Background Setup (Optional)"
+    bl_options = {"REGISTER", "UNDO"}
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.LLStudio.profile_list)
+    
+    def execute(self, context):
+        bpy.context.scene.world = bpy.data.worlds.new("LightStudio")
+        bpy.context.scene.world.use_nodes = True
+        bpy.context.scene.world.node_tree.nodes["Background"].inputs[0].default_value = (0.00802319, 0.00802319, 0.00802319, 1)
+        bpy.context.scene.world.cycles_visibility.diffuse = False
+        bpy.context.scene.world.cycles_visibility.glossy = False
+        bpy.context.scene.world.cycles_visibility.transmission = False
+        return {"FINISHED"}
+
 class AddBSLight(bpy.types.Operator):
-    bl_idname = "scene.add_blender_studio_light"
+    bl_idname = "scene.add_leomoon_studio_light"
     bl_label = "Add Studio Light"
-    bl_description = "Add Light to Studio"
+    bl_description = "Add a new light to studio"
     bl_options = {"REGISTER", "UNDO"}
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
     
     def execute(self, context):
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
         
         scene = context.scene
-        bls_collection, profile_collection, profile, handle = blscol_profilecol_profile_handle(context)
+        lls_collection, profile_collection, profile, handle = llscol_profilecol_profile_handle(context)
 
-        filepath = os.path.join(dir,"BLS3.blend")
+        filepath = os.path.join(dir,"LLS3.blend")
         # load a single scene we know the name of.
         with bpy.data.libraries.load(filepath) as (data_from, data_to):
-            data_to.collections = ["BLS_Light"]
+            data_to.collections = ["LLS_Light"]
             
         for collection in data_to.collections:
             if collection is not None:
@@ -123,11 +142,11 @@ class AddBSLight(bpy.types.Operator):
                 for ob in new_objects:
                     ob.use_fake_user = True
                 
-                blslight = [l for l in new_objects if l.name.startswith('BLS_LIGHT')][0]
-                blslight.parent = profile 
+                llslight = [l for l in new_objects if l.name.startswith('LLS_LIGHT')][0]
+                llslight.parent = profile 
                 
                 bpy.ops.object.select_all(action='DESELECT')
-                light = [p for p in new_objects if p.name.startswith('BLS_LIGHT_MESH')][0]
+                light = [p for p in new_objects if p.name.startswith('LLS_LIGHT_MESH')][0]
                 light.select_set(True)
                 context.view_layer.objects.active = light
         
@@ -146,9 +165,9 @@ class AddBSLight(bpy.types.Operator):
         return {"FINISHED"}
     
 class DeleteBSLight(bpy.types.Operator):
-    bl_idname = "scene.delete_blender_studio_light"
-    bl_label = "Delete BLS Light"
-    bl_description = "Delete selected Light from Studio"
+    bl_idname = "scene.delete_leomoon_studio_light"
+    bl_label = "Delete Studio Light"
+    bl_description = "Delete selected light from studio"
     bl_options = {"REGISTER", "UNDO"}
     
     @classmethod
@@ -156,17 +175,17 @@ class DeleteBSLight(bpy.types.Operator):
         light = context.active_object
         return context.area.type == 'VIEW_3D' and \
                context.mode == 'OBJECT' and \
-               context.scene.BLStudio.initialized and \
+               context.scene.LLStudio.initialized and \
                light and \
-               light.name.startswith('BLS_LIGHT') and \
-               not light.name.startswith('BLS_PROFILE')
+               light.name.startswith('LLS_LIGHT') and \
+               not light.name.startswith('LLS_PROFILE')
 
     def execute(self, context):
         scene = context.scene
         light = context.object
 
         for collection in light.users_collection:
-            if collection.name.startswith('BLS_Light'):
+            if collection.name.startswith('LLS_Light'):
                 bpy.ops.object.delete({"selected_objects": collection.objects}, use_global=True)
                 bpy.data.collections.remove(collection)
                 
@@ -187,22 +206,22 @@ class BUILTIN_KSI_LightStudio(bpy.types.KeyingSetInfo):
 
     # poll - test for whether Keying Set can be used at all
     def poll(ksi, context):
-        return context.active_object or context.selected_objects and context.scene.BLStudio.initialized
+        return context.active_object or context.selected_objects and context.scene.LLStudio.initialized
 
     # iterator - go over all relevant data, calling generate()
     def iterator(ksi, context, ks):
-        for ob in (l for l in context.selected_objects if l.name.startswith("BLS_LIGHT")):
+        for ob in (l for l in context.selected_objects if l.name.startswith("LLS_LIGHT")):
             ksi.generate(context, ks, ob)
 
     # generator - populate Keying Set with property paths to use
     def generate(ksi, context, ks, data):
         id_block = data.id_data
 
-        bls_collection = get_collection(id_block)
-        light_mesh = [m for m in bls_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
-        bls_actuator = light_mesh.parent
+        lls_collection = get_collection(id_block)
+        light_mesh = [m for m in lls_collection.objects if m.name.startswith("LLS_LIGHT_MESH")][0]
+        lls_actuator = light_mesh.parent
         
         ks.paths.add(light_mesh, "location", index=0, group_method='KEYINGSET')
         ks.paths.add(light_mesh, "rotation_euler", index=0, group_method='KEYINGSET')
         ks.paths.add(light_mesh, "scale", group_method='KEYINGSET')
-        ks.paths.add(bls_actuator, "rotation_euler", group_method='KEYINGSET')
\ No newline at end of file
+        ks.paths.add(lls_actuator, "rotation_euler", group_method='KEYINGSET')
\ No newline at end of file
diff --git a/src/light_preview_list.py b/src/light_preview_list.py
index 60bf71c..a45351a 100644
--- a/src/light_preview_list.py
+++ b/src/light_preview_list.py
@@ -83,14 +83,14 @@ def register():
     from bpy.types import WindowManager
     from bpy.props import EnumProperty
 
-    WindowManager.bls_tex_previews = EnumProperty(
+    WindowManager.lls_tex_previews = EnumProperty(
             items=enum_previews_from_directory_items,
             get=preview_enum_get,
             set=preview_enum_set,
             )
     import bpy.utils.previews
     pcoll = bpy.utils.previews.new()
-    pcoll.bls_tex_previews = ()
+    pcoll.lls_tex_previews = ()
     pcoll.initiated = False
     pcoll.dir_update_time = os.path.getmtime(directory)
 
@@ -99,7 +99,7 @@ def register():
 def unregister():
     from bpy.types import WindowManager
 
-    del WindowManager.bls_tex_previews
+    del WindowManager.lls_tex_previews
 
     for pcoll in preview_collections.values():
         bpy.utils.previews.remove(pcoll)
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 7f25ed8..e87064d 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -20,9 +20,9 @@ class ListItem(bpy.types.PropertyGroup):
             description="",
             default="")
             
-class BLS_UL_List(bpy.types.UIList):
+class LLS_UL_List(bpy.types.UIList):
     def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
-        custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.BLStudio.list_index else 'LIGHT'
+        custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.LLStudio.list_index else 'LIGHT'
 
         # Make sure your code supports all 3 layout types
         if self.layout_type in {'DEFAULT', 'COMPACT'}:
@@ -34,23 +34,22 @@ class BLS_UL_List(bpy.types.UIList):
             
             
 class LIST_OT_NewItem(bpy.types.Operator):
-    """ Add a new profile to the list """
 
-    bl_idname = "bls_list.new_profile"
-    bl_label = "Add a new Profile"
+    bl_idname = "lls_list.new_profile"
+    bl_label = "Add a new profile"
     bl_options = {"INTERNAL"}
     
     handle: BoolProperty(default=True)
 
     def execute(self, context):
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         item = props.profile_list.add()
-        bls_collection = get_bls_collection(context)
+        lls_collection = get_lls_collection(context)
 
         # unlink existing profiles
-        for profile in (prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)):
+        for profile in (prof for prof in context.scene.objects if prof.name.startswith('LLS_PROFILE.') and isFamily(prof)):
             profile_collection = profile.users_collection[0]
-            bls_collection.children.unlink(profile_collection)
+            lls_collection.children.unlink(profile_collection)
         #
 
         idx = 0
@@ -70,9 +69,9 @@ class LIST_OT_NewItem(bpy.types.Operator):
         
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
-        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Object'+_,
-            directory=os.path.join(dir,"BLS3.blend"+_+"Object"+_),
-            filename="BLS_PROFILE.000",
+        bpy.ops.wm.append(filepath=_+'LLS3.blend'+_+'Object'+_,
+            directory=os.path.join(dir,"LLS3.blend"+_+"Object"+_),
+            filename="LLS_PROFILE.000",
             active_collection=True)
         
         # after operation
@@ -81,12 +80,12 @@ class LIST_OT_NewItem(bpy.types.Operator):
         # whats the difference
         profile = (A ^ B).pop()
         
-        profile.parent = [ob for ob in context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
+        profile.parent = [ob for ob in context.scene.objects if ob.name.startswith('LEOMOON_LIGHT_STUDIO')][0]
         profile.use_fake_user = True
         profile_collection = bpy.data.collections.new(profile.name)
         profile_collection.use_fake_user = True
-        bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
-        bls_collection.children.link(profile_collection)
+        lls_collection = [c for c in context.scene.collection.children if c.name.startswith('LLS')][0]
+        lls_collection.children.link(profile_collection)
         replace_link(profile, profile.name)
         
         item.empty_name = profile.name
@@ -95,7 +94,7 @@ class LIST_OT_NewItem(bpy.types.Operator):
         if self.handle:
             bpy.ops.object.empty_add()
             handle = context.active_object
-            handle.name = "BLS_HANDLE"
+            handle.name = "LLS_HANDLE"
             handle.empty_display_type = 'SPHERE'
             handle.parent = profile
             handle.protected = True
@@ -108,19 +107,18 @@ class LIST_OT_NewItem(bpy.types.Operator):
         return{'FINISHED'}
 
 class LIST_OT_DeleteItem(bpy.types.Operator):
-    """ Delete the selected profile from the list """
  
-    bl_idname = "bls_list.delete_profile"
-    bl_label = "Deletes an profile"
+    bl_idname = "lls_list.delete_profile"
+    bl_label = "Delete the selected profile"
     bl_options = {"INTERNAL"}
  
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
+        return len(context.scene.LLStudio.profile_list)
  
     def execute(self, context):
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         index = props.list_index
  
         props.profile_list.remove(index)
@@ -134,7 +132,7 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
             ob.use_fake_user = False
         bpy.ops.object.delete({"selected_objects": obsToRemove}, use_global=True)
         for c in collectionsToRemove:
-            if c.name.startswith('BLS_'):
+            if c.name.startswith('LLS_'):
                 bpy.data.collections.remove(c)
         
         # update index
@@ -146,19 +144,18 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
     
 
 class LIST_OT_CopyItem(bpy.types.Operator):
-    """ Copy an item in the list """
 
-    bl_idname = "bls_list.copy_profile"
+    bl_idname = "lls_list.copy_profile"
     bl_label = "Copy profile"
     bl_options = {"INTERNAL"}
 
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list. """
-        return len(context.scene.BLStudio.profile_list)
+        return len(context.scene.LLStudio.profile_list)
 
     def execute(self, context):
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         list = props.profile_list
         index = props.list_index
         
@@ -174,7 +171,7 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         
         for ob in context.selected_objects: ob.select = False
         for ob in obsToCopy:
-            if ob.name.startswith('BLS_PROFILE.'): continue
+            if ob.name.startswith('LLS_PROFILE.'): continue
             ob.hide_select = False
             ob.hide = False
             ob.select = True
@@ -193,34 +190,34 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         
         # make light material single user and update selection drivers]
         bpy.ops.group.objects_remove_all()
-        bpy.ops.group.create(name='BLS_Light')
+        bpy.ops.group.create(name='LLS_Light')
         
         for lg in new_objects:
-            if lg.name.startswith('BLS_LIGHT_GRP.'):
-                controller = [c for c in family(lg) if c.name.startswith("BLS_CONTROLLER.")][0]
-                lmesh = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH.")][0]
+            if lg.name.startswith('LLS_LIGHT_GRP.'):
+                controller = [c for c in family(lg) if c.name.startswith("LLS_CONTROLLER.")][0]
+                lmesh = [l for l in family(lg) if l.name.startswith("LLS_LIGHT_MESH.")][0]
                 
                 light_mat = None
                 for id, mat in enumerate(controller.data.materials):
-                    if mat.name.startswith('BLS_icon_ctrl'):
+                    if mat.name.startswith('LLS_icon_ctrl'):
                         mat = mat.copy()
                         controller.data.materials[id] = mat
                         
                         for d in mat.animation_data.drivers:
-                            d.driver.variables[0].targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
+                            d.driver.variables[0].targets[0].id = scene.objects['LLS_LIGHT_MESH.'+controller.name.split('.')[1]]
                         
                         for d in mat.node_tree.animation_data.drivers:
                             for v in d.driver.variables:
-                                v.targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
+                                v.targets[0].id = scene.objects['LLS_LIGHT_MESH.'+controller.name.split('.')[1]]
                                 
-                    elif mat.name.startswith('BLS_light'):
+                    elif mat.name.startswith('LLS_light'):
                         #mat = mat.copy()
                         light_mat = mat.copy()
                         controller.data.materials[id] = light_mat
                         light_mat.node_tree.nodes['Light Texture'].image = light_mat.node_tree.nodes['Light Texture'].image.copy()
                         
                 for id, mat in enumerate(lmesh.data.materials):
-                    if mat.name.startswith('BLS_light'):
+                    if mat.name.startswith('LLS_light'):
                         lmesh.data.materials[id] = light_mat               
                             
         # revert visibility
@@ -228,23 +225,23 @@ class LIST_OT_CopyItem(bpy.types.Operator):
             ob.hide = True
             ob.hide_select = True
             
-            if ob.name.startswith('BLS_LIGHT_MESH.') or \
-               ob.name.startswith('BLS_HANDLE') or \
-               ob.name.startswith('BLS_CONTROLLER.'):
+            if ob.name.startswith('LLS_LIGHT_MESH.') or \
+               ob.name.startswith('LLS_HANDLE') or \
+               ob.name.startswith('LLS_CONTROLLER.'):
                 ob.hide = False
                 ob.hide_select = False
                 
         profileName = props.profile_list[props.list_index].name
         
-        bpy.ops.bls_list.new_profile(handle=False)
+        bpy.ops.lls_list.new_profile(handle=False)
         lastItemId = len(props.profile_list)-1
         
         # parent objects to new profile
         for ob in new_objects:
             scene.objects.unlink(ob)
-            if ob.name.startswith('BLS_LIGHT_GRP.'):
+            if ob.name.startswith('LLS_LIGHT_GRP.'):
                 ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
-            elif ob.name.startswith('BLS_HANDLE.'):
+            elif ob.name.startswith('LLS_HANDLE.'):
                 ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
                 
             
@@ -264,10 +261,9 @@ class LIST_OT_CopyItem(bpy.types.Operator):
     
  
 class LIST_OT_MoveItem(bpy.types.Operator):
-    """ Move an item in the list """
 
-    bl_idname = "bls_list.move_profile"
-    bl_label = "Move profile in the list"
+    bl_idname = "lls_list.move_profile"
+    bl_label = "Move profile"
     bl_options = {"INTERNAL"}
 
     direction: bpy.props.EnumProperty(
@@ -278,12 +274,12 @@ class LIST_OT_MoveItem(bpy.types.Operator):
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list. """
-        return len(context.scene.BLStudio.profile_list)
+        return len(context.scene.LLStudio.profile_list)
 
 
     def move_index(self, context):
         """ Move index of an item render queue while clamping it. """
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         index = props.list_index
         list_length = len(props.profile_list) - 1 # (index starts at 0)
         new_index = 0
@@ -298,7 +294,7 @@ class LIST_OT_MoveItem(bpy.types.Operator):
 
 
     def execute(self, context):
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         list = props.profile_list
         index = props.list_index
 
@@ -316,8 +312,8 @@ class LIST_OT_MoveItem(bpy.types.Operator):
 
 
 def update_list_index(self, context):
-    props = context.scene.BLStudio
-    bls_collection = get_bls_collection(context)
+    props = context.scene.LLStudio
+    lls_collection = get_lls_collection(context)
     
     if len(props.profile_list) == 0: return
         
@@ -331,10 +327,10 @@ def update_list_index(self, context):
     prof_idx = context.scene.objects.find(props.last_empty)
     if prof_idx > -1: # in case of update after deletion
         profile_collection = context.scene.objects[prof_idx].users_collection[0]
-        bls_collection.children.unlink(profile_collection)
+        lls_collection.children.unlink(profile_collection)
         
     #link selected profile
-    bls_collection.children.link(bpy.data.collections[selected_profile.empty_name])
+    lls_collection.children.link(bpy.data.collections[selected_profile.empty_name])
     
     props.last_empty = selected_profile.empty_name
 
@@ -351,7 +347,7 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
     plist = props.profile_list
     for profile in profiles:
         print(profile)
-        bpy.ops.bls_list.new_profile()
+        bpy.ops.lls_list.new_profile()
         props.list_index = len(plist)-1
         plist[-1].name = profile["name"]
         if not internal_copy:
@@ -370,7 +366,7 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             # before
             A = set(profile_empty.children)
             
-            bpy.ops.scene.add_blender_studio_light()
+            bpy.ops.scene.add_leomoon_studio_light()
             
             # after operation
             B = set(profile_empty.children)
@@ -378,8 +374,8 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             # whats the difference
             lgrp = (A ^ B).pop()
 
-            actuator = [c for c in family(lgrp) if "BLS_ROTATION" in c.name][0]
-            lmesh = [c for c in family(lgrp) if "BLS_LIGHT_MESH" in c.name][0]
+            actuator = [c for c in family(lgrp) if "LLS_ROTATION" in c.name][0]
+            lmesh = [c for c in family(lgrp) if "LLS_LIGHT_MESH" in c.name][0]
             lmesh.location.x = light['radius']
             
             actuator.rotation_euler.x = light['position'][0]
@@ -425,20 +421,20 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
                 lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
                 
 class ImportProfiles(bpy.types.Operator):
-    """ Import Profiles from File """
  
-    bl_idname = "bls_list.import_profiles"
-    bl_label = "Import Profiles"
+    bl_idname = "lls_list.import_profiles"
+    bl_label = "Import profiles"
+    bl_description = "Import profiles from file"
     #bl_options = {"INTERNAL"}
     
-    filepath: bpy.props.StringProperty(default="*.bls", subtype="FILE_PATH")
+    filepath: bpy.props.StringProperty(default="*.lls", subtype="FILE_PATH")
  
     @classmethod
     def poll(self, context):
         return True
  
     def execute(self, context):
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         
         with open(self.filepath, 'r') as f:
             file = f.read()
@@ -454,7 +450,7 @@ class ImportProfiles(bpy.types.Operator):
         return {'RUNNING_MODAL'}
 
 def compose_profile(list_index):
-    props = bpy.context.scene.BLStudio
+    props = bpy.context.scene.LLStudio
     profile_dict = {}
     profile_dict['name'] = props.profile_list[list_index].name
     profile_dict['lights']= []
@@ -463,8 +459,8 @@ def compose_profile(list_index):
     handle = getLightHandle(profile)
     profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
     for light_collection in profile_collection.children:
-        lmesh = [ob for ob in light_collection.objects if ob.name.startswith('BLS_LIGHT_MESH')][0]
-        actuator = [ob for ob in light_collection.objects if ob.name.startswith('BLS_ROTATION')][0]
+        lmesh = [ob for ob in light_collection.objects if ob.name.startswith('LLS_LIGHT_MESH')][0]
+        actuator = [ob for ob in light_collection.objects if ob.name.startswith('LLS_ROTATION')][0]
         light = {}
         light['radius'] = lmesh.location.x
         light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
@@ -508,22 +504,22 @@ def compose_profile(list_index):
     return profile_dict
         
 class ExportProfiles(bpy.types.Operator):
-    """ Export Profiles to File """
  
-    bl_idname = "bls_list.export_profiles"
-    bl_label = "Export"
+    bl_idname = "lls_list.export_profiles"
+    bl_label = "Export profiles to file"
+    bl_description = "Export profile(s) to file"
     #bl_options = {"INTERNAL"}
     
-    filepath: bpy.props.StringProperty(default="profile.bls", subtype="FILE_PATH")
+    filepath: bpy.props.StringProperty(default="profile.lls", subtype="FILE_PATH")
     all: bpy.props.BoolProperty(default=False, name="Export All Profiles")
  
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
+        return len(context.scene.LLStudio.profile_list)
  
     def execute(self, context):
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         index = props.list_index
             
         export_file = {}
@@ -551,21 +547,21 @@ class ExportProfiles(bpy.types.Operator):
         return{'FINISHED'}
     
     def invoke(self, context, event):
-        self.filepath = "profile.bls"
+        self.filepath = "profile.lls"
         context.window_manager.fileselect_add(self)
         return {'RUNNING_MODAL'}
     
 class FindMissingTextures(bpy.types.Operator):
-    """ Find Missing Textures """
  
-    bl_idname = "bls.find_missing_textures"
+    bl_idname = "lls.find_missing_textures"
     bl_label = "Find Missing Textures"
+    bl_description = "Find missing light textures"
     #bl_options = {"INTERNAL"}
     
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
+        return len(context.scene.LLStudio.profile_list)
  
     def execute(self, context):
         bpy.ops.file.find_missing_files(directory=os.path.join(dir, "textures_real_lights"))        
@@ -575,7 +571,7 @@ class FindMissingTextures(bpy.types.Operator):
 class CopyProfileToScene(bpy.types.Operator):
     """ Copy Light Profile to Scene """
  
-    bl_idname = "bls_list.copy_profile_to_scene"
+    bl_idname = "lls_list.copy_profile_to_scene"
     bl_label = "Copy Profile to Scene"
     bl_property = "sceneprop"
     
@@ -587,20 +583,20 @@ class CopyProfileToScene(bpy.types.Operator):
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
+        return len(context.scene.LLStudio.profile_list)
  
     def execute(self, context):
-        props = context.scene.BLStudio
+        props = context.scene.LLStudio
         index = props.list_index
         
         profiles = [compose_profile(index),]
         
         context.screen.scene = bpy.data.scenes[self.sceneprop]
         context.scene.render.engine = 'CYCLES'
-        if not context.scene.BLStudio.initialized:
-            bpy.ops.scene.create_blender_light_studio()
+        if not context.scene.LLStudio.initialized:
+            bpy.ops.scene.create_leomoon_light_studio()
         
-        parse_profile(context, context.scene.BLStudio, profiles, internal_copy=True)
+        parse_profile(context, context.scene.LLStudio, profiles, internal_copy=True)
         
         return{'FINISHED'}
         
@@ -611,15 +607,14 @@ class CopyProfileToScene(bpy.types.Operator):
     
 
 class CopyProfileMenu(bpy.types.Operator):
-    """ Copy Light Profile """
  
-    bl_idname = "bls_list.copy_profile_menu"
-    bl_label = "Copy Profile"
+    bl_idname = "lls_list.copy_profile_menu"
+    bl_label = "Copy selected profile"
 
     @classmethod
     def poll(self, context):
         """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
+        return len(context.scene.LLStudio.profile_list)
     
     def execute(self, context):
         wm = context.window_manager
@@ -627,8 +622,8 @@ class CopyProfileMenu(bpy.types.Operator):
             layout = self.layout
             layout.operator_context='INVOKE_AREA'
             col = layout.column(align=True)
-            col.operator('bls_list.copy_profile')
-            col.operator('bls_list.copy_profile_to_scene')
+            col.operator('lls_list.copy_profile')
+            col.operator('lls_list.copy_profile_to_scene')
 
         wm.popup_menu(draw, title="Copy Profile")
         return {'FINISHED'}
\ No newline at end of file
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 1022d6b..629d31c 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -9,6 +9,8 @@ from .modal_utils import shader2Dcolor
 from gpu_extras.batch import batch_for_shader
 import time
 
+#textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale | [Ctrl+Click] Loop overlapping"
+
 last_time = time.time()
 def draw(self, area):
     if area != bpy.context.area:
@@ -16,7 +18,6 @@ def draw(self, area):
 
     shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
     batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
-    #
 
     self.panel.draw()
     for b in Button.buttons:
@@ -24,7 +25,7 @@ def draw(self, area):
     for l in LightImage.lights:
         l.draw()
 
-class BLS_OT_Rotate(bpy.types.Operator, MouseWidget):
+class LLS_OT_Rotate(bpy.types.Operator, MouseWidget):
     bl_idname = "light_studio.rotate"
     bl_label = "Rotate Light"
     bl_options = {"REGISTER", "UNDO", "INTERNAL"}
@@ -37,24 +38,26 @@ class BLS_OT_Rotate(bpy.types.Operator, MouseWidget):
 
     def invoke(self, context, event):
         super().invoke(context, event)
-        self.base_object_rotation = LightImage.selected_object._bls_mesh.rotation_euler.x
+        self.base_object_rotation = LightImage.selected_object._lls_mesh.rotation_euler.x
         return {"RUNNING_MODAL"}
     
     def _finish(self, context, event):
-        context.area.header_text_set(text=None)
+        bpy.context.workspace.status_text_set(None)
+        #context.area.header_text_set(text=None)
 
     def _cancel(self, context, event):
-        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation
-        context.area.header_text_set(text=None)
+        LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation
+        bpy.context.workspace.status_text_set(None)
+        #context.area.header_text_set(text=None)
 
     def _modal(self, context, event):
-        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
-
-        context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
+        LightImage.selected_object._lls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
+        bpy.context.workspace.status_text_set(f"Rot: {self.angle():.3f}")
+        #context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
 
         return {"PASS_THROUGH"}
 
-class BLS_OT_Scale(bpy.types.Operator, MouseWidget):
+class LLS_OT_Scale(bpy.types.Operator, MouseWidget):
     bl_idname = "light_studio.scale"
     bl_label = "Scale Light"
     bl_options = {"GRAB_CURSOR", "BLOCKING", "REGISTER", "UNDO", "INTERNAL"}
@@ -68,15 +71,17 @@ class BLS_OT_Scale(bpy.types.Operator, MouseWidget):
 
     def invoke(self, context, event):
         super().invoke(context, event)
-        self.base_object_scale = LightImage.selected_object._bls_mesh.scale.copy()
+        self.base_object_scale = LightImage.selected_object._lls_mesh.scale.copy()
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
-        LightImage.selected_object._bls_mesh.scale = self.base_object_scale
-        context.area.header_text_set(text=None)
+        LightImage.selected_object._lls_mesh.scale = self.base_object_scale
+        bpy.context.workspace.status_text_set(None)
+        #context.area.header_text_set(text=None)
 
     def _finish(self, context, event):
-        context.area.header_text_set(text=None)
+        bpy.context.workspace.status_text_set(None)
+        #context.area.header_text_set(text=None)
 
     def _modal(self, context, event):
         new_scale = self.base_object_scale * self.delta_length_factor()
@@ -85,16 +90,16 @@ class BLS_OT_Scale(bpy.types.Operator, MouseWidget):
         if self.y_key:
             new_scale.y = self.base_object_scale.y
 
-        LightImage.selected_object._bls_mesh.scale = new_scale
-
-        context.area.header_text_set(text=f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
+        LightImage.selected_object._lls_mesh.scale = new_scale
+        bpy.context.workspace.status_text_set(f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
+        #context.area.header_text_set(text=f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
 
         if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
             return {"RUNNING_MODAL"}
         return {"PASS_THROUGH"}
 
 GRABBING = False
-class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
+class LLS_OT_Grab(bpy.types.Operator, MouseWidget):
     bl_idname = "light_studio.grab"
     bl_label = "Grab Light"
     bl_options = {"GRAB_CURSOR", "BLOCKING", "INTERNAL"}
@@ -113,19 +118,21 @@ class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
 
     def invoke(self, context, event):
         super().invoke(context, event)
-        self.base_object_rotation = LightImage.selected_object._bls_actuator.rotation_euler.copy()
+        self.base_object_rotation = LightImage.selected_object._lls_actuator.rotation_euler.copy()
         return {"RUNNING_MODAL"}
     
     def _cancel(self, context, event):
-        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation
+        LightImage.selected_object._lls_actuator.rotation_euler = self.base_object_rotation
         global GRABBING
         GRABBING = False
-        context.area.header_text_set(text=None)
+        bpy.context.workspace.status_text_set(None)
+        #context.area.header_text_set(text=None)
 
     def _finish(self, context, event):
         global GRABBING
         GRABBING = False
-        context.area.header_text_set(text=None)
+        bpy.context.workspace.status_text_set(None)
+        #context.area.header_text_set(text=None)
 
     def _modal(self, context, event):
         dv = self.delta_vector()
@@ -137,12 +144,12 @@ class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
         x_factor = 2*pi / self.canvas_width
         y_factor = pi / self.canvas_height
 
-        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation.copy()
-        LightImage.selected_object._bls_actuator.rotation_euler.x += dv.x * x_factor
-        LightImage.selected_object._bls_actuator.rotation_euler.y += dv.y * y_factor
-        LightImage.selected_object._bls_actuator.rotation_euler.y = clamp(-pi/2 + 0.000001, LightImage.selected_object._bls_actuator.rotation_euler.y, pi/2 - 0.000001)
-
-        context.area.header_text_set(text=f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
+        LightImage.selected_object._lls_actuator.rotation_euler = self.base_object_rotation.copy()
+        LightImage.selected_object._lls_actuator.rotation_euler.x += dv.x * x_factor
+        LightImage.selected_object._lls_actuator.rotation_euler.y += dv.y * y_factor
+        LightImage.selected_object._lls_actuator.rotation_euler.y = clamp(-pi/2 + 0.000001, LightImage.selected_object._lls_actuator.rotation_euler.y, pi/2 - 0.000001)
+        bpy.context.workspace.status_text_set(f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
+        #context.area.header_text_set(text=f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
 
         if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
             return {"RUNNING_MODAL"}
@@ -150,19 +157,19 @@ class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
 
 panel_global = None
 running_modals = 0
-class BLS_OT_control_panel(bpy.types.Operator):
+class LLS_OT_control_panel(bpy.types.Operator):
     bl_idname = "light_studio.control_panel"
-    bl_label = "Light Studio Control Panel"
+    bl_label = "LightStudio Control Panel"
+    bl_description = "Show/Hide LightStudio Control Panel"
 
     mouse_x: bpy.props.IntProperty()
     mouse_y: bpy.props.IntProperty()
 
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.LLStudio.initialized
 
     def __init__(self):
-        self.textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale | [Ctrl+Click] Loop overlapping"
         self.handler = None
         self.panel = None
         self.panel_moving = False
@@ -202,24 +209,23 @@ class BLS_OT_control_panel(bpy.types.Operator):
 
         self.handler = bpy.types.SpaceView3D.draw_handler_add(draw, (self, context.area), 'WINDOW', 'POST_PIXEL')
         context.window_manager.modal_handler_add(self)
-
         aw = context.area.width
         ah = context.area.height
-        pw = min(aw-60, 600)
+        pw = min(aw-60, 800)
         
         global panel_global
         if not panel_global:
             panel_global = Panel(Vector((30, 25)), pw, pw*(9/16))
         self.panel = panel_global
 
-        LightImage.default_size = 100
+        LightImage.default_size = 50
 
         self.mouse_x = event.mouse_x - context.area.x
         self.mouse_y = event.mouse_y - context.area.y
 
         update_light_sets(self.panel, context, always=True)
-
-        context.area.header_text_set(text=self.textinfo)
+        #bpy.context.workspace.status_text_set(textinfo)
+        #context.area.header_text_set(text=textinfo)
 
         self.ctrl = False
 
@@ -360,7 +366,8 @@ class BLS_OT_control_panel(bpy.types.Operator):
                     if hasattr(self.clicked_object, 'click'):
                         result = self.clicked_object.click()
                         if result == "FINISHED":
-                            context.area.header_text_set(text=None)
+                            bpy.context.workspace.status_text_set(None) #clear help if window is closed
+                            #context.area.header_text_set(text=None)
                             self._unregister_handler()
                             return {"FINISHED"}
                         return {"RUNNING_MODAL"}
@@ -381,12 +388,14 @@ class BLS_OT_control_panel(bpy.types.Operator):
                 
                 # Return (Enter) key is pressed
                 elif event.type == "RET":
-                    context.area.header_text_set(text=None)
+                    bpy.context.workspace.status_text_set(None)
+                    #context.area.header_text_set(text=None)
                     self._unregister_handler()
                     return {'FINISHED'}
             
             if event.value == "RELEASE":
-                context.area.header_text_set(text=self.textinfo)
+                #bpy.context.workspace.status_text_set(textinfo)
+                #context.area.header_text_set(text=textinfo)
                 if event.type == "LEFTMOUSE":
                     self.panel_moving = False
                 elif event.type == "LEFT_SHIFT":
@@ -428,22 +437,24 @@ class BLS_OT_control_panel(bpy.types.Operator):
         return None
 
 def update_light_sets(panel, context, always=False):
-    bls_collection, profile_collection = blscol_profilecol(context)
-    if is_updated() or always or len(profile_collection.children) != len(LightImage.lights):
-        bls_lights = set(profile_collection.children)
-        working_set = set((l._collection for l in LightImage.lights))
-
-        to_delete = working_set.difference(bls_lights)
-        to_add =  bls_lights.difference(working_set)
-        
-        for col in to_delete:
-            LightImage.remove(col)
+    lls_collection, profile_collection = llscol_profilecol(context)
+    if profile_collection is not None:
+        if is_updated() or always or len(profile_collection.children) != len(LightImage.lights):
+            lls_lights = set(profile_collection.children)
+            working_set = set((l._collection for l in LightImage.lights))
+
+            to_delete = working_set.difference(lls_lights)
+            to_add =  lls_lights.difference(working_set)
+            
+            for col in to_delete:
+                LightImage.remove(col)
 
-        for col in to_add:
-            LightImage(context, panel, col)
+            for col in to_add:
+                LightImage(context, panel, col)
 
-        update_clear()
+            update_clear()
 
 def close_control_panel():
     global running_modals
-    running_modals = 0
\ No newline at end of file
+    running_modals = 0
+    
\ No newline at end of file
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 84d4656..143b88c 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -258,7 +258,7 @@ def send_light_to_top(light):
 class Panel(Rectangle):
     def __init__(self, loc, width, height):
         super().__init__(loc, width, height)
-        self.button_exit = Button(Vector((0,0)), 'X', 30)
+        self.button_exit = Button(Vector((0,0)), 'x', 30)
         self.button_exit.function = lambda x: "FINISHED"
 
         self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
@@ -327,7 +327,7 @@ class Button(Rectangle):
 view_layers = []
 
 class Border(Rectangle):
-    weight = 5
+    weight = 3
 
     def __init__(self, light_image, color):
         self.color = color
@@ -454,14 +454,14 @@ class LightImage(Rectangle):
     selected_object = None
     lights = []
     @classmethod
-    def find_idx(cls, bls_light_collection):
+    def find_idx(cls, lls_light_collection):
         for idx, l in enumerate(cls.lights):
-            if l._collection == bls_light_collection:
+            if l._collection == lls_light_collection:
                 return idx
         return -1
     @classmethod
-    def remove(cls, bls_light_collection):
-        del cls.lights[cls.find_idx(bls_light_collection)]
+    def remove(cls, lls_light_collection):
+        del cls.lights[cls.find_idx(lls_light_collection)]
 
     def delete(self):
         del LightImage.lights[LightImage.lights.index(self)]
@@ -471,7 +471,7 @@ class LightImage(Rectangle):
         cls.selected_object = None
         for l in cls.lights:
             try:
-                if l.update_from_bls():
+                if l.update_from_lls():
                     l.update_visual_location()
             except ReferenceError:
                 l.delete()
@@ -490,33 +490,33 @@ class LightImage(Rectangle):
         return panel_px_loc + self.panel.point_lt - Vector((LightImage.default_size*self._scale.y/2, LightImage.default_size*self._scale.z/2))
     
     def _update_panel_loc(self):
-        self.panel_loc.x = (self._bls_rot.x + pi) % (2*pi) / (2*pi)
-        self.panel_loc.y = fmod(self._bls_rot.y + pi/2, pi) / (pi)
+        self.panel_loc.x = (self._lls_rot.x + pi) % (2*pi) / (2*pi)
+        self.panel_loc.y = fmod(self._lls_rot.y + pi/2, pi) / (pi)
 
-    def update_from_bls(self):
-        if self._bls_mesh.select_get():
+    def update_from_lls(self):
+        if self._lls_mesh.select_get():
             LightImage.selected_object = self
 
         updated = False
-        if self._bls_rot != self._bls_actuator.rotation_euler:
+        if self._lls_rot != self._lls_actuator.rotation_euler:
             updated |= True
-            self._bls_rot = self._bls_actuator.rotation_euler.copy()
-        if self.rot != self._bls_mesh.rotation_euler.x:
+            self._lls_rot = self._lls_actuator.rotation_euler.copy()
+        if self.rot != self._lls_mesh.rotation_euler.x:
             updated |= True
-            self.rot = self._bls_mesh.rotation_euler.x
-        if self._scale != self._bls_mesh.scale:
+            self.rot = self._lls_mesh.rotation_euler.x
+        if self._scale != self._lls_mesh.scale:
             updated |= True
-            self._scale = self._bls_mesh.scale.copy()
+            self._scale = self._lls_mesh.scale.copy()
             self.width = LightImage.default_size * self._scale.y
             self.height = LightImage.default_size * self._scale.z
         
         if updated:
             self._update_panel_loc()
 
-        if self._image_path != self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath:
+        if self._image_path != self._lls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath:
             updated |= True
-            self.image = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image
-            self._image_path = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath
+            self.image = self._lls_mesh.active_material.node_tree.nodes["Light Texture"].image
+            self._image_path = self._lls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath
         # this should run when image changes but sometimes Blender looses images... so it's run every time to be safe
         if self.image.gl_load():
             raise Exception
@@ -524,32 +524,33 @@ class LightImage(Rectangle):
 
         return updated
 
-    def update_bls(self):
-        self._bls_actuator.rotation_euler = self._bls_rot
-        self._bls_mesh.rotation_euler.x = self.rot
+    def update_lls(self):
+        self._lls_actuator.rotation_euler = self._lls_rot
+        self._lls_mesh.rotation_euler.x = self.rot
 
-    def __init__(self, context, panel, bls_light_collection):
+    def __init__(self, context, panel, lls_light_collection):
         self.panel = panel
         self.__panel_loc = Vector((.5, .5))
 
-        self._collection = bls_light_collection
-        self._bls_mesh = [m for m in bls_light_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
-        self._bls_actuator = self._bls_mesh.parent
+        self._collection = lls_light_collection
+        self._lls_mesh = [m for m in lls_light_collection.objects if m.name.startswith("LLS_LIGHT_MESH")][0]
+        self._lls_actuator = self._lls_mesh.parent
         self._view_layer = find_view_layer(self._collection, context.view_layer.layer_collection)
         
         self._image_path = ""
-        self._bls_rot = None
+        self._lls_rot = None
         self._scale = None
 
         super().__init__(Vector((0,0)), LightImage.default_size, LightImage.default_size)
-        self.update_from_bls()
+        self.update_from_lls()
         self.update_visual_location()
         
         LightImage.lights.append(self)
 
+        self.default_border = Border(self, (.2, .35, .2, 1))
         self.mute_border = Border(self, (.7, 0, 0, 1))
         self.select_border = Border(self, (.2, .9, .2, 1))
-        self.select_border.weight = 2
+        #self.select_border.weight = 2
     
     @property
     def mute(self):
@@ -566,10 +567,10 @@ class LightImage(Rectangle):
     @panel_loc.setter
     def panel_loc(self, pos):
         self.__panel_loc = pos
-        self._bls_rot = Vector((
+        self._lls_rot = Vector((
             (self.panel_loc.x -.5) * (2*pi),
             (self.panel_loc.y -.5) * (pi),
-            self._bls_rot.z
+            self._lls_rot.z
         ))
         self.update_visual_location() # update self.loc
 
@@ -577,8 +578,8 @@ class LightImage(Rectangle):
         if self.mute:
             return
         bpy.ops.object.select_all(action='DESELECT')
-        bpy.context.view_layer.objects.active = self._bls_mesh
-        self._bls_mesh.select_set(True)
+        bpy.context.view_layer.objects.active = self._lls_mesh
+        self._lls_mesh.select_set(True)
 
     def is_mouse_over(self, mouse_x, mouse_y):
         def rotate(x1, y1, offset):
@@ -615,7 +616,7 @@ class LightImage(Rectangle):
 
     def draw(self):
         try:
-            select = self._bls_mesh.select_get()
+            select = self._lls_mesh.select_get()
         except ReferenceError:
             return
         
@@ -634,8 +635,10 @@ class LightImage(Rectangle):
 
         if self.mute:
             self.mute_border.draw()
-        if select:
+        elif select:
             self.select_border.draw()
+        else:
+            self.default_border.draw()
 
         lightIconShader.bind()
         bgl.glActiveTexture(bgl.GL_TEXTURE0)
@@ -647,32 +650,32 @@ class LightImage(Rectangle):
 
         try:
             # material properties
-            bls_node = self._bls_mesh.active_material.node_tree.nodes['Group']
-            intensity = bls_node.inputs['Intensity'].default_value
+            lls_node = self._lls_mesh.active_material.node_tree.nodes['Group']
+            intensity = lls_node.inputs['Intensity'].default_value
 
-            texture_switch = bls_node.inputs['Texture Switch'].default_value
-            color_overlay = bls_node.inputs['Color Overlay'].default_value
-            color_saturation = bls_node.inputs['Color Saturation'].default_value
+            texture_switch = lls_node.inputs['Texture Switch'].default_value
+            color_overlay = lls_node.inputs['Color Overlay'].default_value
+            color_saturation = lls_node.inputs['Color Saturation'].default_value
 
             lightIconShader.uniform_float("intensity", intensity)
             lightIconShader.uniform_float("texture_switch", texture_switch)
             lightIconShader.uniform_float("color_overlay", color_overlay)
             lightIconShader.uniform_float("color_saturation", color_saturation)
 
-            mask_bottom_to_top = bls_node.inputs['Mask - Bottom to Top'].default_value
-            mask_diagonal_bottom_left = bls_node.inputs['Mask - Diagonal Bottom Left'].default_value
-            mask_diagonal_bottom_right = bls_node.inputs['Mask - Diagonal Bottom Right'].default_value
-            mask_diagonal_top_left = bls_node.inputs['Mask - Diagonal Top Left'].default_value
-            mask_diagonal_top_right = bls_node.inputs['Mask - Diagonal Top Right'].default_value
-            mask_gradient_amount = bls_node.inputs['Mask - Gradient Amount'].default_value
-            mask_gradient_switch = bls_node.inputs['Mask - Gradient Switch'].default_value
-            mask_gradient_type = bls_node.inputs['Mask - Gradient Type'].default_value
-            mask_left_to_right = bls_node.inputs['Mask - Left to Right'].default_value
-            mask_right_to_left = bls_node.inputs['Mask - Right to Left'].default_value
-            mask_ring_inner_radius = bls_node.inputs['Mask - Ring Inner Radius'].default_value
-            mask_ring_outer_radius = bls_node.inputs['Mask - Ring Outer Radius'].default_value
-            mask_ring_switch = bls_node.inputs['Mask - Ring Switch'].default_value
-            mask_top_to_bottom = bls_node.inputs['Mask - Top to Bottom'].default_value
+            mask_bottom_to_top = lls_node.inputs['Mask - Bottom to Top'].default_value
+            mask_diagonal_bottom_left = lls_node.inputs['Mask - Diagonal Bottom Left'].default_value
+            mask_diagonal_bottom_right = lls_node.inputs['Mask - Diagonal Bottom Right'].default_value
+            mask_diagonal_top_left = lls_node.inputs['Mask - Diagonal Top Left'].default_value
+            mask_diagonal_top_right = lls_node.inputs['Mask - Diagonal Top Right'].default_value
+            mask_gradient_amount = lls_node.inputs['Mask - Gradient Amount'].default_value
+            mask_gradient_switch = lls_node.inputs['Mask - Gradient Switch'].default_value
+            mask_gradient_type = lls_node.inputs['Mask - Gradient Type'].default_value
+            mask_left_to_right = lls_node.inputs['Mask - Left to Right'].default_value
+            mask_right_to_left = lls_node.inputs['Mask - Right to Left'].default_value
+            mask_ring_inner_radius = lls_node.inputs['Mask - Ring Inner Radius'].default_value
+            mask_ring_outer_radius = lls_node.inputs['Mask - Ring Outer Radius'].default_value
+            mask_ring_switch = lls_node.inputs['Mask - Ring Switch'].default_value
+            mask_top_to_bottom = lls_node.inputs['Mask - Top to Bottom'].default_value
 
             lightIconShader.uniform_float("mask_bottom_to_top", mask_bottom_to_top)
             lightIconShader.uniform_float("mask_diagonal_bottom_left", mask_diagonal_bottom_left)
@@ -753,7 +756,7 @@ class LightImage(Rectangle):
             clamp(0.0001, (self.loc.y-self.panel.loc.y) / self.panel.height +.5, 0.9999),
         ))
 
-        self.update_bls()
+        self.update_lls()
 
 def is_in_rect(rect, loc):
     return (loc.x >= rect.point_lt.x and loc.x <= rect.point_rb.x) and (loc.y >= rect.point_rb.y and loc.y <= rect.point_lt.y)

commit 3e835732a77c60124556a6213ad5c473cedd9840
Merge: 653f519 e6332d6
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Mar 23 09:15:14 2020 -0700

    Merge pull request #24 from StyriamMZ/beta
    
    2.5.0

commit e6332d6e71e912f8d3ee96df61543457670ea5f8
Author: StyriamMZ <styriam@o2.pl>
Date:   Sat Mar 21 16:33:03 2020 +0100

    2.5.0

diff --git a/src/light_operators.py b/src/light_operators.py
index 7ace206..746c383 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -63,6 +63,10 @@ class DeleteBlenderLightStudio(bpy.types.Operator):
     def execute(self, context):
         scene = context.scene
         scene.BLStudio.initialized = False
+
+        # close control panel
+        from . operators.modal import close_control_panel
+        close_control_panel()
         
         ''' for each profile from this scene: delete objects then remove from list '''
         while len(context.scene.BLStudio.profile_list):
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 0da4952..1022d6b 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -442,4 +442,8 @@ def update_light_sets(panel, context, always=False):
         for col in to_add:
             LightImage(context, panel, col)
 
-        update_clear()
\ No newline at end of file
+        update_clear()
+
+def close_control_panel():
+    global running_modals
+    running_modals = 0
\ No newline at end of file

commit c20d3de394ede54f18fd90474c76b30e12366ac1
Merge: 9b5b0d6 f8b4cf8
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Mar 20 23:49:54 2020 +0100

    Merge branch 'beta' of https://github.com/StyriamMZ/leomoon-lightstudio-1 into beta

commit 9b5b0d6972edf31d4306c89b25475c11aa48e9c9
Merge: c2977f1 cbf8a59
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Mar 20 16:33:24 2020 +0100

    2.5.0

commit f8b4cf829eb915ac787c5019b37ba234bc9cb01a
Merge: c2977f1 cbf8a59
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Mar 20 16:33:24 2020 +0100

    Merge branch 'beta' of https://github.com/StyriamMZ/leomoon-lightstudio-1 into beta

commit c2977f1288a5ec0faef80b5e6e88208ee9bbfde7
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Mar 20 16:30:34 2020 +0100

    2.5.0

diff --git a/src/gui.py b/src/gui.py
index 45d174e..9d30015 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -67,7 +67,6 @@ class BLS_PT_Selected(bpy.types.Panel):
             col.template_icon_view(wm, "bls_tex_previews", show_labels=True)
             col.label(text=os.path.splitext(wm.bls_tex_previews)[0])
             
-            
             layout.separator()
             try:
                 bls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
@@ -79,8 +78,8 @@ class BLS_PT_Selected(bpy.types.Panel):
                         col.prop(input, 'default_value', text=input.name)
             except:
                 col.label(text="BLS_light material is not valid.")
-                import traceback
-                traceback.print_exc()
+                #import traceback
+                #traceback.print_exc()
             col.prop(getLightMesh(), 'location', index=0) #light radius
 
 @force_register
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 15a9f77..84d4656 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -31,19 +31,39 @@ fragment_shader = '''
 
     in vec2 texCoord_interp;
     in vec4 gl_FragCoord;
-    out vec4 fragColor;
 
-    uniform sampler2D image;
-    uniform float intensity;
-    uniform float texture_switch;
-    uniform vec4 color_overlay;
-    uniform float color_saturation;
+    layout(location = 0) out vec4 fragColor;
+    layout(location = 1) out vec4 trash;
 
-    uniform vec2 panel_point_lt;
-    uniform vec2 panel_point_rb;
+    uniform sampler2D image;
+    uniform float panel_point_left;
+    uniform float panel_point_right;
+
+    uniform vec4 color_overlay = vec4(0);
+    uniform float intensity = 1;
+    uniform float texture_switch = 1;
+    uniform float color_saturation = 0;
+
+    uniform float mask_bottom_to_top = 0;
+    uniform float mask_diagonal_bottom_left = 0;
+    uniform float mask_diagonal_bottom_right = 0;
+    uniform float mask_diagonal_top_left = 0;
+    uniform float mask_diagonal_top_right = 0;
+    uniform float mask_gradient_amount = 0;
+    uniform float mask_gradient_switch = 0;
+    uniform float mask_gradient_type = 0;
+    uniform float mask_left_to_right = 0;
+    uniform float mask_right_to_left = 0;
+    uniform float mask_ring_inner_radius = 0;
+    uniform float mask_ring_outer_radius = 0;
+    uniform float mask_ring_switch = 0;
+    uniform float mask_top_to_bottom = 0;
 
     void main()
     {
+        // Trash output - sum all uniforms to prevent compiler from skipping currently unused ones
+        trash = vec4(panel_point_left+panel_point_right+mask_bottom_to_top+mask_diagonal_bottom_left+mask_diagonal_bottom_right+mask_diagonal_top_left+mask_diagonal_top_right+mask_gradient_amount+mask_gradient_switch+mask_gradient_type+mask_left_to_right+mask_right_to_left+mask_ring_inner_radius+mask_ring_outer_radius+mask_ring_switch+mask_top_to_bottom);
+        
         // Texture Switch + Intensity
         // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
         fragColor = mix(vec4(1.0f), texture(image, texCoord_interp), texture_switch) * log(1+intensity);
@@ -57,8 +77,58 @@ fragment_shader = '''
         fragColor.a = gray;
         fragColor.rgb *= fragColor.a;
 
-        if(gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
-            fragColor.rgba = vec4(0);
+        // MASKS //
+
+        // Vertical gradient + mask_gradient_amount
+        float vg = sqrt(texCoord_interp.y);
+        vg = (texCoord_interp.y <= mask_gradient_amount+.05f) ? mix(0, vg, (texCoord_interp.y-mask_gradient_amount)/.05f) : vg;
+        vg = texCoord_interp.y >= mask_gradient_amount ? vg : 0;
+
+        // Spherical gradient + mask_gradient_amount
+        float d = distance(texCoord_interp.xy, vec2(0.5f, 0.5f));
+        float m = (1.0f-mask_gradient_amount)*.5f;
+        float sg = 1-pow(d*2, 2.f);
+        sg = (d >= m-.05f) ? mix(0, sg, (m-d)/.05f) : sg;
+        sg = (d <= m) ? sg : 0;
+
+        // Gradient Type
+        float grad = mix(sg, vg, mask_gradient_type);
+
+        // Gradient Switch
+        fragColor.a = mix(fragColor.a, grad*fragColor.a, mask_gradient_switch);
+
+        // Gradient Ring Switch
+        float ring = d < (1-mask_ring_outer_radius)*.575f ? 1 : 0;
+        ring = d < (1-mask_ring_inner_radius)*.55f ? 0 : ring;
+        fragColor.a = mix(fragColor.a, fragColor.a*ring, mask_ring_switch);
+        
+        // Top-Bottom
+        fragColor.a = texCoord_interp.y < (1-mask_top_to_bottom) ? fragColor.a : 0;
+        
+        // Bottom-Top
+        fragColor.a = texCoord_interp.y > mask_bottom_to_top ? fragColor.a : 0;
+
+        // Left-Right
+        fragColor.a = texCoord_interp.x > mask_left_to_right ? fragColor.a : 0;
+        
+        // Right-Left
+        fragColor.a = texCoord_interp.x < (1-mask_right_to_left) ? fragColor.a : 0;
+
+        // Diagonal Top-Right
+        fragColor.a = 1-(texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_right ? fragColor.a : 0;
+        
+        // Diagonal Top-Left
+        fragColor.a = 1-(1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_top_left ? fragColor.a : 0;
+        
+        // Diagonal Bottom-Right
+        fragColor.a = (1-texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_right ? fragColor.a : 0;
+
+        // Diagonal Bottom-Left
+        fragColor.a = (texCoord_interp.x+texCoord_interp.y)/2 > mask_diagonal_bottom_left ? fragColor.a : 0;
+
+        // Panel bound clipping
+        if(gl_FragCoord.x < panel_point_left || gl_FragCoord.x > panel_point_right)
+            discard;
     }
 '''
 
@@ -572,22 +642,54 @@ class LightImage(Rectangle):
         bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
         lightIconShader.uniform_int("image", 0)
 
-        # material properties
-        bls_node = self._bls_mesh.active_material.node_tree.nodes['Group']
-        intensity = bls_node.inputs['Intensity'].default_value
-
-        texture_switch = bls_node.inputs['Texture Switch'].default_value
-        color_overlay = bls_node.inputs['Color Overlay'].default_value
-        color_saturation = bls_node.inputs['Color Saturation'].default_value
-
-        lightIconShader.uniform_float("intensity", intensity)
-        lightIconShader.uniform_float("texture_switch", texture_switch)
-        lightIconShader.uniform_float("color_overlay", color_overlay)
-        lightIconShader.uniform_float("color_saturation", color_saturation)
-
-        lightIconShader.uniform_float("panel_point_lt", self.panel.point_lt)
-        lightIconShader.uniform_float("panel_point_rb", self.panel.point_rb)
+        lightIconShader.uniform_float("panel_point_left", self.panel.point_lt.x)
+        lightIconShader.uniform_float("panel_point_right", self.panel.point_rb.x)
 
+        try:
+            # material properties
+            bls_node = self._bls_mesh.active_material.node_tree.nodes['Group']
+            intensity = bls_node.inputs['Intensity'].default_value
+
+            texture_switch = bls_node.inputs['Texture Switch'].default_value
+            color_overlay = bls_node.inputs['Color Overlay'].default_value
+            color_saturation = bls_node.inputs['Color Saturation'].default_value
+
+            lightIconShader.uniform_float("intensity", intensity)
+            lightIconShader.uniform_float("texture_switch", texture_switch)
+            lightIconShader.uniform_float("color_overlay", color_overlay)
+            lightIconShader.uniform_float("color_saturation", color_saturation)
+
+            mask_bottom_to_top = bls_node.inputs['Mask - Bottom to Top'].default_value
+            mask_diagonal_bottom_left = bls_node.inputs['Mask - Diagonal Bottom Left'].default_value
+            mask_diagonal_bottom_right = bls_node.inputs['Mask - Diagonal Bottom Right'].default_value
+            mask_diagonal_top_left = bls_node.inputs['Mask - Diagonal Top Left'].default_value
+            mask_diagonal_top_right = bls_node.inputs['Mask - Diagonal Top Right'].default_value
+            mask_gradient_amount = bls_node.inputs['Mask - Gradient Amount'].default_value
+            mask_gradient_switch = bls_node.inputs['Mask - Gradient Switch'].default_value
+            mask_gradient_type = bls_node.inputs['Mask - Gradient Type'].default_value
+            mask_left_to_right = bls_node.inputs['Mask - Left to Right'].default_value
+            mask_right_to_left = bls_node.inputs['Mask - Right to Left'].default_value
+            mask_ring_inner_radius = bls_node.inputs['Mask - Ring Inner Radius'].default_value
+            mask_ring_outer_radius = bls_node.inputs['Mask - Ring Outer Radius'].default_value
+            mask_ring_switch = bls_node.inputs['Mask - Ring Switch'].default_value
+            mask_top_to_bottom = bls_node.inputs['Mask - Top to Bottom'].default_value
+
+            lightIconShader.uniform_float("mask_bottom_to_top", mask_bottom_to_top)
+            lightIconShader.uniform_float("mask_diagonal_bottom_left", mask_diagonal_bottom_left)
+            lightIconShader.uniform_float("mask_diagonal_bottom_right", mask_diagonal_bottom_right)
+            lightIconShader.uniform_float("mask_diagonal_top_left", mask_diagonal_top_left)
+            lightIconShader.uniform_float("mask_diagonal_top_right", mask_diagonal_top_right)
+            lightIconShader.uniform_float("mask_gradient_amount", mask_gradient_amount)
+            lightIconShader.uniform_float("mask_gradient_switch", mask_gradient_switch)
+            lightIconShader.uniform_float("mask_gradient_type", mask_gradient_type)
+            lightIconShader.uniform_float("mask_left_to_right", mask_left_to_right)
+            lightIconShader.uniform_float("mask_right_to_left", mask_right_to_left)
+            lightIconShader.uniform_float("mask_ring_inner_radius", mask_ring_inner_radius)
+            lightIconShader.uniform_float("mask_ring_outer_radius", mask_ring_outer_radius)
+            lightIconShader.uniform_float("mask_ring_switch", mask_ring_switch)
+            lightIconShader.uniform_float("mask_top_to_bottom", mask_top_to_bottom)
+        except:
+            pass
         bgl.glEnable(bgl.GL_BLEND);
 
         if lleft < bleft:

commit cbf8a5994f3d81dd32b54d7bc25d3f900d035ee2
Author: StyriamMZ <styriam@o2.pl>
Date:   Wed Mar 18 12:53:05 2020 +0100

    2.5.0

diff --git a/src/deleteOperator.py b/src/deleteOperator.py
deleted file mode 100644
index f525d96..0000000
--- a/src/deleteOperator.py
+++ /dev/null
@@ -1,63 +0,0 @@
-import bpy
-from bpy.props import BoolProperty
-from . common import findLightGrp
-
-class DeleteOperator(bpy.types.Operator):
-    """ Custom delete """
-    bl_idname = "object.delete_custom" 
-    bl_label = "Custom Delete"
-    bl_options = {'REGISTER', 'UNDO'}
-
-    use_global: BoolProperty(default = False)
-
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
-    
-    def execute(self, context):
-        protected_groups = [findLightGrp(ob) for ob in context.selected_objects if ob.protected]
-        protected_objects = (ob for ob in context.selected_objects if ob.protected)
-        
-        for obj in protected_objects:
-            context.view_layer.objects.active = obj
-            if hasattr(obj, 'use_fake_user'):
-                obj.use_fake_user = False
-            ret = bpy.ops.scene.delete_blender_studio_light()
-            if 'CANCELLED' in ret:
-                self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
-        
-        bpy.ops.object.delete(use_global=self.use_global)
-
-        return {'FINISHED'}
-
-    # def invoke(self, context, event):
-    #     wm = context.window_manager
-    #     return wm.invoke_confirm(self, event)
-        
-addon_keymaps = []
-def add_shortkeys():       
-    wm = bpy.context.window_manager
-    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
-    addon_kmi.properties.use_global = False
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
-    addon_kmi.shift = True
-    addon_kmi.properties.use_global = True
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
-    addon_kmi.properties.use_global = False
-    
-    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
-    addon_kmi.shift = True
-    addon_kmi.properties.use_global = True
-    
-    addon_keymaps.append(addon_km)
-
-def remove_shortkeys():
-    wm = bpy.context.window_manager
-    for km in addon_keymaps:
-        wm.keyconfigs.addon.keymaps.remove(km)
-        
-    addon_keymaps.clear()

commit 5502689fdae979642f778269c00a3dc34fd88f3f
Author: StyriamMZ <styriam@o2.pl>
Date:   Sat Mar 14 00:24:02 2020 +0100

    2.5.0

diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 0a7c1f1..15a9f77 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -10,9 +10,6 @@ from copy import deepcopy
 shader2Dcolor = gpu.shader.from_builtin('2D_UNIFORM_COLOR')
 shader2Dcolor.bind()
 
-# shader2Dtexture = gpu.shader.from_builtin('2D_IMAGE')
-# shader2Dtexture.bind()
-
 vertex_shader = '''
     uniform mat4 ModelViewProjectionMatrix;
 
@@ -33,6 +30,7 @@ fragment_shader = '''
     #define PI 3.1415926535897932384626433832795f
 
     in vec2 texCoord_interp;
+    in vec4 gl_FragCoord;
     out vec4 fragColor;
 
     uniform sampler2D image;
@@ -41,6 +39,9 @@ fragment_shader = '''
     uniform vec4 color_overlay;
     uniform float color_saturation;
 
+    uniform vec2 panel_point_lt;
+    uniform vec2 panel_point_rb;
+
     void main()
     {
         // Texture Switch + Intensity
@@ -55,12 +56,49 @@ fragment_shader = '''
         fragColor = mix(fragColor, colored, color_saturation);
         fragColor.a = gray;
         fragColor.rgb *= fragColor.a;
+
+        if(gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
+            fragColor.rgba = vec4(0);
+    }
+'''
+
+border_vertex_shader= '''
+    uniform mat4 ModelViewProjectionMatrix;
+
+    #ifdef UV_POS
+    in vec2 u;
+    #  define pos u
+    #else
+    in vec2 pos;
+    #endif
+
+    void main()
+    {
+        gl_Position = ModelViewProjectionMatrix * vec4(pos, 0.0, 1.0);
+    }
+'''
+border_fragment_shader= '''
+    uniform vec4 color;
+    uniform vec2 panel_point_lt;
+    uniform vec2 panel_point_rb;
+    in vec4 gl_FragCoord;
+    out vec4 fragColor;
+
+    void main()
+    {
+        fragColor = color;
+
+        if(gl_FragCoord.x < panel_point_lt.x || gl_FragCoord.x > panel_point_rb.x)
+            fragColor.rgba = vec4(0);
     }
 '''
 
 lightIconShader = gpu.types.GPUShader(vertex_shader, fragment_shader)
 lightIconShader.bind()
 
+border_shader2Dcolor = gpu.types.GPUShader(border_vertex_shader, border_fragment_shader)
+border_shader2Dcolor.bind()
+
 class Rectangle:
     def __init__(self, start_point, width, height):
         self.point_lt = Vector((
@@ -227,184 +265,105 @@ class Border(Rectangle):
         super().__init__(Vector((0, 0)), 100, 100)
 
     def draw(self):
+        verts = self.get_verts()
+        lleft = min(verts, key=lambda v: v[0])[0]
+        lright = max(verts, key=lambda v: v[0])[0]
+
         bleft = self.light_image.panel.point_lt[0]
         bright = self.light_image.panel.point_rb[0]
-        lleft = self.light_image.point_lt[0]
-        lright = self.light_image.point_rb[0]
 
-        off = 0
-        # is left overextending
-        if lleft < bleft:
-            off = lleft - bleft
+        from mathutils import Euler
+        rot_translate = Vector((self.weight, 0, 0))
+        rot_translate.rotate(Euler((0,0,self.rot)))
+        rot_translate_ort = Vector((-rot_translate.y, rot_translate.x))
+
+                #       0   1
+        # 0  lt.x, lt.y         0 2
+        # 1  lt.x, rb.y         1 3
+        # 2  rb.x, lt.y
+        # 3  rb.x, rb.y
+
+        left_verts = [
+            verts[0],
+            verts[1],
+            [verts[0][0]+rot_translate.x, verts[0][1]+rot_translate.y],
+            [verts[1][0]+rot_translate.x, verts[1][1]+rot_translate.y]
+        ]
+
+        right_verts = [
+            [verts[2][0]-rot_translate.x, verts[2][1]-rot_translate.y],
+            [verts[3][0]-rot_translate.x, verts[3][1]-rot_translate.y],
+            verts[2],
+            verts[3]
+        ]
+
+        top_verts = [
+            verts[0],
+            [verts[0][0]-rot_translate_ort.x, verts[0][1]-rot_translate_ort.y],
+            verts[2],
+            [verts[2][0]-rot_translate_ort.x, verts[2][1]-rot_translate_ort.y]
+        ]
+
+        bottom_verts = [
+            [verts[1][0]+rot_translate_ort.x, verts[1][1]+rot_translate_ort.y],
+            verts[1],
+            [verts[3][0]+rot_translate_ort.x, verts[3][1]+rot_translate_ort.y],
+            verts[3]
+        ]
         
-        # is right overextending
+        border_shader2Dcolor.bind()
+        bgl.glEnable(bgl.GL_BLEND);
+        border_shader2Dcolor.uniform_float("color", self.color)
+        border_shader2Dcolor.uniform_float("panel_point_lt", self.light_image.panel.point_lt)
+        border_shader2Dcolor.uniform_float("panel_point_rb", self.light_image.panel.point_rb)
+        if lleft < bleft:
+            left_verts2 = deepcopy(left_verts)
+            for v in left_verts2:
+                v[0] += self.light_image.panel.width
+
+            right_verts2 = deepcopy(right_verts)
+            for v in right_verts2:
+                v[0] += self.light_image.panel.width
+            
+            top_verts2 = deepcopy(top_verts)
+            for v in top_verts2:
+                v[0] += self.light_image.panel.width
+            
+            bottom_verts2 = deepcopy(bottom_verts)
+            for v in bottom_verts2:
+                v[0] += self.light_image.panel.width
+
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(border_shader2Dcolor)
         elif lright > bright:
-            off = lright - bright
+            left_verts2 = deepcopy(left_verts)
+            for v in left_verts2:
+                v[0] -= self.light_image.panel.width
 
-        verts = self.get_verts()
+            right_verts2 = deepcopy(right_verts)
+            for v in right_verts2:
+                v[0] -= self.light_image.panel.width
+            
+            top_verts2 = deepcopy(top_verts)
+            for v in top_verts2:
+                v[0] -= self.light_image.panel.width
+            
+            bottom_verts2 = deepcopy(bottom_verts)
+            for v in bottom_verts2:
+                v[0] -= self.light_image.panel.width
+
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(border_shader2Dcolor)
+            batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(border_shader2Dcolor)
         
-        if off < 0:
-            verts2 = deepcopy(verts)
-
-            # 1st part
-            verts[0][0] -= off - self.weight
-            verts[1][0] = verts[0][0]
-
-            right_verts = [
-                [verts[2][0]-self.weight, verts[0][1]],
-                [verts[2][0]-self.weight, verts[1][1]],
-                verts[2],
-                verts[3]
-            ]
-
-            top_verts = [
-                verts[0],
-                [verts[0][0], verts[0][1]-self.weight],
-                verts[2],
-                [verts[2][0], verts[2][1]-self.weight]
-            ]
-
-            bottom_verts = [
-                [verts[0][0], verts[1][1]+self.weight],
-                verts[1],
-                [verts[2][0], verts[3][1]+self.weight],
-                verts[3]
-            ]
-
-            # 2nd part
-            verts2[0][0] = verts2[1][0] = self.light_image.panel.point_rb[0] + off - self.weight
-            verts2[2][0] = verts2[3][0] = self.light_image.panel.point_rb[0]
-
-            left_verts2 = [
-                verts2[0],
-                verts2[1],
-                [verts2[0][0]+self.weight, verts2[2][1]],
-                [verts2[0][0]+self.weight, verts2[3][1]]
-            ]
-
-            top_verts2 = [
-                verts2[0],
-                [verts2[0][0], verts2[0][1]-self.weight],
-                verts2[2],
-                [verts2[2][0], verts2[2][1]-self.weight]
-            ]
-
-            bottom_verts2 = [
-                [verts2[0][0], verts2[1][1]+self.weight],
-                verts2[1],
-                [verts2[2][0], verts2[3][1]+self.weight],
-                verts2[3]
-            ]
-
-            shader2Dcolor.uniform_float("color", self.color)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(shader2Dcolor)
-
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(shader2Dcolor)
-        elif off > 0:
-            verts2 = deepcopy(verts)
-
-            # 1st part
-            verts[2][0] -= off + self.weight
-            verts[3][0] = verts[2][0]
-
-            left_verts = [
-                verts[0],
-                verts[1],
-                [verts[0][0]+self.weight, verts[2][1]],
-                [verts[0][0]+self.weight, verts[3][1]]
-            ]
-
-            top_verts = [
-                verts[0],
-                [verts[0][0], verts[0][1]-self.weight],
-                verts[2],
-                [verts[2][0], verts[2][1]-self.weight]
-            ]
-
-            bottom_verts = [
-                [verts[0][0], verts[1][1]+self.weight],
-                verts[1],
-                [verts[2][0], verts[3][1]+self.weight],
-                verts[3]
-            ]
-
-            # 2nd part
-            verts2[0][0] = verts2[1][0] = self.light_image.panel.point_lt[0]
-            verts2[2][0] = verts2[3][0] = self.light_image.panel.point_lt[0] + off + self.weight
-
-            right_verts2 = [
-                [verts2[2][0]-self.weight, verts2[0][1]],
-                [verts2[2][0]-self.weight, verts2[1][1]],
-                verts2[2],
-                verts2[3]
-            ]
-
-            top_verts2 = [
-                verts2[0],
-                [verts2[0][0], verts2[0][1]-self.weight],
-                verts2[2],
-                [verts2[2][0], verts2[2][1]-self.weight]
-            ]
-
-            bottom_verts2 = [
-                [verts2[0][0], verts2[1][1]+self.weight],
-                verts2[1],
-                [verts2[2][0], verts2[3][1]+self.weight],
-                verts2[3]
-            ]
-
-            shader2Dcolor.uniform_float("color", self.color)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(shader2Dcolor)
-
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(shader2Dcolor)
-        else:        
-            #       0   1
-            # 0  lt.x, lt.y         0 2
-            # 1  lt.x, rb.y         1 3
-            # 2  rb.x, lt.y
-            # 3  rb.x, rb.y
-
-            left_verts = [
-                verts[0],
-                verts[1],
-                [verts[0][0]+self.weight, verts[2][1]],
-                [verts[0][0]+self.weight, verts[3][1]]
-            ]
-
-            right_verts = [
-                [verts[2][0]-self.weight, verts[0][1]],
-                [verts[2][0]-self.weight, verts[1][1]],
-                verts[2],
-                verts[3]
-            ]
-
-            top_verts = [
-                verts[0],
-                [verts[0][0], verts[0][1]-self.weight],
-                verts[2],
-                [verts[2][0], verts[2][1]-self.weight]
-            ]
-
-            bottom_verts = [
-                [verts[0][0], verts[1][1]+self.weight],
-                verts[1],
-                [verts[2][0], verts[3][1]+self.weight],
-                verts[3]
-            ]
-
-            shader2Dcolor.uniform_float("color", self.color)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(shader2Dcolor)
-            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(shader2Dcolor)
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(border_shader2Dcolor)
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(border_shader2Dcolor)
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(border_shader2Dcolor)
+        batch_for_shader(border_shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(border_shader2Dcolor)
+        bgl.glDisable(bgl.GL_BLEND);
 
     def get_verts(self):
         self.point_lt = self.light_image.point_lt.copy()
@@ -552,30 +511,35 @@ class LightImage(Rectangle):
         self._bls_mesh.select_set(True)
 
     def is_mouse_over(self, mouse_x, mouse_y):
-        if not (mouse_y <= self.point_lt[1] and mouse_y >= self.point_rb[1]):
-            return False
-        if not (mouse_x >= self.panel.point_lt[0] and mouse_x <= self.panel.point_rb[0]):
-            return False
-        if mouse_x >= self.point_lt[0] and mouse_x <= self.point_rb[0]:
-            return True
-
+        def rotate(x1, y1, offset):
+            x1 -= offset.x
+            y1 -= offset.y
+            x2 = cos(-self.rot) * x1 - sin(-self.rot) * y1
+            y2 = sin(-self.rot) * x1 + cos(-self.rot) * y1
+            x2 += offset.x
+            y2 += offset.y
+            return [x2, y2]
+        
         bleft = self.panel.point_lt[0]
         bright = self.panel.point_rb[0]
-        lleft = self.point_lt[0]
-        lright = self.point_rb[0]
 
-        off = 0
-        # is left overextending
-        if lleft < bleft:
-            off = lleft - bleft
-            if mouse_x >= bright + off:
-                return True
+        if mouse_x > bright or mouse_x < bleft:
+            return False
+
+        tmouse_x, tmouse_y = rotate(mouse_x, mouse_y, self.loc)
+        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
+            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
+            return True
         
-        # is right overextending
-        elif lright > bright:
-            off = lright - bright
-            if mouse_x <= bleft + off:
-                return True
+        tmouse_x, tmouse_y = rotate(bleft-(bright-mouse_x), mouse_y, self.loc)
+        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
+            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
+            return True
+
+        tmouse_x, tmouse_y = rotate(bright+(mouse_x-bleft), mouse_y, self.loc)
+        if (tmouse_y <= self.point_lt[1] and tmouse_y >= self.point_rb[1]) and\
+            (tmouse_x <= self.point_rb[0] and tmouse_x >= self.point_lt[0]):
+            return True
 
         return False
 
@@ -591,22 +555,12 @@ class LightImage(Rectangle):
 
         bleft = self.panel.point_lt[0]
         bright = self.panel.point_rb[0]
-        lleft = self.point_lt[0]
-        lright = self.point_rb[0]
-
-        off = 0
-        # is left overextending
-        if lleft < bleft:
-            off = lleft - bleft
         
-        # is right overextending
-        elif lright > bright:
-            off = lright - bright
-
-        uv_factor = abs(off / self.width)
-
         verts = self.get_verts()
         uv_coords = self.get_tex_coords()
+        
+        lleft = min(verts, key=lambda v: v[0])[0]
+        lright = max(verts, key=lambda v: v[0])[0]
 
         if self.mute:
             self.mute_border.draw()
@@ -631,18 +585,15 @@ class LightImage(Rectangle):
         lightIconShader.uniform_float("color_overlay", color_overlay)
         lightIconShader.uniform_float("color_saturation", color_saturation)
 
-        bgl.glEnable(bgl.GL_BLEND);
-        if off < 0:
-            verts2 = deepcopy(verts)
-            verts[0][0] -= off
-            verts[1][0] = verts[0][0]
+        lightIconShader.uniform_float("panel_point_lt", self.panel.point_lt)
+        lightIconShader.uniform_float("panel_point_rb", self.panel.point_rb)
 
-            verts2[0][0] = verts2[1][0] = self.panel.point_rb[0] + off
-            verts2[2][0] = verts2[3][0] = self.panel.point_rb[0]
+        bgl.glEnable(bgl.GL_BLEND);
 
-            uv_coords2 = deepcopy(uv_coords)
-            uv_coords[0][0] = uv_coords[1][0] = uv_factor
-            uv_coords2[2][0] = uv_coords2[3][0] = uv_factor
+        if lleft < bleft:
+            verts2 = deepcopy(verts)
+            for v in verts2:
+                v[0] += self.panel.width
 
             batch_for_shader(
                 lightIconShader, 'TRI_STRIP',
@@ -656,20 +607,13 @@ class LightImage(Rectangle):
                 lightIconShader, 'TRI_STRIP',
                 {
                     "pos": verts2,
-                    "texCoord": uv_coords2,
+                    "texCoord": uv_coords,
                 }
             ).draw(lightIconShader)
-        elif off > 0:
+        elif lright > bright:
             verts2 = deepcopy(verts)
-            verts[2][0] -= off
-            verts[3][0] = verts[2][0]
-
-            verts2[0][0] = verts2[1][0] = self.panel.point_lt[0]
-            verts2[2][0] = verts2[3][0] = self.panel.point_lt[0] + off
-
-            uv_coords2 = deepcopy(uv_coords)
-            uv_coords[2][0] = uv_coords[3][0] = 1-uv_factor
-            uv_coords2[0][0] = uv_coords2[1][0] = 1-uv_factor
+            for v in verts2:
+                v[0] -= self.panel.width
 
             batch_for_shader(
                 lightIconShader, 'TRI_STRIP',
@@ -683,7 +627,7 @@ class LightImage(Rectangle):
                 lightIconShader, 'TRI_STRIP',
                 {
                     "pos": verts2,
-                    "texCoord": uv_coords2,
+                    "texCoord": uv_coords,
                 }
             ).draw(lightIconShader)
         else:

commit 94786584dc477486eda57de67d55ac90ea522744
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Mar 13 18:27:58 2020 +0100

    2.5.0

diff --git a/src/operators/modal.py b/src/operators/modal.py
index 2ec6d4d..08c5013 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -318,7 +318,12 @@ class BLS_OT_control_panel(bpy.types.Operator):
                     dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
 
                     overlapped = self.find_clicked(area_mouse_x, area_mouse_y, overlapping=True)
-                    self.clicked_object = overlapped[0] if overlapped else None
+                    if type(overlapped) == list:
+                        # List of overlapping lights
+                        self.clicked_object = overlapped[0] if overlapped else None
+                    else:
+                        # Button
+                        self.clicked_object = overlapped
                     self.panel_moving = self.clicked_object != None
                     
                     click_result = self.click_manager.click(self.clicked_object)

commit 7eac5176bf94ecb814bc4638530c6248395474d1
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Mar 13 18:16:36 2020 +0100

    2.5.0

diff --git a/src/operators/modal.py b/src/operators/modal.py
index eb60daa..2ec6d4d 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -317,7 +317,8 @@ class BLS_OT_control_panel(bpy.types.Operator):
                 elif event.type == "LEFTMOUSE":
                     dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
 
-                    self.clicked_object = self.find_clicked(area_mouse_x, area_mouse_y)
+                    overlapped = self.find_clicked(area_mouse_x, area_mouse_y, overlapping=True)
+                    self.clicked_object = overlapped[0] if overlapped else None
                     self.panel_moving = self.clicked_object != None
                     
                     click_result = self.click_manager.click(self.clicked_object)
@@ -344,9 +345,11 @@ class BLS_OT_control_panel(bpy.types.Operator):
 
                     if hasattr(self.clicked_object, 'select'):
                         self.clicked_object.select()
-                        if self.ctrl:
+                        if self.ctrl and len(overlapped)>1:
                             send_light_to_bottom(self.clicked_object)
                             self.find_clicked(area_mouse_x, area_mouse_y).select()
+                        else:
+                            send_light_to_top(self.clicked_object)
 
 
                     if hasattr(self.clicked_object, 'click'):
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index b4b9458..0a7c1f1 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -133,13 +133,20 @@ class Rectangle:
         new_loc.y = clamp(rect.point_rb.y, new_loc.y, rect.point_lt.y)
         self.loc = new_loc
 
-def send_light_to_bottom(args):
-    light = LightImage.selected_object
+def send_light_to_bottom(light):
+    light = LightImage.selected_object if not light else light
     if not light:
         return
     lights = LightImage.lights
     lights.insert(0, lights.pop(lights.index(light)))
 
+def send_light_to_top(light):
+    light = LightImage.selected_object if not light else light
+    if not light:
+        return
+    lights = LightImage.lights
+    lights.append(lights.pop(lights.index(light)))
+
 class Panel(Rectangle):
     def __init__(self, loc, width, height):
         super().__init__(loc, width, height)

commit e70200b27b6ae0c8eabe10096e84c04dce866685
Author: StyriamMZ <styriam@o2.pl>
Date:   Fri Mar 13 16:26:26 2020 +0100

    2.5.0

diff --git a/src/BLS3.blend b/src/BLS3.blend
index d6ed6aa..5939dec 100644
Binary files a/src/BLS3.blend and b/src/BLS3.blend differ
diff --git a/src/__init__.py b/src/__init__.py
index 25b5a80..e9b6f34 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -4,7 +4,7 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 4, 0),
+    "version": (2, 5, 0),
     "blender": (2, 80, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
@@ -26,7 +26,6 @@ auto_load.init()
 
 from . light_operators import Blender_Light_Studio_Properties
 from . import deleteOperator
-from . import light_preview_list
 
 def register():
     auto_load.register()
@@ -34,7 +33,6 @@ def register():
     bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
     bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
     deleteOperator.add_shortkeys()
-    light_preview_list.register()
     
 
 def unregister():
diff --git a/src/auto_load.py b/src/auto_load.py
index f369928..0f930b5 100644
--- a/src/auto_load.py
+++ b/src/auto_load.py
@@ -138,7 +138,7 @@ def get_register_base_types():
         "Panel", "Operator", "PropertyGroup",
         "AddonPreferences", "Header", "Menu",
         "Node", "NodeSocket", "NodeTree",
-        "UIList", "RenderEngine"
+        "UIList", "RenderEngine", "KeyingSetInfo"
     ])
 
 
diff --git a/src/gui.py b/src/gui.py
index 53b32e6..45d174e 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -1,7 +1,9 @@
 import bpy
 import os
 from . common import getLightMesh
+from . auto_load import force_register
 
+@force_register
 class BLS_PT_Studio(bpy.types.Panel):
     bl_idname = "BLS_PT_studio"
     bl_label = "Studio"
@@ -21,36 +23,7 @@ class BLS_PT_Studio(bpy.types.Panel):
         col.separator()
         col.operator('light_studio.control_panel', icon='MENU_PANEL')
 
-class BLS_PT_ProfileList(bpy.types.Panel):
-    bl_idname = "BLS_PT_profile_list"
-    bl_label = "Profiles"
-    bl_space_type = "VIEW_3D"
-    bl_region_type = "UI"
-    bl_category = "Light Studio"
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-            
-    def draw(self, context):
-        layout = self.layout
-        scene = context.scene
-        
-        props = scene.BLStudio
-        
-        row = layout.row()
-        col = row.column()
-        col.template_list("BLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
-        
-        col = row.column(align=True)
-        col.operator('bls_list.new_profile', icon='PLUS', text="")
-        col.operator('bls_list.delete_profile', icon='TRASH', text="")
-        col.operator('bls_list.copy_profile_menu', icon='DUPLICATE', text="")
-        
-        col.separator()
-        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
-        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
-                
+@force_register
 class BLS_PT_Lights(bpy.types.Panel):
     bl_idname = "BLS_PT_lights"
     bl_label = "Lights"
@@ -68,7 +41,8 @@ class BLS_PT_Lights(bpy.types.Panel):
         row = col.row(align=True)
         row.operator('scene.add_blender_studio_light', text='Add Light')
         row.operator('scene.delete_blender_studio_light', text='Delete Light')
-        
+
+@force_register
 class BLS_PT_Selected(bpy.types.Panel):
     bl_idname = "BLS_PT_selected"
     bl_label = "Selected Light"
@@ -78,7 +52,7 @@ class BLS_PT_Selected(bpy.types.Panel):
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'    
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
     
     def draw(self, context):
         if context.active_object and (context.active_object.name.startswith('BLS_CONTROLLER') or context.active_object.name.startswith('BLS_LIGHT_MESH')):
@@ -108,23 +82,39 @@ class BLS_PT_Selected(bpy.types.Panel):
                 import traceback
                 traceback.print_exc()
             col.prop(getLightMesh(), 'location', index=0) #light radius
-                
-class BLS_PT_Visibility(bpy.types.Panel):
-    bl_label = "Visibility Options"
+
+@force_register
+class BLS_PT_ProfileList(bpy.types.Panel):
+    bl_idname = "BLS_PT_profile_list"
+    bl_label = "Profiles"
     bl_space_type = "VIEW_3D"
     bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.BLStudio.profile_list)
-    
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+            
     def draw(self, context):
         layout = self.layout
-        col = layout.column(align=True)
-        col.operator('object.mute_other_lights')
-        col.operator('object.show_all_lights')
+        scene = context.scene
+        
+        props = scene.BLStudio
         
+        row = layout.row()
+        col = row.column()
+        col.template_list("BLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
+        
+        col = row.column(align=True)
+        col.operator('bls_list.new_profile', icon='PLUS', text="")
+        col.operator('bls_list.delete_profile', icon='TRASH', text="")
+        col.operator('bls_list.copy_profile_menu', icon='DUPLICATE', text="")
+        
+        col.separator()
+        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
+        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
+
+@force_register
 class BLS_PT_ProfileImportExport(bpy.types.Panel):
     bl_idname = "BLS_PT_profile_import_export"
     bl_label = "Import/Export"
@@ -146,7 +136,7 @@ class BLS_PT_ProfileImportExport(bpy.types.Panel):
         col.operator('bls_list.import_profiles')
 
 from . import bl_info
-
+@force_register
 class BLS_PT_Misc(bpy.types.Panel):
     bl_idname = "BLS_PT_misc"
     bl_label = "Misc"
@@ -166,4 +156,18 @@ class BLS_PT_Misc(bpy.types.Panel):
               
         col = layout.column(align=True)
         col.operator('bls.find_missing_textures')
-        
\ No newline at end of file
+        col.operator('bls.bls_keyingset')
+        if context.scene.keying_sets.active and context.scene.keying_sets.active.bl_idname == "BUILTIN_KSI_LightStudio":
+            box = col.box()
+            box.label(text="Keying Set is active")
+
+class BLSKeyingSet(bpy.types.Operator):
+    """Activate Light Studio Keying Set to animate lights"""
+    bl_idname = "bls.bls_keyingset"
+    bl_description = "Activate Light Studio Keying Set to animate lights"
+    bl_label = "Light Studio Keying Set"
+    bl_options = {"INTERNAL", "UNDO"}
+
+    def execute(self, context):
+        context.scene.keying_sets.active = [k for k in context.scene.keying_sets_all if k.bl_idname == "BUILTIN_KSI_LightStudio"][0]
+        return {"FINISHED"}
\ No newline at end of file
diff --git a/src/light_operators.py b/src/light_operators.py
index ee1a224..7ace206 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -70,13 +70,13 @@ class DeleteBlenderLightStudio(bpy.types.Operator):
             
         obsToRemove = [ob for ob in scene.objects if isFamily(ob)]
         for ob in obsToRemove:
-            scene.objects.unlink(ob)
-            for gr in ob.users_group:
-                gr.objects.unlink(ob)
+            for c in ob.users_collection:
+                c.objects.unlink(ob)
             ob.user_clear()
             ob.use_fake_user = False
             bpy.data.objects.remove(ob)
             
+        context.scene.collection.children.unlink(get_bls_collection(context))
         
         return {"FINISHED"}
      
@@ -177,54 +177,28 @@ class DeleteBSLight(bpy.types.Operator):
         layout = self.layout
         col = layout.column(align=True)
         col.label(text="OK?")
-    
-class BSL_MuteOtherLights(bpy.types.Operator):
-    bl_idname = "object.mute_other_lights"
-    bl_label = "Show Only This Light"
-    bl_description = "Show only this light."
-    bl_options = {"INTERNAL", "UNDO"}
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized \
-            and context.active_object and (context.active_object.name.startswith('BLS_CONTROLLER') or context.active_object.name.startswith('BLS_LIGHT_MESH'))
-    
-    def execute(self, context):
-        obs = context.scene.objects
-        lightGrp = obs.active
-        light_no = lightGrp.name.split('.')[1]
-    
-        for light in (ob for ob in obs if ob.name.startswith('BLS_LIGHT_MESH') and isFamily(ob)):
-            if light.name[-3:] == light_no:
-                light.hide_render = False
-                light.hide = False
-            else:
-                light.hide_render = True
-                light.hide = True
-                
-        # context.scene.frame_current = context.scene.frame_current # refresh hack
-        # refreshMaterials()
-    
-        return {"FINISHED"}
-    
-class BSL_ShowAllLights(bpy.types.Operator):
-    bl_idname = "object.show_all_lights"
-    bl_label = "Show All Lights"
-    bl_description = "Show all lights."
-    bl_options = {"INTERNAL", "UNDO"}
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-    
-    def execute(self, context):
-        obs = context.scene.objects
-        for light in (ob for ob in obs if ob.name.startswith('BLS_LIGHT_MESH') and isFamily(ob)):
-            light.hide_render = False
-            light.hide = False
-                
-        # context.scene.frame_current = context.scene.frame_current # refresh hack
-        # refreshMaterials()
-    
-        return {"FINISHED"}
-        
\ No newline at end of file
+
+class BUILTIN_KSI_LightStudio(bpy.types.KeyingSetInfo):
+    bl_label = "LightStudio KeyingSet"
+
+    # poll - test for whether Keying Set can be used at all
+    def poll(ksi, context):
+        return context.active_object or context.selected_objects and context.scene.BLStudio.initialized
+
+    # iterator - go over all relevant data, calling generate()
+    def iterator(ksi, context, ks):
+        for ob in (l for l in context.selected_objects if l.name.startswith("BLS_LIGHT")):
+            ksi.generate(context, ks, ob)
+
+    # generator - populate Keying Set with property paths to use
+    def generate(ksi, context, ks, data):
+        id_block = data.id_data
+
+        bls_collection = get_collection(id_block)
+        light_mesh = [m for m in bls_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
+        bls_actuator = light_mesh.parent
+        
+        ks.paths.add(light_mesh, "location", index=0, group_method='KEYINGSET')
+        ks.paths.add(light_mesh, "rotation_euler", index=0, group_method='KEYINGSET')
+        ks.paths.add(light_mesh, "scale", group_method='KEYINGSET')
+        ks.paths.add(bls_actuator, "rotation_euler", group_method='KEYINGSET')
\ No newline at end of file
diff --git a/src/light_preview_list.py b/src/light_preview_list.py
index 052e9f8..60bf71c 100644
--- a/src/light_preview_list.py
+++ b/src/light_preview_list.py
@@ -28,8 +28,8 @@ def enum_previews_from_directory_items(self, context):
     if pcoll.initiated and dir_up <= pcoll.dir_update_time:
         return pcoll.tex_previews
     pcoll.dir_update_time = dir_up
-    pcoll.clear()
     
+    pcoll.clear()
 
     print("Scanning directory: %s" % directory)
 
@@ -88,7 +88,6 @@ def register():
             get=preview_enum_get,
             set=preview_enum_set,
             )
-
     import bpy.utils.previews
     pcoll = bpy.utils.previews.new()
     pcoll.bls_tex_previews = ()
@@ -97,7 +96,6 @@ def register():
 
     preview_collections["main"] = pcoll
 
-
 def unregister():
     from bpy.types import WindowManager
 
@@ -105,5 +103,5 @@ def unregister():
 
     for pcoll in preview_collections.values():
         bpy.utils.previews.remove(pcoll)
-    preview_collections.clear()
-    
\ No newline at end of file
+        pcoll.clear()
+    preview_collections.clear()
\ No newline at end of file
diff --git a/src/operators/modal.py b/src/operators/modal.py
index 25ef9e2..eb60daa 100644
--- a/src/operators/modal.py
+++ b/src/operators/modal.py
@@ -14,7 +14,6 @@ def draw(self, area):
     if area != bpy.context.area:
         return
 
-    # draw something to refresh renderer? color won't work otherwise
     shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
     batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
     #
@@ -25,7 +24,6 @@ def draw(self, area):
     for l in LightImage.lights:
         l.draw()
 
-
 class BLS_OT_Rotate(bpy.types.Operator, MouseWidget):
     bl_idname = "light_studio.rotate"
     bl_label = "Rotate Light"
@@ -151,7 +149,7 @@ class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
         return {"PASS_THROUGH"}
 
 panel_global = None
-# running_modals = 0
+running_modals = 0
 class BLS_OT_control_panel(bpy.types.Operator):
     bl_idname = "light_studio.control_panel"
     bl_label = "Light Studio Control Panel"
@@ -164,7 +162,7 @@ class BLS_OT_control_panel(bpy.types.Operator):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
 
     def __init__(self):
-        self.textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale"
+        self.textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale | [Ctrl+Click] Loop overlapping"
         self.handler = None
         self.panel = None
         self.panel_moving = False
@@ -178,11 +176,11 @@ class BLS_OT_control_panel(bpy.types.Operator):
         self._unregister_handler()
 
     def _unregister_handler(self):
-        # global running_modals
-        # running_modals = max(0, running_modals-1)
+        global running_modals
+        running_modals = max(0, running_modals-1)
         try:
             bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
-        except ValueError:
+        except (ValueError, AttributeError):
             pass
 
     def _mouse_event(self, context, event):
@@ -195,10 +193,12 @@ class BLS_OT_control_panel(bpy.types.Operator):
         return dx, dy, area_mouse_x, area_mouse_y
 
     def invoke(self, context, event):
-        # global running_modals
-        # running_modals += 1
-        # if running_modals > 1:
-        #     return {"CANCELLED"}
+        global running_modals
+        running_modals += 1
+        if running_modals > 1:
+            # toggle panel
+            running_modals = 0
+            return {"CANCELLED"}
 
         self.handler = bpy.types.SpaceView3D.draw_handler_add(draw, (self, context.area), 'WINDOW', 'POST_PIXEL')
         context.window_manager.modal_handler_add(self)
@@ -221,9 +221,17 @@ class BLS_OT_control_panel(bpy.types.Operator):
 
         context.area.header_text_set(text=self.textinfo)
 
+        self.ctrl = False
+
         return {"RUNNING_MODAL"}
     
     def modal(self, context, event):
+        global running_modals
+        if running_modals < 1:
+            self._unregister_handler()
+            context.area.tag_redraw()
+            return {"FINISHED"}
+
         # print(event.type, event.value)
         if not context.area or (context.object and not context.object.mode == 'OBJECT'):
             self._unregister_handler()
@@ -255,6 +263,9 @@ class BLS_OT_control_panel(bpy.types.Operator):
                 return {"PASS_THROUGH"}
             
             if event.value == "PRESS":
+                if event.type in {"LEFT_CTRL"}:
+                    self.ctrl = True
+
                 if event.type in {"R"}:
                     active_object = None
                     if LightImage.selected_object:
@@ -310,7 +321,7 @@ class BLS_OT_control_panel(bpy.types.Operator):
                     self.panel_moving = self.clicked_object != None
                     
                     click_result = self.click_manager.click(self.clicked_object)
-                    if hasattr(self.clicked_object, 'mute'):
+                    if not self.ctrl and hasattr(self.clicked_object, 'mute'):
                         if click_result == "TRIPLE":
                             muted_count = len([l for l in LightImage.lights if l.mute]) - 1
                             unmuted_count = len(LightImage.lights) - muted_count
@@ -333,6 +344,10 @@ class BLS_OT_control_panel(bpy.types.Operator):
 
                     if hasattr(self.clicked_object, 'select'):
                         self.clicked_object.select()
+                        if self.ctrl:
+                            send_light_to_bottom(self.clicked_object)
+                            self.find_clicked(area_mouse_x, area_mouse_y).select()
+
 
                     if hasattr(self.clicked_object, 'click'):
                         result = self.clicked_object.click()
@@ -369,6 +384,8 @@ class BLS_OT_control_panel(bpy.types.Operator):
                 elif event.type == "LEFT_SHIFT":
                     self.precision_mode = False
                     return {'RUNNING_MODAL'}
+                elif event.type in {"LEFT_CTRL"}:
+                    self.ctrl = False
 
             if event.value == "CLICK":
                 # Left mouse button clicked
@@ -399,10 +416,17 @@ class BLS_OT_control_panel(bpy.types.Operator):
 
             update_clear()
 
-    def find_clicked(self, area_mouse_x, area_mouse_y):
+    def find_clicked(self, area_mouse_x, area_mouse_y, overlapping=False):
+        overlapped = []
         for l in reversed(LightImage.lights):
-            if is_in_rect(l, Vector((area_mouse_x, area_mouse_y))):
-                return l
+            if l.is_mouse_over(area_mouse_x, area_mouse_y):
+                if not overlapping:
+                    return l
+                else:
+                    overlapped.append(l)
+
+        if overlapping and overlapped:
+            return overlapped
         
         for b in Button.buttons:
             if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
index 5e43d66..b4b9458 100644
--- a/src/operators/modal_utils.py
+++ b/src/operators/modal_utils.py
@@ -5,12 +5,61 @@ from math import pi, fmod, radians, sin, cos, atan2
 from .. common import *
 from . import *
 import time
+from copy import deepcopy
 
 shader2Dcolor = gpu.shader.from_builtin('2D_UNIFORM_COLOR')
 shader2Dcolor.bind()
 
-shader2Dtexture = gpu.shader.from_builtin('2D_IMAGE')
-shader2Dtexture.bind()
+# shader2Dtexture = gpu.shader.from_builtin('2D_IMAGE')
+# shader2Dtexture.bind()
+
+vertex_shader = '''
+    uniform mat4 ModelViewProjectionMatrix;
+
+    /* Keep in sync with intern/opencolorio/gpu_shader_display_transform_vertex.glsl */
+    in vec2 pos;
+    in vec2 texCoord;
+    out vec2 texCoord_interp;
+
+    void main()
+    {
+        gl_Position = ModelViewProjectionMatrix * vec4(pos.xy, 0.0f, 1.0f);
+        gl_Position.z = 1.0;
+        texCoord_interp = texCoord;
+    }
+'''
+
+fragment_shader = '''
+    #define PI 3.1415926535897932384626433832795f
+
+    in vec2 texCoord_interp;
+    out vec4 fragColor;
+
+    uniform sampler2D image;
+    uniform float intensity;
+    uniform float texture_switch;
+    uniform vec4 color_overlay;
+    uniform float color_saturation;
+
+    void main()
+    {
+        // Texture Switch + Intensity
+        // log(1+intensity) so the images won't get overexposed too fast when high intensity values used
+        fragColor = mix(vec4(1.0f), texture(image, texCoord_interp), texture_switch) * log(1+intensity);
+        
+        // Color Overlay
+        float gray = clamp(dot(fragColor.rgb, vec3(0.299, 0.587, 0.114)), 0, 1);
+        vec4 colored = color_overlay * gray;
+        
+        // Color Saturation
+        fragColor = mix(fragColor, colored, color_saturation);
+        fragColor.a = gray;
+        fragColor.rgb *= fragColor.a;
+    }
+'''
+
+lightIconShader = gpu.types.GPUShader(vertex_shader, fragment_shader)
+lightIconShader.bind()
 
 class Rectangle:
     def __init__(self, start_point, width, height):
@@ -63,7 +112,7 @@ class Rectangle:
             y2 = sin(self.rot) * x1 + cos(self.rot) * y1
             x2 += offset.x
             y2 += offset.y
-            return (x2, y2)
+            return [x2, y2]
         
         loc = self.loc # prevent property from recomputing
         return (
@@ -74,7 +123,7 @@ class Rectangle:
         )
 
     def get_tex_coords(self):
-        return ((0, 1), (0, 0), (1, 1), (1, 0))
+        return ([0, 1], [0, 0], [1, 1], [1, 0])
 
     def move(self, loc_diff):
         rect = self.panel if hasattr(self, 'panel') else self
@@ -84,6 +133,13 @@ class Rectangle:
         new_loc.y = clamp(rect.point_rb.y, new_loc.y, rect.point_lt.y)
         self.loc = new_loc
 
+def send_light_to_bottom(args):
+    light = LightImage.selected_object
+    if not light:
+        return
+    lights = LightImage.lights
+    lights.insert(0, lights.pop(lights.index(light)))
+
 class Panel(Rectangle):
     def __init__(self, loc, width, height):
         super().__init__(loc, width, height)
@@ -91,10 +147,6 @@ class Panel(Rectangle):
         self.button_exit.function = lambda x: "FINISHED"
 
         self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
-        def send_light_to_bottom(args):
-            light = LightImage.selected_object
-            lights = LightImage.lights
-            lights.insert(0, lights.pop(lights.index(light)))
         self.button_send_to_bottom.function = send_light_to_bottom
 
         self._move_buttons()
@@ -168,15 +220,192 @@ class Border(Rectangle):
         super().__init__(Vector((0, 0)), 100, 100)
 
     def draw(self):
-        shader2Dcolor.uniform_float("color", self.color)
-        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
+        bleft = self.light_image.panel.point_lt[0]
+        bright = self.light_image.panel.point_rb[0]
+        lleft = self.light_image.point_lt[0]
+        lright = self.light_image.point_rb[0]
+
+        off = 0
+        # is left overextending
+        if lleft < bleft:
+            off = lleft - bleft
+        
+        # is right overextending
+        elif lright > bright:
+            off = lright - bright
+
+        verts = self.get_verts()
+        
+        if off < 0:
+            verts2 = deepcopy(verts)
+
+            # 1st part
+            verts[0][0] -= off - self.weight
+            verts[1][0] = verts[0][0]
+
+            right_verts = [
+                [verts[2][0]-self.weight, verts[0][1]],
+                [verts[2][0]-self.weight, verts[1][1]],
+                verts[2],
+                verts[3]
+            ]
+
+            top_verts = [
+                verts[0],
+                [verts[0][0], verts[0][1]-self.weight],
+                verts[2],
+                [verts[2][0], verts[2][1]-self.weight]
+            ]
+
+            bottom_verts = [
+                [verts[0][0], verts[1][1]+self.weight],
+                verts[1],
+                [verts[2][0], verts[3][1]+self.weight],
+                verts[3]
+            ]
+
+            # 2nd part
+            verts2[0][0] = verts2[1][0] = self.light_image.panel.point_rb[0] + off - self.weight
+            verts2[2][0] = verts2[3][0] = self.light_image.panel.point_rb[0]
+
+            left_verts2 = [
+                verts2[0],
+                verts2[1],
+                [verts2[0][0]+self.weight, verts2[2][1]],
+                [verts2[0][0]+self.weight, verts2[3][1]]
+            ]
+
+            top_verts2 = [
+                verts2[0],
+                [verts2[0][0], verts2[0][1]-self.weight],
+                verts2[2],
+                [verts2[2][0], verts2[2][1]-self.weight]
+            ]
+
+            bottom_verts2 = [
+                [verts2[0][0], verts2[1][1]+self.weight],
+                verts2[1],
+                [verts2[2][0], verts2[3][1]+self.weight],
+                verts2[3]
+            ]
+
+            shader2Dcolor.uniform_float("color", self.color)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(shader2Dcolor)
+
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": left_verts2}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(shader2Dcolor)
+        elif off > 0:
+            verts2 = deepcopy(verts)
+
+            # 1st part
+            verts[2][0] -= off + self.weight
+            verts[3][0] = verts[2][0]
+
+            left_verts = [
+                verts[0],
+                verts[1],
+                [verts[0][0]+self.weight, verts[2][1]],
+                [verts[0][0]+self.weight, verts[3][1]]
+            ]
+
+            top_verts = [
+                verts[0],
+                [verts[0][0], verts[0][1]-self.weight],
+                verts[2],
+                [verts[2][0], verts[2][1]-self.weight]
+            ]
+
+            bottom_verts = [
+                [verts[0][0], verts[1][1]+self.weight],
+                verts[1],
+                [verts[2][0], verts[3][1]+self.weight],
+                verts[3]
+            ]
+
+            # 2nd part
+            verts2[0][0] = verts2[1][0] = self.light_image.panel.point_lt[0]
+            verts2[2][0] = verts2[3][0] = self.light_image.panel.point_lt[0] + off + self.weight
+
+            right_verts2 = [
+                [verts2[2][0]-self.weight, verts2[0][1]],
+                [verts2[2][0]-self.weight, verts2[1][1]],
+                verts2[2],
+                verts2[3]
+            ]
+
+            top_verts2 = [
+                verts2[0],
+                [verts2[0][0], verts2[0][1]-self.weight],
+                verts2[2],
+                [verts2[2][0], verts2[2][1]-self.weight]
+            ]
+
+            bottom_verts2 = [
+                [verts2[0][0], verts2[1][1]+self.weight],
+                verts2[1],
+                [verts2[2][0], verts2[3][1]+self.weight],
+                verts2[3]
+            ]
+
+            shader2Dcolor.uniform_float("color", self.color)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(shader2Dcolor)
+
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": right_verts2}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts2}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts2}).draw(shader2Dcolor)
+        else:        
+            #       0   1
+            # 0  lt.x, lt.y         0 2
+            # 1  lt.x, rb.y         1 3
+            # 2  rb.x, lt.y
+            # 3  rb.x, rb.y
+
+            left_verts = [
+                verts[0],
+                verts[1],
+                [verts[0][0]+self.weight, verts[2][1]],
+                [verts[0][0]+self.weight, verts[3][1]]
+            ]
+
+            right_verts = [
+                [verts[2][0]-self.weight, verts[0][1]],
+                [verts[2][0]-self.weight, verts[1][1]],
+                verts[2],
+                verts[3]
+            ]
+
+            top_verts = [
+                verts[0],
+                [verts[0][0], verts[0][1]-self.weight],
+                verts[2],
+                [verts[2][0], verts[2][1]-self.weight]
+            ]
+
+            bottom_verts = [
+                [verts[0][0], verts[1][1]+self.weight],
+                verts[1],
+                [verts[2][0], verts[3][1]+self.weight],
+                verts[3]
+            ]
+
+            shader2Dcolor.uniform_float("color", self.color)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": left_verts}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": right_verts}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": top_verts}).draw(shader2Dcolor)
+            batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": bottom_verts}).draw(shader2Dcolor)
 
     def get_verts(self):
         self.point_lt = self.light_image.point_lt.copy()
+        self.point_rb = self.light_image.point_rb.copy()
+
         self.point_lt.x -= self.weight
         self.point_lt.y += self.weight
 
-        self.point_rb = self.light_image.point_rb.copy()
         self.point_rb.x += self.weight
         self.point_rb.y -= self.weight
         
@@ -217,8 +446,8 @@ class LightImage(Rectangle):
     def change_default_size(cls, value):
         cls.default_size = value
         for l in cls.lights:
-            l.width = value
-            l.height = value
+            l.width = value * l._scale.y
+            l.height = value * l._scale.z
         
     def panel_loc_to_area_px_lt(self):
         panel_px_loc = Vector((self.panel.width * self.panel_loc.x, -self.panel.height * (1-self.panel_loc.y)))
@@ -315,6 +544,34 @@ class LightImage(Rectangle):
         bpy.context.view_layer.objects.active = self._bls_mesh
         self._bls_mesh.select_set(True)
 
+    def is_mouse_over(self, mouse_x, mouse_y):
+        if not (mouse_y <= self.point_lt[1] and mouse_y >= self.point_rb[1]):
+            return False
+        if not (mouse_x >= self.panel.point_lt[0] and mouse_x <= self.panel.point_rb[0]):
+            return False
+        if mouse_x >= self.point_lt[0] and mouse_x <= self.point_rb[0]:
+            return True
+
+        bleft = self.panel.point_lt[0]
+        bright = self.panel.point_rb[0]
+        lleft = self.point_lt[0]
+        lright = self.point_rb[0]
+
+        off = 0
+        # is left overextending
+        if lleft < bleft:
+            off = lleft - bleft
+            if mouse_x >= bright + off:
+                return True
+        
+        # is right overextending
+        elif lright > bright:
+            off = lright - bright
+            if mouse_x <= bleft + off:
+                return True
+
+        return False
+
     def draw(self):
         try:
             select = self._bls_mesh.select_get()
@@ -324,23 +581,113 @@ class LightImage(Rectangle):
         # draw something to refresh buffer?
         shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
         batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
+
+        bleft = self.panel.point_lt[0]
+        bright = self.panel.point_rb[0]
+        lleft = self.point_lt[0]
+        lright = self.point_rb[0]
+
+        off = 0
+        # is left overextending
+        if lleft < bleft:
+            off = lleft - bleft
         
+        # is right overextending
+        elif lright > bright:
+            off = lright - bright
+
+        uv_factor = abs(off / self.width)
+
+        verts = self.get_verts()
+        uv_coords = self.get_tex_coords()
+
         if self.mute:
             self.mute_border.draw()
         if select:
             self.select_border.draw()
 
+        lightIconShader.bind()
         bgl.glActiveTexture(bgl.GL_TEXTURE0)
         bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
-        shader2Dtexture.uniform_int("image", 0)
-
-        batch_for_shader(
-            shader2Dtexture, 'TRI_STRIP',
-            {
-                "pos": self.get_verts(),
-                "texCoord": self.get_tex_coords(),
-            }
-        ).draw(shader2Dtexture)
+        lightIconShader.uniform_int("image", 0)
+
+        # material properties
+        bls_node = self._bls_mesh.active_material.node_tree.nodes['Group']
+        intensity = bls_node.inputs['Intensity'].default_value
+
+        texture_switch = bls_node.inputs['Texture Switch'].default_value
+        color_overlay = bls_node.inputs['Color Overlay'].default_value
+        color_saturation = bls_node.inputs['Color Saturation'].default_value
+
+        lightIconShader.uniform_float("intensity", intensity)
+        lightIconShader.uniform_float("texture_switch", texture_switch)
+        lightIconShader.uniform_float("color_overlay", color_overlay)
+        lightIconShader.uniform_float("color_saturation", color_saturation)
+
+        bgl.glEnable(bgl.GL_BLEND);
+        if off < 0:
+            verts2 = deepcopy(verts)
+            verts[0][0] -= off
+            verts[1][0] = verts[0][0]
+
+            verts2[0][0] = verts2[1][0] = self.panel.point_rb[0] + off
+            verts2[2][0] = verts2[3][0] = self.panel.point_rb[0]
+
+            uv_coords2 = deepcopy(uv_coords)
+            uv_coords[0][0] = uv_coords[1][0] = uv_factor
+            uv_coords2[2][0] = uv_coords2[3][0] = uv_factor
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts,
+                    "texCoord": uv_coords,
+                }
+            ).draw(lightIconShader)
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts2,
+                    "texCoord": uv_coords2,
+                }
+            ).draw(lightIconShader)
+        elif off > 0:
+            verts2 = deepcopy(verts)
+            verts[2][0] -= off
+            verts[3][0] = verts[2][0]
+
+            verts2[0][0] = verts2[1][0] = self.panel.point_lt[0]
+            verts2[2][0] = verts2[3][0] = self.panel.point_lt[0] + off
+
+            uv_coords2 = deepcopy(uv_coords)
+            uv_coords[2][0] = uv_coords[3][0] = 1-uv_factor
+            uv_coords2[0][0] = uv_coords2[1][0] = 1-uv_factor
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts,
+                    "texCoord": uv_coords,
+                }
+            ).draw(lightIconShader)
+
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts2,
+                    "texCoord": uv_coords2,
+                }
+            ).draw(lightIconShader)
+        else:
+            batch_for_shader(
+                lightIconShader, 'TRI_STRIP',
+                {
+                    "pos": verts,
+                    "texCoord": self.get_tex_coords(),
+                }
+            ).draw(lightIconShader)
+        bgl.glDisable(bgl.GL_BLEND);
 
     def update_visual_location(self):
         self.loc = self.panel_loc_to_area_px_lt() + Vector((self.width/2, self.height/2))
@@ -469,7 +816,7 @@ class MouseWidget:
     def _unregister_handler(self):
         try:
             bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
-        except ValueError:
+        except (ValueError, AttributeError):
             pass
     
     def length(self):

commit 653f51939905a72e07ac446e48b142a788aa98b5
Author: Amin Persia <leomoon@gmail.com>
Date:   Sun Jan 19 23:08:58 2020 -0800

    beta branch readme change

diff --git a/README.md b/README.md
index 35afb44..e6a1bdb 100644
--- a/README.md
+++ b/README.md
@@ -43,9 +43,9 @@ Why not use the other background HDR light plugins? It's simple. Template based
 
 However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
 
-Why Are You Selling This "Free" Plugin?
+## Why Are You Selling This "Free" Plugin?
 Me and some generous donors, we've been funding LightStudio so far. This plugin is getting harder to develop and we need your help.
 
-If you think this plugin speeds up your workflow, consider funding the development of it by purchasing this plugin.
+If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
 
 Thank you.
\ No newline at end of file

commit e8aeacdb6877246c8927b99c61f39af0b7d2c25a
Author: Amin Persia <leomoon@gmail.com>
Date:   Sun Jan 19 23:08:34 2020 -0800

    master readme change

diff --git a/README.md b/README.md
index 35afb44..e6a1bdb 100644
--- a/README.md
+++ b/README.md
@@ -43,9 +43,9 @@ Why not use the other background HDR light plugins? It's simple. Template based
 
 However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
 
-Why Are You Selling This "Free" Plugin?
+## Why Are You Selling This "Free" Plugin?
 Me and some generous donors, we've been funding LightStudio so far. This plugin is getting harder to develop and we need your help.
 
-If you think this plugin speeds up your workflow, consider funding the development of it by purchasing this plugin.
+If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
 
 Thank you.
\ No newline at end of file

commit 5bded98b1620afa0cbad6c52537afefa6bef8ede
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 17 23:58:22 2020 -0800

    readme change

diff --git a/README.md b/README.md
index 71c5f11..35afb44 100644
--- a/README.md
+++ b/README.md
@@ -48,10 +48,4 @@ Me and some generous donors, we've been funding LightStudio so far. This plugin
 
 If you think this plugin speeds up your workflow, consider funding the development of it by purchasing this plugin.
 
-Thank you.
-
-## Known Bugs and Upcoming Changes
-* There's an error when Blender 2.8x opens but the plugin is still functional
-* When deleting Light STudio, it will show an error
-* Animating lights will be added soon
-* LightStudio menu is not ordered correctly in 2.8x
\ No newline at end of file
+Thank you.
\ No newline at end of file

commit 689e92fddafa7d8908149ace96259bf909de74c6
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 17 23:56:04 2020 -0800

    readme change

diff --git a/README.md b/README.md
index 71c5f11..35afb44 100644
--- a/README.md
+++ b/README.md
@@ -48,10 +48,4 @@ Me and some generous donors, we've been funding LightStudio so far. This plugin
 
 If you think this plugin speeds up your workflow, consider funding the development of it by purchasing this plugin.
 
-Thank you.
-
-## Known Bugs and Upcoming Changes
-* There's an error when Blender 2.8x opens but the plugin is still functional
-* When deleting Light STudio, it will show an error
-* Animating lights will be added soon
-* LightStudio menu is not ordered correctly in 2.8x
\ No newline at end of file
+Thank you.
\ No newline at end of file

commit 30c6457c11843c4e9a0a9d5807e42aacdaa528e0
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 17 23:42:25 2020 -0800

    more readme changes

diff --git a/README.md b/README.md
index 095caff..71c5f11 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,57 @@
-# LeoMoon LightStudio plugin for Blender
-## More Info / Download
-https://leomoon.com/downloads/plugins/leomoon-lightstudio/
+# LeoMoon LightStudio
+## Important Notice
+LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)**. You can **[download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)** and use it without any limitations. The purpose of this product page is to raise funds to fix the bugs, improve the user interface and add new features.
+
+## Development Fund
+If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
+
+**This plugin is currently in beta for Blender 2.8x. You might encounter bugs.**
+
+## Introduction
+[![LeoMoon LightStudio 2.4.1 Beta Demo](https://img.youtube.com/vi/jwirtdK7cpQ/sddefault.jpg)](https://www.youtube.com/watch?v=jwirtdK7cpQ)
+
+LeoMoon LightStudio is the easiest, fastest and most advanced lighting system for Blender 2.8x.
+
+With Blender 2.8x we had to add a new OpenGL based LightPanel which makes the development much harder. We are now trying to add light previews.
+
+LeoMoon LightStudio is packed with features and the new Light Node has so many options so you can customize each light exactly the way you want.
+
+Video below shows the options that are available per light.
+
+[![New Light Node](https://img.youtube.com/vi/bKVe2n2tGvs/sddefault.jpg)](https://www.youtube.com/watch?v=bKVe2n2tGvs)
+
+## Features
+* Add/Remove lights around objects
+* Add multiple light profiles
+* Each light has many options to customize
+* Easily switch between light profiles with a single click
+* All options per light can be animated
+* Each light can have different light texture
+* Fastest render update while lighting
+* Realistic HDR light textures included
+* Easy 2D manipulation of light in the LightPanel which translates to 3D positioning of that light
+* Toggle light by double clicking on it in the LightPanel
+* Isolate light by right clicking on it in the LightPanel
+* Lights can be added to different renders layers
+* Import/Export light profiles
+
+## Limitations
+LeoMoon LightStudio uses mesh lights and currently, EEVEE does not support mesh lights in real-time. Rendering is only supported in Cycles.
+
+## Background HDR vs Manual Lighting
+Why not use the other background HDR light plugins? It's simple. Template based light plugins are for noobs! They are predictable and limited. For product renders, you want lots of options and control, NOT templates!
+
+However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
+
+Why Are You Selling This "Free" Plugin?
+Me and some generous donors, we've been funding LightStudio so far. This plugin is getting harder to develop and we need your help.
+
+If you think this plugin speeds up your workflow, consider funding the development of it by purchasing this plugin.
+
+Thank you.
+
+## Known Bugs and Upcoming Changes
+* There's an error when Blender 2.8x opens but the plugin is still functional
+* When deleting Light STudio, it will show an error
+* Animating lights will be added soon
+* LightStudio menu is not ordered correctly in 2.8x
\ No newline at end of file

commit 70c7461d325c0320e12ffe945522ed676f611712
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 17 23:41:49 2020 -0800

    more readme change

diff --git a/README.md b/README.md
index 7367681..71c5f11 100644
--- a/README.md
+++ b/README.md
@@ -1,9 +1,9 @@
 # LeoMoon LightStudio
 ## Important Notice
-LeoMoon LightStudio (formerly known as Blender Light Studio) is [100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/). You can [download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/) and use it without any limitations. The purpose of this product page is to raise funds to fix the bugs, improve the user interface and add new features.
+LeoMoon LightStudio (formerly known as Blender Light Studio) is **[100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)**. You can **[download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/)** and use it without any limitations. The purpose of this product page is to raise funds to fix the bugs, improve the user interface and add new features.
 
 ## Development Fund
-If you think this plugin speeds up your workflow, consider funding the development of it by [purchasing it here](https://blendermarket.com/products/leomoon-lightstudio).
+If you think this plugin speeds up your workflow, consider funding the development of it by **[purchasing it here](https://blendermarket.com/products/leomoon-lightstudio)**.
 
 **This plugin is currently in beta for Blender 2.8x. You might encounter bugs.**
 

commit d6af4d1ce78b8a4a8a93417f9a88f40ffacbbe6f
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 17 23:40:04 2020 -0800

    readme update with more info

diff --git a/README.md b/README.md
index 095caff..7367681 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,57 @@
-# LeoMoon LightStudio plugin for Blender
-## More Info / Download
-https://leomoon.com/downloads/plugins/leomoon-lightstudio/
+# LeoMoon LightStudio
+## Important Notice
+LeoMoon LightStudio (formerly known as Blender Light Studio) is [100% free and open-source](https://leomoon.com/downloads/plugins/leomoon-lightstudio/). You can [download](https://leomoon.com/downloads/plugins/leomoon-lightstudio/) and use it without any limitations. The purpose of this product page is to raise funds to fix the bugs, improve the user interface and add new features.
+
+## Development Fund
+If you think this plugin speeds up your workflow, consider funding the development of it by [purchasing it here](https://blendermarket.com/products/leomoon-lightstudio).
+
+**This plugin is currently in beta for Blender 2.8x. You might encounter bugs.**
+
+## Introduction
+[![LeoMoon LightStudio 2.4.1 Beta Demo](https://img.youtube.com/vi/jwirtdK7cpQ/sddefault.jpg)](https://www.youtube.com/watch?v=jwirtdK7cpQ)
+
+LeoMoon LightStudio is the easiest, fastest and most advanced lighting system for Blender 2.8x.
+
+With Blender 2.8x we had to add a new OpenGL based LightPanel which makes the development much harder. We are now trying to add light previews.
+
+LeoMoon LightStudio is packed with features and the new Light Node has so many options so you can customize each light exactly the way you want.
+
+Video below shows the options that are available per light.
+
+[![New Light Node](https://img.youtube.com/vi/bKVe2n2tGvs/sddefault.jpg)](https://www.youtube.com/watch?v=bKVe2n2tGvs)
+
+## Features
+* Add/Remove lights around objects
+* Add multiple light profiles
+* Each light has many options to customize
+* Easily switch between light profiles with a single click
+* All options per light can be animated
+* Each light can have different light texture
+* Fastest render update while lighting
+* Realistic HDR light textures included
+* Easy 2D manipulation of light in the LightPanel which translates to 3D positioning of that light
+* Toggle light by double clicking on it in the LightPanel
+* Isolate light by right clicking on it in the LightPanel
+* Lights can be added to different renders layers
+* Import/Export light profiles
+
+## Limitations
+LeoMoon LightStudio uses mesh lights and currently, EEVEE does not support mesh lights in real-time. Rendering is only supported in Cycles.
+
+## Background HDR vs Manual Lighting
+Why not use the other background HDR light plugins? It's simple. Template based light plugins are for noobs! They are predictable and limited. For product renders, you want lots of options and control, NOT templates!
+
+However you can create your own light profiles in LeoMoon LightStudio and import/export light profiles in different projects.
+
+Why Are You Selling This "Free" Plugin?
+Me and some generous donors, we've been funding LightStudio so far. This plugin is getting harder to develop and we need your help.
+
+If you think this plugin speeds up your workflow, consider funding the development of it by purchasing this plugin.
+
+Thank you.
+
+## Known Bugs and Upcoming Changes
+* There's an error when Blender 2.8x opens but the plugin is still functional
+* When deleting Light STudio, it will show an error
+* Animating lights will be added soon
+* LightStudio menu is not ordered correctly in 2.8x
\ No newline at end of file

commit 50d1ea86f7a834aa470c1f3749bcc6a64ba3df08
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 17 22:40:04 2020 -0800

    readme chage

diff --git a/README.md b/README.md
index ec3af2a..095caff 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,3 @@
-# leomoon-lightstudio
+# LeoMoon LightStudio plugin for Blender
+## More Info / Download
+https://leomoon.com/downloads/plugins/leomoon-lightstudio/

commit b5bad24c8584a6f10ea0c4bb4138f88c5491315b
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 17 21:58:15 2020 -0800

    2.4.1 beta

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..894a44c
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,104 @@
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+wheels/
+*.egg-info/
+.installed.cfg
+*.egg
+MANIFEST
+
+# PyInstaller
+#  Usually these files are written by a python script from a template
+#  before PyInstaller builds the exe, so as to inject date/other infos into it.
+*.manifest
+*.spec
+
+# Installer logs
+pip-log.txt
+pip-delete-this-directory.txt
+
+# Unit test / coverage reports
+htmlcov/
+.tox/
+.coverage
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*.cover
+.hypothesis/
+.pytest_cache/
+
+# Translations
+*.mo
+*.pot
+
+# Django stuff:
+*.log
+local_settings.py
+db.sqlite3
+
+# Flask stuff:
+instance/
+.webassets-cache
+
+# Scrapy stuff:
+.scrapy
+
+# Sphinx documentation
+docs/_build/
+
+# PyBuilder
+target/
+
+# Jupyter Notebook
+.ipynb_checkpoints
+
+# pyenv
+.python-version
+
+# celery beat schedule file
+celerybeat-schedule
+
+# SageMath parsed files
+*.sage.py
+
+# Environments
+.env
+.venv
+env/
+venv/
+ENV/
+env.bak/
+venv.bak/
+
+# Spyder project settings
+.spyderproject
+.spyproject
+
+# Rope project settings
+.ropeproject
+
+# mkdocs documentation
+/site
+
+# mypy
+.mypy_cache/
diff --git a/GUI b/GUI
index 98404f0..7833878 100644
--- a/GUI
+++ b/GUI
@@ -1,45 +1,71 @@
+* BUTTON ICONS GUIDE:
+	[+] = Add light (icon: ADD)
+	[-] = Delete light (icon: REMOVE)
+	[L] = Lock light (icon: UNLOCKED, LOCKED)
+	[V] = Show/hide light (icon: HIDE_OFF, HIDE_ON)
+	[S] = Solo selected light (icon: SOLO_OFF, SOLO_ON)
+	[C] = Copy menu (icon: DUPLICATE)
+
+New scene that doesn't have LightStudio:
  Studio
-    [Delete Studio]
-    [Prepare Layout]
+	[            Create LightStudio             ]
 
- Profiles
-    ------------------------- [+]
-    | Profile 1               | [-]
-    |                         | [c]
-    |                         |
-    |                         | []
-    |                         | []
-    -------------------------
 
+After adding LightStudio:
+ Studio
+	[            Delete LightStudio             ]
+	[          Show LightStudio Panel           ]
  Lights
-    [Add Light]      [Delete Light]
-
- Selected Light
-    [3D Edit]
-    -----------------------------
-    |                             |
-    |                             |
-    |                             |
-    |                             |
-    |                             |
-    | Soft Box A                  |
-    -----------------------------
-    [ ] Mute Light
-    Color:                [       ]
-    -----------------------------
-    |  Intensity:        2.000  |
-    |  Opacity:          1.000  |
-    |  Falloff:          1.000  |
-    |  Color Saturation: 0.300  |
-    |  Half:             0.000  |
-    |  Light Distance:  30.000  |
-    -----------------------------
-
- Visibility Options
-    [Show Only This Light]
-    [Show All Lights]
-
- Import / Export
-    [Export Selected Profile]
-    [Export All Profiles]
-    [Import Profile]
\ No newline at end of file
+    --------------------------------------- [+]
+    | Light 1                      [L][V][S]| [-]
+    | Light 2                      [L][V][S]| [c]
+    |                                       |
+    |                                       | []
+    |                                       | []
+    ---------------------------------------
+    [                  3D Edit                  ]
+    -------------------------------------------
+    |              -------------              |
+    |              |             |              |
+	|              |             |              |
+	|              |             |              |
+    |              |             |              |
+    |              |             |              |
+    |              -------------              |
+    | Soft Box A                                |
+	|  Texture Switch                  1.000  |
+    -------------------------------------------
+    Color Overlay:                      [       ]
+    -------------------------------------------
+	|  Color Saturation:               0.300  |
+    |  Intensity:                      2.000  |
+    |  Mask - Gradient Switch:         0.000  |
+    |  Mask - Gradient Type:           0.000  |
+    |  Mask - Gradient Amount:         0.000  |
+    |  Mask - Ring Switch:             0.000  |
+    |  Mask - Ring Inner Radius:       0.000  |
+    |  Mask - Ring Outer Radius:       0.000  |
+    |  Mask - Top to Bottom:           0.000  |
+    |  Mask - Bottom to Top:           0.000  |
+    |  Mask - Left to Right:           0.000  |
+    |  Mask - Right to Left:           0.000  |
+    |  Mask - Diagonal Top Left:       0.000  |
+    |  Mask - Diagonal Top Right:      0.000  |
+    |  Mask - Diagonal Bottom Right:   0.000  |
+    |  Mask - Diagonal Bottom Left:    0.000  |
+    |  Location:                      30.000  |
+    -------------------------------------------
+ Light Profiles
+    --------------------------------------- [+]
+    | Profile 1                             | [-]
+    |                                       | [C]
+    |                                       |
+    |                                       | []
+    |                                       | []
+    ---------------------------------------
+ Import/Export
+	[          Export Selected Profile          ]
+	[            Export All Profiles            ]
+	[              Import Profiles              ]
+ Misc
+	[            Find Missing Textures          ]
\ No newline at end of file
diff --git a/LICENSE b/LICENSE
index f015d11..3877ae0 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,7 +1,7 @@
                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
@@ -631,8 +631,8 @@ to attach them to the start of each source file to most effectively
 state the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.
 
-    {one line to give the program's name and a brief idea of what it does.}
-    Copyright (C) {year}  {name of author}
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
 
     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -645,14 +645,14 @@ the "copyright" line and a pointer to where the full notice is found.
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 Also add information on how to contact you by electronic and paper mail.
 
   If the program does terminal interaction, make it output a short
 notice like this when it starts in an interactive mode:
 
-    {project}  Copyright (C) {year}  {fullname}
+    <program>  Copyright (C) <year>  <name of author>
     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.
@@ -664,12 +664,11 @@ might be different; for a GUI interface, you would use an "about box".
   You should also get your employer (if you work as a programmer) or school,
 if any, to sign a "copyright disclaimer" for the program, if necessary.
 For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
+<https://www.gnu.org/licenses/>.
 
   The GNU General Public License does not permit incorporating your program
 into proprietary programs.  If your program is a subroutine library, you
 may consider it more useful to permit linking proprietary applications with
 the library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
-
+<https://www.gnu.org/licenses/why-not-lgpl.html>.
diff --git a/README.md b/README.md
index 095caff..ec3af2a 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1 @@
-# LeoMoon LightStudio plugin for Blender
-## More Info / Download
-https://leomoon.com/downloads/plugins/leomoon-lightstudio/
+# leomoon-lightstudio
diff --git a/src/BLS.blend b/src/BLS.blend
deleted file mode 100644
index 68fa33d..0000000
Binary files a/src/BLS.blend and /dev/null differ
diff --git a/src/BLS3.blend b/src/BLS3.blend
new file mode 100644
index 0000000..d6ed6aa
Binary files /dev/null and b/src/BLS3.blend differ
diff --git a/src/__init__.py b/src/__init__.py
index a0d5356..25b5a80 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -4,8 +4,8 @@ bl_info = {
     "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios",
-    "version": (2, 3, 11),
-    "blender": (2, 79, 0),
+    "version": (2, 4, 0),
+    "blender": (2, 80, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
     "category": "User Interface" }
@@ -15,47 +15,28 @@ import bpy
 
 # load and reload submodules
 ##################################    
-    
-from . import developer_utils
-modules = developer_utils.setup_addon_modules(__path__, __name__, "bpy" in locals())
 
+from . import auto_load
+
+auto_load.init()
 
 
 # register
 ################################## 
 
-import traceback
-
-from . light_operators import Blender_Light_Studio_Properties, update_selection_override
+from . light_operators import Blender_Light_Studio_Properties
 from . import deleteOperator
-from . import selectOperator
 from . import light_preview_list
 
-def config_load():
-    from extensions_framework import util as efutil
-    bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
-    bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)
-    
-    update_selection_override()
-    
 def register():
-    try: bpy.utils.register_module(__name__)
-    except: traceback.print_exc()
+    auto_load.register()
+
     bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
     bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
     deleteOperator.add_shortkeys()
-    config_load() # select operator shortkeys
     light_preview_list.register()
     
-    
-    print("Registered {} with {} modules".format(bl_info["name"], len(modules)))
-    
 
 def unregister():
-    selectOperator.remove_shortkeys()
     deleteOperator.remove_shortkeys()
-    try: bpy.utils.unregister_module(__name__)
-    except: traceback.print_exc()
-    
-    print("Unregistered {}".format(bl_info["name"]))
-    
+    auto_load.unregister()
diff --git a/src/auto_load.py b/src/auto_load.py
new file mode 100644
index 0000000..f369928
--- /dev/null
+++ b/src/auto_load.py
@@ -0,0 +1,184 @@
+import os
+import bpy
+import sys
+import typing
+import inspect
+import pkgutil
+import importlib
+from pathlib import Path
+
+__all__ = (
+    "init",
+    "register",
+    "unregister",
+)
+
+modules = None
+ordered_classes = None
+ignored=[]
+auto_annotations = False
+def init(ignore=[], make_annotations=False):
+    global modules
+    global ordered_classes
+    global ignored    
+    global fifo_cls
+    global auto_annotations
+
+    ignored = ignore
+    modules = get_all_submodules(Path(__file__).parent)
+    ordered_classes = get_ordered_classes_to_register(modules)
+    auto_annotations = make_annotations
+
+def register():
+    for cls in fifo_cls:
+        if auto_annotations:
+            make_annotations(cls)
+        bpy.utils.register_class(cls)
+
+    for cls in ordered_classes:
+        if cls not in fifo_cls:
+            if auto_annotations:
+                make_annotations(cls)
+            bpy.utils.register_class(cls)
+
+    for module in modules:
+        if module.__name__ == __name__:
+            continue
+        if hasattr(module, "register"):
+            module.register()
+
+def unregister():
+    for cls in reversed(ordered_classes):
+        bpy.utils.unregister_class(cls)
+
+    for cls in reversed(fifo_cls):
+        if cls not in ordered_classes:
+            bpy.utils.unregister_class(cls)
+
+    for module in modules:
+        if module.__name__ == __name__:
+            continue
+        if hasattr(module, "unregister"):
+            module.unregister()
+
+
+# Import modules
+#################################################
+
+def get_all_submodules(directory):
+    return list(iter_submodules(directory, directory.name))
+
+def iter_submodules(path, package_name):
+    global ignored
+    for name in sorted(iter_submodule_names(path)):
+        if name in ignored:#("addon_updater", "addon_updater_ops"):
+            continue
+        yield importlib.import_module("." + name, package_name)
+
+def iter_submodule_names(path, root=""):
+    for _, module_name, is_package in pkgutil.iter_modules([str(path)]):
+        if is_package:
+            sub_path = path / module_name
+            sub_root = root + module_name + "."
+            yield from iter_submodule_names(sub_path, sub_root)
+            yield root + module_name
+        else:
+            yield root + module_name
+
+
+# Find classes to register
+#################################################
+
+def get_ordered_classes_to_register(modules):
+    return toposort(get_register_deps_dict(modules))
+
+def get_register_deps_dict(modules):
+    deps_dict = {}
+    classes_to_register = set(iter_classes_to_register(modules))
+    for cls in classes_to_register:
+        deps_dict[cls] = set(iter_own_register_deps(cls, classes_to_register))
+    return deps_dict
+
+def iter_own_register_deps(cls, own_classes):
+    yield from (dep for dep in iter_register_deps(cls) if dep in own_classes)
+
+def iter_register_deps(cls):
+    for value in typing.get_type_hints(cls, {}, {}).values():
+        dependency = get_dependency_from_annotation(value)
+        if dependency is not None:
+            yield dependency
+
+def get_dependency_from_annotation(value):
+    if isinstance(value, tuple) and len(value) == 2:
+        if value[0] in (bpy.props.PointerProperty, bpy.props.CollectionProperty):
+            return value[1]["type"]
+    return None
+
+def iter_classes_to_register(modules):
+    base_types = get_register_base_types()
+    for cls in get_classes_in_modules(modules):
+        if any(base in base_types for base in cls.__bases__):
+            if not getattr(cls, "is_registered", False):
+                yield cls
+
+def get_classes_in_modules(modules):
+    classes = set()
+    for module in modules:
+        for cls in iter_classes_in_module(module):
+            classes.add(cls)
+    return classes
+
+def iter_classes_in_module(module):
+    for value in module.__dict__.values():
+        if inspect.isclass(value):
+            yield value
+
+def get_register_base_types():
+    return set(getattr(bpy.types, name) for name in [
+        "Panel", "Operator", "PropertyGroup",
+        "AddonPreferences", "Header", "Menu",
+        "Node", "NodeSocket", "NodeTree",
+        "UIList", "RenderEngine"
+    ])
+
+
+# Find order to register to solve dependencies
+#################################################
+
+def toposort(deps_dict):
+    sorted_list = []
+    sorted_values = set()
+    while len(deps_dict) > 0:
+        unsorted = []
+        for value, deps in deps_dict.items():
+            if len(deps) == 0:
+                sorted_list.append(value)
+                sorted_values.add(value)
+            else:
+                unsorted.append(value)
+        deps_dict = {value : deps_dict[value] - sorted_values for value in unsorted}
+    return sorted_list
+
+
+# Force register classes at FIFO order (decorator).
+#################################################
+# Use for ordering in nesting cases
+fifo_cls = []
+def force_register(cls):
+    global fifo_cls
+    fifo_cls.append(cls)
+    return cls
+
+def make_annotations(cls):
+    """Converts class fields to annotations if running with Blender 2.8"""
+    if bpy.app.version < (2, 80):
+        return cls
+    bl_props = {k: v for k, v in cls.__dict__.items() if isinstance(v, tuple)}
+    if bl_props:
+        if '__annotations__' not in cls.__dict__:
+            setattr(cls, '__annotations__', {})
+        annotations = cls.__dict__['__annotations__']
+        for k, v in bl_props.items():
+            annotations[k] = v
+            delattr(cls, k)
+    return cls
\ No newline at end of file
diff --git a/src/common.py b/src/common.py
index d203267..67c38d9 100644
--- a/src/common.py
+++ b/src/common.py
@@ -1,3 +1,47 @@
+import bpy
+
+def replace_link(object, collection_name):
+    if isinstance(object, bpy.types.Collection):
+        bpy.context.scene.collection.children.unlink(bpy.context.scene.collection.children[object.name])
+        bpy.data.collections[collection_name].children.link(object)
+    else:
+        object.users_collection[0].objects.unlink(object)
+        bpy.data.collections[collection_name].objects.link(object)
+
+def get_collection(object):
+    return [c for c in object.users_collection if c.name.startswith('BLS')][0]
+
+def get_bls_collection(context):
+    return [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+
+def blscol_profilecol_profile_handle(context):
+    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
+    profile = [ob for ob in profile_collection.objects if ob.name.startswith('BLS_PROFILE')][0]
+    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
+    return bls_collection, profile_collection, profile, handle
+
+def blscol_profilecol(context):
+    bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+    profile_collection = [c for c in bls_collection.children if c.name.startswith('BLS_PROFILE')][0]
+    return bls_collection, profile_collection
+
+def find_view_layer(collection, layer_collection):
+    idx = layer_collection.children.find(collection.name)
+    if idx >= 0:
+        return layer_collection.children[idx]
+    else:
+        for vc in layer_collection.children:
+            rcol = find_view_layer(collection, layer_collection=vc)
+            if rcol:
+                return rcol
+            
+def get_view_layers(layer_collection):
+    for lc in layer_collection.children:
+        yield lc
+        for clc in get_view_layers(layer_collection=lc):
+            yield clc
+            
 def isFamily(ob=None):
     if not ob:
         ob = bpy.context.scene.objects.active
@@ -25,9 +69,9 @@ def family(object):
     return family.pop()
 
 def findLightGrp(ob):
-    while ob.parent:
+    while ob and ob.parent:
         ob = ob.parent
-        if ob.name.startswith('BLS_LIGHT_GRP.'): return ob
+        if ob.name.startswith('BLS_LIGHT.'): return ob
     return None
 
 def getLightMesh():
@@ -36,12 +80,12 @@ def getLightMesh():
     #light_no = lightGrp.name.split('.')[1]
     #return obs[obs.find('BLS_LIGHT_MESH.'+light_no)]
 
-    lg = findLightGrp(bpy.context.scene.objects.active)
+    lg = findLightGrp(bpy.context.active_object)
     lm = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH")]
     return lm[0] if len(lm) else None
 
 def getLightController():
-    obs = bpy.context.scene.objects
+    obs = bpy.context.view_layer.objects
     lightGrp = obs.active
     light_no = lightGrp.name.split('.')[1]
     return obs[obs.find('BLS_CONTROLLER.'+light_no)]
@@ -71,7 +115,6 @@ def getLightHandle(ob=None):
     else:
         return None
 
-import bpy
 def refreshMaterials():
     #controllers = [ob for ob in family(findLightGrp(context.active_object).parent) if ob.name.startswith('BLS_CONTROLLER.')]
     controllers = (ob for ob in bpy.context.scene.objects if ob.name.startswith('BLS_CONTROLLER.') and isFamily(ob))
diff --git a/src/deleteOperator.py b/src/deleteOperator.py
index 016fec3..f525d96 100644
--- a/src/deleteOperator.py
+++ b/src/deleteOperator.py
@@ -8,7 +8,7 @@ class DeleteOperator(bpy.types.Operator):
     bl_label = "Custom Delete"
     bl_options = {'REGISTER', 'UNDO'}
 
-    use_global = BoolProperty(default = False)
+    use_global: BoolProperty(default = False)
 
     @classmethod
     def poll(cls, context):
@@ -19,7 +19,7 @@ class DeleteOperator(bpy.types.Operator):
         protected_objects = (ob for ob in context.selected_objects if ob.protected)
         
         for obj in protected_objects:
-            context.scene.objects.active = obj
+            context.view_layer.objects.active = obj
             if hasattr(obj, 'use_fake_user'):
                 obj.use_fake_user = False
             ret = bpy.ops.scene.delete_blender_studio_light()
@@ -30,9 +30,9 @@ class DeleteOperator(bpy.types.Operator):
 
         return {'FINISHED'}
 
-    def invoke(self, context, event):
-        wm = context.window_manager
-        return wm.invoke_confirm(self, event)
+    # def invoke(self, context, event):
+    #     wm = context.window_manager
+    #     return wm.invoke_confirm(self, event)
         
 addon_keymaps = []
 def add_shortkeys():       
diff --git a/src/developer_utils.py b/src/developer_utils.py
deleted file mode 100644
index f4c4535..0000000
--- a/src/developer_utils.py
+++ /dev/null
@@ -1,38 +0,0 @@
-import os
-import sys
-import pkgutil
-import importlib
-
-def setup_addon_modules(path, package_name, reload):
-    """
-    Imports and reloads all modules in this addon. 
-    
-    path -- __path__ from __init__.py
-    package_name -- __name__ from __init__.py
-    """
-    def get_submodule_names(path = path[0], root = ""):
-        module_names = []
-        for importer, module_name, is_package in pkgutil.iter_modules([path]):
-            if is_package:
-                sub_path = os.path.join(path, module_name)
-                sub_root = root + module_name + "."
-                module_names.extend(get_submodule_names(sub_path, sub_root))
-            else: 
-                module_names.append(root + module_name)
-        return module_names 
-
-    def import_submodules(names):
-        modules = []
-        for name in names:
-            modules.append(importlib.import_module("." + name, package_name))
-        return modules
-        
-    def reload_modules(modules):
-        for module in modules:
-            importlib.reload(module)
-    
-    names = get_submodule_names()
-    modules = import_submodules(names)        
-    if reload: 
-        reload_modules(modules) 
-    return modules
diff --git a/src/extensions_framework/util.py b/src/extensions_framework/util.py
new file mode 100644
index 0000000..2ad450b
--- /dev/null
+++ b/src/extensions_framework/util.py
@@ -0,0 +1,270 @@
+# -*- coding: utf-8 -*-
+#
+# ***** BEGIN GPL LICENSE BLOCK *****
+#
+# --------------------------------------------------------------------------
+# Blender 2.5 Extensions Framework
+# --------------------------------------------------------------------------
+#
+# Authors:
+# Doug Hammond
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License
+# as published by the Free Software Foundation; either version 2
+# of the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#
+# ***** END GPL LICENCE BLOCK *****
+#
+import configparser
+import datetime
+import os
+import tempfile
+import threading
+
+import bpy
+
+"""List of possibly appropriate paths to load/save addon config from/to"""
+config_paths = []
+if bpy.utils.user_resource('CONFIG', '') != "": config_paths.append(bpy.utils.user_resource('CONFIG', '', create=True))
+if bpy.utils.user_resource('SCRIPTS', '') != "": config_paths.append(bpy.utils.user_resource('SCRIPTS', '', create=True))
+# want to scan other script paths in reverse order, since the user path comes last
+sp = [p for p in bpy.utils.script_paths() if p != '']
+sp.reverse()
+config_paths.extend(sp)
+
+"""This path is set at the start of export, so that calls to
+path_relative_to_export() can make all exported paths relative to
+this one.
+"""
+export_path = '';
+
+def path_relative_to_export(p):
+    """Return a path that is relative to the export path"""
+    global export_path
+    p = filesystem_path(p)
+    ep = os.path.dirname(export_path)
+
+    if os.sys.platform[:3] == "win":
+        # Prevent an error whereby python thinks C: and c: are different drives
+        if p[1] == ':': p = p[0].lower() + p[1:]
+        if ep[1] == ':': ep = ep[0].lower() + ep[1:]
+
+    try:
+        relp = os.path.relpath(p, ep)
+    except ValueError: # path on different drive on windows
+        relp = p
+
+    return relp.replace('\\', '/')
+
+def filesystem_path(p):
+    """Resolve a relative Blender path to a real filesystem path"""
+    if p.startswith('//'):
+        pout = bpy.path.abspath(p)
+    else:
+        pout = os.path.realpath(p)
+
+    return pout.replace('\\', '/')
+
+# TODO: - somehow specify TYPES to get/set from config
+
+def find_config_value(module, section, key, default):
+    """Attempt to find the configuration value specified by string key
+    in the specified section of module's configuration file. If it is
+    not found, return default.
+
+    """
+    global config_paths
+    fc = []
+    for p in config_paths:
+        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
+            fc.append( '/'.join([p, '%s.cfg' % module]))
+
+    if len(fc) < 1:
+        print('Cannot find %s config file path' % module)
+        return default
+
+    cp = configparser.SafeConfigParser()
+
+    cfg_files = cp.read(fc)
+    if len(cfg_files) > 0:
+        try:
+            val = cp.get(section, key)
+            if val == 'true':
+                return True
+            elif val == 'false':
+                return False
+            else:
+                return val
+        except:
+            return default
+    else:
+        return default
+
+def write_config_value(module, section, key, value):
+    """Attempt to write the configuration value specified by string key
+    in the specified section of module's configuration file.
+
+    """
+    global config_paths
+    fc = []
+    for p in config_paths:
+        if os.path.exists(p) and os.path.isdir(p) and os.access(p, os.W_OK):
+            fc.append( '/'.join([p, '%s.cfg' % module]))
+
+    if len(fc) < 1:
+        raise Exception('Cannot find a writable path to store %s config file' %
+            module)
+
+    cp = configparser.SafeConfigParser()
+
+    cfg_files = cp.read(fc)
+
+    if not cp.has_section(section):
+        cp.add_section(section)
+
+    if value == True:
+        cp.set(section, key, 'true')
+    elif value == False:
+        cp.set(section, key, 'false')
+    else:
+        cp.set(section, key, value)
+
+    if len(cfg_files) < 1:
+        cfg_files = fc
+
+    fh=open(cfg_files[0],'w')
+    cp.write(fh)
+    fh.close()
+
+    return True
+
+def scene_filename():
+    """Construct a safe scene filename, using 'untitled' instead of ''"""
+    filename = os.path.splitext(os.path.basename(bpy.data.filepath))[0]
+    if filename == '':
+        filename = 'untitled'
+    return bpy.path.clean_name(filename)
+
+def temp_directory():
+    """Return the system temp directory"""
+    return tempfile.gettempdir()
+
+def temp_file(ext='tmp'):
+    """Get a temporary filename with the given extension. This function
+    will actually attempt to create the file."""
+    tf, fn = tempfile.mkstemp(suffix='.%s'%ext)
+    os.close(tf)
+    return fn
+
+class TimerThread(threading.Thread):
+    """Periodically call self.kick(). The period of time in seconds
+    between calling is given by self.KICK_PERIOD, and the first call
+    may be delayed by setting self.STARTUP_DELAY, also in seconds.
+    self.kick() will continue to be called at regular intervals until
+    self.stop() is called. Since this is a thread, calling self.join()
+    may be wise after calling self.stop() if self.kick() is performing
+    a task necessary for the continuation of the program.
+    The object that creates this TimerThread may pass into it data
+    needed during self.kick() as a dict LocalStorage in __init__().
+
+    """
+    STARTUP_DELAY = 0
+    KICK_PERIOD = 8
+
+    active = True
+    timer = None
+
+    LocalStorage = None
+
+    def __init__(self, LocalStorage=dict()):
+        threading.Thread.__init__(self)
+        self.LocalStorage = LocalStorage
+
+    def set_kick_period(self, period):
+        """Adjust the KICK_PERIOD between __init__() and start()"""
+        self.KICK_PERIOD = period + self.STARTUP_DELAY
+
+    def stop(self):
+        """Stop this timer. This method does not join()"""
+        self.active = False
+        if self.timer is not None:
+            self.timer.cancel()
+
+    def run(self):
+        """Timed Thread loop"""
+        while self.active:
+            self.timer = threading.Timer(self.KICK_PERIOD, self.kick_caller)
+            self.timer.start()
+            if self.timer.isAlive(): self.timer.join()
+
+    def kick_caller(self):
+        """Intermediary between the kick-wait-loop and kick to allow
+        adjustment of the first KICK_PERIOD by STARTUP_DELAY
+
+        """
+        if self.STARTUP_DELAY > 0:
+            self.KICK_PERIOD -= self.STARTUP_DELAY
+            self.STARTUP_DELAY = 0
+
+        self.kick()
+
+    def kick(self):
+        """Sub-classes do their work here"""
+        pass
+
+def format_elapsed_time(t):
+    """Format a duration in seconds as an HH:MM:SS format time"""
+
+    td = datetime.timedelta(seconds=t)
+    min = td.days*1440  + td.seconds/60.0
+    hrs = td.days*24    + td.seconds/3600.0
+
+    return '%i:%02i:%02i' % (hrs, min%60, td.seconds%60)
+
+def getSequenceTexturePath(it, f):
+    import bpy.path
+    import os.path
+    import string
+    fd = it.image_user.frame_duration
+    fs = it.image_user.frame_start
+    fo = it.image_user.frame_offset
+    cyclic = it.image_user.use_cyclic
+    ext = os.path.splitext(it.image.filepath)[-1]
+    fb = bpy.path.display_name_from_filepath(it.image.filepath)
+    dn = os.path.dirname(it.image.filepath)
+    rf = fb[::-1]
+    nl = 0
+    for i in range (len(fb)):
+        if rf[i] in string.digits:
+            nl += 1
+        else:
+            break
+    head = fb[:len(fb)-nl]
+    fnum = f
+    if fs != 1:
+        if f != fs:
+            fnum -= (fs-1)
+        elif f == fs:
+            fnum = 1
+    if fnum <= 0:
+        if cyclic:
+            fnum = fd - abs(fnum) % fd
+        else:
+            fnum = 1
+    elif fnum > fd:
+        if cyclic:
+            fnum = fnum % fd
+        else:
+            fnum = fd
+    fnum += fo
+    return dn + "/" + head + str(fnum).rjust(nl, "0") + ext
diff --git a/src/gui.py b/src/gui.py
index b109b40..53b32e6 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -2,11 +2,11 @@ import bpy
 import os
 from . common import getLightMesh
 
-class BLS_Studio(bpy.types.Panel):
-    bl_idname = "bls_studio"
+class BLS_PT_Studio(bpy.types.Panel):
+    bl_idname = "BLS_PT_studio"
     bl_label = "Studio"
     bl_space_type = "VIEW_3D"
-    bl_region_type = "TOOLS"
+    bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
@@ -18,13 +18,14 @@ class BLS_Studio(bpy.types.Panel):
         col = layout.column(align=True)
         if not context.scene.BLStudio.initialized: col.operator('scene.create_blender_light_studio')
         if context.scene.BLStudio.initialized: col.operator('scene.delete_blender_light_studio')
-        col.operator('scene.prepare_blender_studio_light')
+        col.separator()
+        col.operator('light_studio.control_panel', icon='MENU_PANEL')
 
-class BLS_ProfileList(bpy.types.Panel):
-    bl_idname = "bls_profile_list"
+class BLS_PT_ProfileList(bpy.types.Panel):
+    bl_idname = "BLS_PT_profile_list"
     bl_label = "Profiles"
     bl_space_type = "VIEW_3D"
-    bl_region_type = "TOOLS"
+    bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
@@ -42,19 +43,19 @@ class BLS_ProfileList(bpy.types.Panel):
         col.template_list("BLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
         
         col = row.column(align=True)
-        col.operator('bls_list.new_profile', icon='ZOOMIN', text="")
-        col.operator('bls_list.delete_profile', icon='ZOOMOUT', text="")
-        col.operator('bls_list.copy_profile_menu', icon='GHOST', text="")
+        col.operator('bls_list.new_profile', icon='PLUS', text="")
+        col.operator('bls_list.delete_profile', icon='TRASH', text="")
+        col.operator('bls_list.copy_profile_menu', icon='DUPLICATE', text="")
         
         col.separator()
         col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
         col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
                 
-class BLS_Lights(bpy.types.Panel):
-    bl_idname = "bls_lights"
+class BLS_PT_Lights(bpy.types.Panel):
+    bl_idname = "BLS_PT_lights"
     bl_label = "Lights"
     bl_space_type = "VIEW_3D"
-    bl_region_type = "TOOLS"
+    bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
@@ -68,11 +69,11 @@ class BLS_Lights(bpy.types.Panel):
         row.operator('scene.add_blender_studio_light', text='Add Light')
         row.operator('scene.delete_blender_studio_light', text='Delete Light')
         
-class BLS_Selected(bpy.types.Panel):
-    bl_idname = "bls_selected"
+class BLS_PT_Selected(bpy.types.Panel):
+    bl_idname = "BLS_PT_selected"
     bl_label = "Selected Light"
     bl_space_type = "VIEW_3D"
-    bl_region_type = "TOOLS"
+    bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
@@ -80,40 +81,38 @@ class BLS_Selected(bpy.types.Panel):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'    
     
     def draw(self, context):
-        if context.scene.objects.active and (context.scene.objects.active.name.startswith('BLS_CONTROLLER') or context.scene.objects.active.name.startswith('BLS_LIGHT_MESH')):
+        if context.active_object and (context.active_object.name.startswith('BLS_CONTROLLER') or context.active_object.name.startswith('BLS_LIGHT_MESH')):
             layout = self.layout
             wm = context.window_manager
             
             col = layout.column(align=True)
-            col.operator('bls.light_brush', text="3D Edit", icon='CURSOR')
+            col.operator('bls.light_brush', text="3D Edit", icon='PIVOT_CURSOR')
             
             box = layout.box()
             col = box.column()
             col.template_icon_view(wm, "bls_tex_previews", show_labels=True)
-            col.label(os.path.splitext(wm.bls_tex_previews)[0])
-            
-            col = layout.column(align=True)
-            col.prop(context.scene.BLStudio, 'light_muted')
+            col.label(text=os.path.splitext(wm.bls_tex_previews)[0])
             
             
             layout.separator()
             try:
                 bls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
-                for input in bls_inputs[1:]:
+                for input in bls_inputs[2:]:
                     if input.type == "RGBA":
-                        layout.prop(input, 'default_value', input.name)
+                        layout.prop(input, 'default_value', text=input.name)
                         col = layout.column(align=True)
                     else:
-                        col.prop(input, 'default_value', input.name)
+                        col.prop(input, 'default_value', text=input.name)
             except:
-                col.label("BLS_light material is not valid.")
+                col.label(text="BLS_light material is not valid.")
+                import traceback
+                traceback.print_exc()
             col.prop(getLightMesh(), 'location', index=0) #light radius
                 
-class BLS_Visibility(bpy.types.Panel):
-    bl_idname = "bls_visibility"
+class BLS_PT_Visibility(bpy.types.Panel):
     bl_label = "Visibility Options"
     bl_space_type = "VIEW_3D"
-    bl_region_type = "TOOLS"
+    bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
@@ -126,11 +125,11 @@ class BLS_Visibility(bpy.types.Panel):
         col.operator('object.mute_other_lights')
         col.operator('object.show_all_lights')
         
-class BLS_ProfileImportExport(bpy.types.Panel):
-    bl_idname = "bls_profile_import_export"
+class BLS_PT_ProfileImportExport(bpy.types.Panel):
+    bl_idname = "BLS_PT_profile_import_export"
     bl_label = "Import/Export"
     bl_space_type = "VIEW_3D"
-    bl_region_type = "TOOLS"
+    bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
@@ -140,22 +139,19 @@ class BLS_ProfileImportExport(bpy.types.Panel):
     def draw(self, context):
         layout = self.layout
         scene = context.scene
-        
-        props = scene.BLStudio
               
         col = layout.column(align=True)
         col.operator('bls_list.export_profiles', text="Export Selected Profile")
         col.operator('bls_list.export_profiles', text="Export All Profiles").all=True
         col.operator('bls_list.import_profiles')
 
-from extensions_framework import util as efutil
 from . import bl_info
 
-class BLS_Misc(bpy.types.Panel):
-    bl_idname = "bls_misc"
+class BLS_PT_Misc(bpy.types.Panel):
+    bl_idname = "BLS_PT_misc"
     bl_label = "Misc"
     bl_space_type = "VIEW_3D"
-    bl_region_type = "TOOLS"
+    bl_region_type = "UI"
     bl_category = "Light Studio"
     
     @classmethod
@@ -170,10 +166,4 @@ class BLS_Misc(bpy.types.Panel):
               
         col = layout.column(align=True)
         col.operator('bls.find_missing_textures')
-        
-        box = layout.box()
-        col = box.column()
-        col.label("Disable in case of problems")
-        col.label("eg. using manipulators")
-        col.prop(props, 'selection_overriden')
         
\ No newline at end of file
diff --git a/src/light_brush.py b/src/light_brush.py
index 5bdb40f..c30180a 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -9,8 +9,6 @@ from . common import isFamily, family, findLightGrp, getLightMesh, getLightContr
 
            
 def raycast(context, event, diff):
-    controller = getLightController()
-    #####
     """Run this function on left mouse, execute the ray cast"""
     # get the context arguments
     scene = context.scene
@@ -34,22 +32,20 @@ def raycast(context, event, diff):
             if obj.type == 'MESH':
                 yield (obj, obj.matrix_world.copy())
 
-            if obj.dupli_type != 'NONE':
-                obj.dupli_list_create(scene)
-                for dob in obj.dupli_list:
-                    obj_dupli = dob.object
+            if obj.instance_type != 'NONE':
+                depsgraph = context.depsgraph
+                for dup in depsgraph.object_instances:
+                    obj_dupli = dup.object
                     if obj_dupli.type == 'MESH':
-                        yield (obj_dupli, dob.matrix.copy())
-
-            obj.dupli_list_clear()
+                        yield (obj_dupli, dup.matrix_world.copy())
 
     def obj_ray_cast(obj, matrix):
         """Wrapper for ray casting that moves the ray into object space"""
 
         # get the ray relative to the object
         matrix_inv = matrix.inverted()
-        ray_origin_obj = matrix_inv * ray_origin
-        ray_target_obj = matrix_inv * ray_target
+        ray_origin_obj = matrix_inv @ ray_origin
+        ray_target_obj = matrix_inv @ ray_target
         ray_direction_obj = ray_target_obj - ray_origin_obj
 
         # cast the ray
@@ -70,7 +66,7 @@ def raycast(context, event, diff):
         if obj.type == 'MESH':
             hit, hit_normal, face_index = obj_ray_cast(obj, matrix)
             if hit is not None:
-                hit_world = matrix * hit
+                hit_world = matrix @ hit
                 length_squared = (hit_world - ray_origin).length_squared
                 if best_obj is None or length_squared < best_length_squared:
                     best_length_squared = length_squared
@@ -85,13 +81,14 @@ def raycast(context, event, diff):
     # convert normal from local space to global
     matrix = best_obj.matrix_world
     matrix_new = matrix.to_3x3().inverted().transposed()
-    normal = matrix_new * normal
+    normal = matrix_new @ normal
     normal.normalize()
     
     #####
-    profile = findLightGrp(controller).parent
+    profile = findLightGrp(context.active_object).parent
     handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
     lightmesh = getLightMesh()
+    actuator = lightmesh.parent
     position = intersect_line_sphere(
         location - handle.location,
         (normal if diff else view_vector.reflect(normal)) + location - handle.location,
@@ -106,14 +103,11 @@ def raycast(context, event, diff):
    
     # ctrl x
     x,y,z = position
-    ctrl_x = (degrees(atan2(-x, y)) % 360) * (4/360) -2 +0.015
+    actuator.rotation_euler.x = atan2(x, -y)
     
     # ctrl y
     deg = copysign(degrees(Vector.angle(Vector((x,y,z)), Vector((x,y,0)))), z)
-    ctrl_y = deg / 90
-    
-    controller.location.x = ctrl_x
-    controller.location.y = ctrl_y
+    actuator.rotation_euler.y = copysign(Vector.angle(Vector((x,y,z)), Vector((x,y,0))), z)
 
 class BLSLightBrush(bpy.types.Operator):
     """Click on object to position light and reflection"""
@@ -121,13 +115,12 @@ class BLSLightBrush(bpy.types.Operator):
     bl_label = "Light Brush"
     bl_options = {"UNDO"}
     
-    pressed = BoolProperty(default=False)
-    aux = BoolProperty(default=False) # is aux operator working
-    diffuse_type = BoolProperty(default=False)
+    aux: BoolProperty(default=False) # is aux operator working
+    diffuse_type: BoolProperty(default=False)
     
     @classmethod
     def poll(cls, context):
-        light = context.scene.objects.active
+        light = context.active_object
         return context.area.type == 'VIEW_3D' and \
                context.mode == 'OBJECT' and \
                context.scene.BLStudio.initialized and \
@@ -136,39 +129,30 @@ class BLSLightBrush(bpy.types.Operator):
                not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
 
     def modal(self, context, event):
-        #print(event.type, event.value)
+        print(event.type, event.value)
         if self.aux:
             if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
                 self.aux = False
             return {'RUNNING_MODAL'}
         
-        context.area.header_text_set("[LM] Select Face,  [ESC/RM] Quit,  [N] %s,  [S] Scale, [G] Grab, [R] Rotate" % ('Reflection | [Normal]' if self.diffuse_type else '[Reflection] | Normal'))
+        context.area.header_text_set(text=f"[LM] Select Face,  [ESC/RM] Quit,  [N] {'Reflection | [Normal]' if self.diffuse_type else '[Reflection] | Normal'}")
         
         if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'Z', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
             # allow navigation
             return {'PASS_THROUGH'}
         elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
-            context.area.header_text_set()
+            context.area.header_text_set(text=None)
             return {'FINISHED'}
         elif event.type == 'LEFTMOUSE':
             if event.value == 'PRESS':
-                self.pressed = True
                 raycast(context, event, self.diffuse_type)
+                return {'RUNNING_MODAL'}
             elif event.value == 'RELEASE':
-                self.pressed = False
-            return {'RUNNING_MODAL'}
-        elif self.pressed and event.type == 'MOUSEMOVE':
-            raycast(context, event, self.diffuse_type)
-            return {'RUNNING_MODAL'}
-        elif event.type == 'S':
-            self.aux = True
-            bpy.ops.bls.resize_light('INVOKE_DEFAULT')
-        elif event.type == 'G':
-            self.aux = True
-            bpy.ops.bls.move_light('INVOKE_DEFAULT')
-        elif event.type == 'R':
-            self.aux = True
-            bpy.ops.bls.rotate_light('INVOKE_DEFAULT')
+                return {'PASS_THROUGH'}
+        elif event.type == 'MOUSEMOVE':
+            if event.value == 'PRESS':
+                raycast(context, event, self.diffuse_type)
+                return {'PASS_THROUGH'}
         elif event.type == 'N' and event.value == 'PRESS':
             self.diffuse_type = not self.diffuse_type
 
@@ -179,365 +163,6 @@ class BLSLightBrush(bpy.types.Operator):
         if context.space_data.type == 'VIEW_3D':
             context.window_manager.modal_handler_add(self)
             return {'RUNNING_MODAL'}
-        else:
-            self.report({'WARNING'}, "Active space must be a View3d")
-            return {'CANCELLED'}
-
-
-########################################## Modal AUX Operators ##########################################
-from bpy_extras.view3d_utils import location_3d_to_region_2d as loc3d2d
-import bgl
-def draw_callback_px(self, context): 
-    region = context.region  
-    rv3d = context.space_data.region_3d
-            
-    init2d = self.obLoc[:2]
-    dest2d = self.mouseCoNew[:2]
-
-    # Line drawing
-    bgl.glPushAttrib(bgl.GL_ENABLE_BIT)
-    # glPushAttrib is done to return everything to normal after drawing
-    
-    bgl.glLineStipple(2, 0x9999)
-    bgl.glEnable(bgl.GL_LINE_STIPPLE)
-    
-    bgl.glEnable(bgl.GL_BLEND)
-    bgl.glColor4f(0.0, 0.0, 0.0, 1)
-    #bgl.glLineWidth(2)
-
-    bgl.glBegin(bgl.GL_LINE_STRIP)
-    bgl.glVertex2f(*init2d)
-    bgl.glVertex2f(*dest2d)
-    bgl.glEnd()
-    bgl.glPopAttrib()
-
-    # restore opengl defaults
-    bgl.glLineWidth(1)
-    bgl.glDisable(bgl.GL_BLEND)
-    bgl.glColor4f(0.0, 0.0, 0.0, 1.0)
-
-obj_ref = {}
-obj_ref['resize'] = None
-class BLS_ResizeLight(bpy.types.Operator):
-    """Resize BLS Light Mesh"""
-    bl_idname = "bls.resize_light"
-    bl_label = "Resize BLS Light"
-    bl_options = {"REGISTER", "UNDO"}
-    
-    #mouse and ui
-    mouseCo = FloatVectorProperty()
-    mouseCoNew = FloatVectorProperty(default=(0,0,0))
-    tmp_mouseCo = FloatVectorProperty()
-    obLoc = FloatVectorProperty()
-    
-    #values
-    first_value = FloatVectorProperty()
-    tmp_value = FloatVectorProperty()
-    backup_value = FloatVectorProperty()
-    
-    #operator dependants
-    axis = IntProperty(default=2) # x,y,xy
-    precision = BoolProperty()
-    
-    @classmethod
-    def poll(cls, context):
-        light = context.scene.objects.active
-        return context.area.type == 'VIEW_3D' and \
-               context.mode == 'OBJECT' and \
-               context.scene.BLStudio.initialized and \
-               light and \
-               isFamily(light) and \
-               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
-
-    def modal(self, context, event):
-        dist2d = lambda p1, p2: sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
-        
-        if event.type in {'MOUSEMOVE'}:
-            region = context.region  
-            
-            loc2d = [region.width/2, region.height/2]
-            #
-            self.obLoc = (loc2d[0], loc2d[1], 0)
-            
-            self.mouseCoNew = Vector((event.mouse_region_x, event.mouse_region_y, 0))
-            unit = dist2d(loc2d, self.mouseCo)
-            dist = dist2d(loc2d, self.mouseCoNew)
-            
-            scale = (dist/unit)
-            first_scale = Vector(self.first_value)
-            
-            scale_xyz = first_scale + (first_scale * scale - first_scale) / (10 if self.precision else 1)
-            
-            if self.axis == 2:
-                context.area.header_text_set("Scale X: %.4f Y: %.4f" % (scale, scale))
-            elif self.axis == 1:
-                scale_xyz[0] = self.first_value[0]
-                scale_xyz[2] = self.first_value[2]
-                context.area.header_text_set("Scale: %.4f along local Y" % scale)
-            elif self.axis == 0:
-                scale_xyz[1] = self.first_value[1]
-                scale_xyz[2] = self.first_value[2]
-                context.area.header_text_set("Scale: %.4f along local X" % scale)
-            
-            obj_ref['resize'].scale = scale_xyz
-            self.tmp_value = scale_xyz
-            
-            return {'RUNNING_MODAL'}
-        elif event.type == 'X' and event.value == 'PRESS':
-            self.axis = 0 if self.axis != 0 else 2
-        elif event.type == 'Y' and event.value == 'PRESS':
-            self.axis = 1 if self.axis != 1 else 2
-        elif event.type in {'LEFT_SHIFT', 'RIGHT_SHIFT'}:
-             if event.value == 'PRESS':
-                 self.precision = True
-                 
-                 tmp = self.first_value
-                 self.first_value = self.tmp_value
-                 self.tmp_value = tmp
-                 
-                 tmp = self.mouseCo
-                 self.mouseCo = self.mouseCoNew
-                 self.mouseCoNew = tmp
-             elif event.value == 'RELEASE':
-                 self.precision = False
-                 
-                 tmp = self.first_value
-                 self.first_value = self.tmp_value
-                 self.tmp_value = tmp
-                 
-                 tmp = self.mouseCo
-                 self.mouseCo = self.mouseCoNew
-                 self.mouseCoNew = tmp
-        elif event.type == 'LEFTMOUSE':
-            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
-            context.area.header_text_set()
-            context.scene.objects.active = context.scene.objects.active
-            return {'FINISHED'}
-        elif event.type in {'RIGHTMOUSE', 'ESC'}:
-            obj_ref['resize'].scale = self.backup_value
-            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
-            context.area.header_text_set()
-            context.scene.objects.active = context.scene.objects.active
-            return {'CANCELLED'}
-        else:
-            #return {'PASS_THROUGH'}
-            return {'RUNNING_MODAL'}
-
-        return {'RUNNING_MODAL'}
-
-    def invoke(self, context, event):
-        if context.space_data.type == 'VIEW_3D':
-            self.mouseCo = Vector((event.mouse_region_x, event.mouse_region_y, 0))
-            obj_ref['resize'] = getLightController()
-            self.first_value = obj_ref['resize'].scale
-            self.backup_value = obj_ref['resize'].scale[:]
-            args = (self, context)
-            self._handle = bpy.types.SpaceView3D.draw_handler_add(draw_callback_px, args, 'WINDOW', 'POST_PIXEL')
-            context.window_manager.modal_handler_add(self)
-            context.area.header_text_set("Scale X: 1.000 Y: 1.000  [X/Y] Axis, [Shift] Precision mode")
-            return {'RUNNING_MODAL'}
-        else:
-            self.report({'WARNING'}, "Active space must be a View3d")
-            return {'CANCELLED'}
-        
-obj_ref['move'] = None
-class BLS_MoveLight(bpy.types.Operator):
-    """Move BLS Light Mesh"""
-    bl_idname = "bls.move_light"
-    bl_label = "Move BLS Light"
-    bl_options = {"REGISTER", "UNDO"}
-    
-    #mouse and ui
-    mouseCo = FloatVectorProperty()
-    mouseCoNew = FloatVectorProperty(default=(0,0,0))
-    tmp_mouseCo = FloatVectorProperty()
-    obLoc = FloatVectorProperty()
-    
-    #values
-    first_value = FloatVectorProperty()
-    tmp_value = FloatVectorProperty()
-    back_value = FloatVectorProperty()
-    
-    #operator dependants
-    axis = IntProperty(default=2) # [x,y,xy]
-    precision = BoolProperty()
-    
-    @classmethod
-    def poll(cls, context):
-        light = context.scene.objects.active
-        return context.area.type == 'VIEW_3D' and \
-               context.mode == 'OBJECT' and \
-               context.scene.BLStudio.initialized and \
-               light and \
-               isFamily(light) and \
-               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
-
-    def modal(self, context, event):
-        dist2d = lambda p1, p2: sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
-        
-        if event.type in {'MOUSEMOVE'}:
-            region = context.region  
-            rv3d = context.space_data.region_3d
-            
-            self.mouseCoNew = (event.mouse_region_x, event.mouse_region_y, 0)
-            #        
-            loc2d = loc3d2d(region, rv3d, self.obLoc)
-            dx = self.mouseCoNew[0] - self.mouseCo[0]
-            dy = self.mouseCoNew[1] - self.mouseCo[1]
-                        
-            first_loc = Vector(self.first_value)
-            last_loc = Vector((first_loc[0] + dx/(1000 if self.precision else 100), first_loc[1] + dy/(1000 if self.precision else 100), first_loc[2]))
-            
-            if self.axis == 2: #xy
-                context.area.header_text_set("Move Dx: %.4f Dy: %.4f" % (dx, dy))
-                last_loc[2] = self.backup_value[2]
-            elif self.axis == 1: #y
-                last_loc[0] = self.first_value[0]
-                last_loc[2] = self.backup_value[2]
-                context.area.header_text_set("Move: %.4f along local Y" % dy)
-            elif self.axis == 0: #x
-                last_loc[1] = self.first_value[1]
-                last_loc[2] = self.backup_value[2]
-                context.area.header_text_set("Move: %.4f along local X" % dx)
-            
-            last_loc[0] = (last_loc[0] + 2) % 4 - 2
-            obj_ref['move'].location = last_loc
-            self.tmp_value = last_loc
-            
-            return {'RUNNING_MODAL'}
-        elif event.type == 'X' and event.value == 'PRESS':
-            self.axis = 0 if self.axis != 0 else 2
-        elif event.type == 'Y' and event.value == 'PRESS':
-            self.axis = 1 if self.axis != 1 else 2
-        elif event.type in {'LEFT_SHIFT', 'RIGHT_SHIFT'}:
-             if event.value == 'PRESS':
-                 self.precision = True
-                 
-                 tmp = self.first_value
-                 self.first_value = self.tmp_value
-                 self.tmp_value = tmp
-                 
-                 tmp = self.mouseCo
-                 self.mouseCo = self.mouseCoNew
-                 self.mouseCoNew = tmp
-             elif event.value == 'RELEASE':
-                 self.precision = False
-                 
-                 tmp = self.first_value
-                 self.first_value = self.tmp_value
-                 self.tmp_value = tmp
-                 
-                 tmp = self.mouseCo
-                 self.mouseCo = self.mouseCoNew
-                 self.mouseCoNew = tmp
-        elif event.type == 'LEFTMOUSE':
-            context.area.header_text_set()
-            return {'FINISHED'}
-        elif event.type in {'RIGHTMOUSE', 'ESC'}:
-            obj_ref['move'].location = self.backup_value
-            context.area.header_text_set()
-            return {'CANCELLED'}
-        else:
-            #return {'PASS_THROUGH'}
-            return {'RUNNING_MODAL'}
-
-        return {'RUNNING_MODAL'}
-
-    def invoke(self, context, event):
-        if context.space_data.type == 'VIEW_3D':
-            self.mouseCo = Vector((event.mouse_region_x, event.mouse_region_y, 0))
-            obj_ref['move'] = getLightController()
-            self.first_value = obj_ref['move'].location
-            self.backup_value = obj_ref['move'].location[:]
-            context.window_manager.modal_handler_add(self)
-            context.area.header_text_set("Move Dx: 0.000 Dy: 0.000  [X/Y] Axis, [Shift] Precision mode")
-            
-            self.obLoc = getLightMesh().matrix_world.to_translation()
-            
-            return {'RUNNING_MODAL'}
-        else:
-            self.report({'WARNING'}, "Active space must be a View3d")
-            return {'CANCELLED'}
-        
-obj_ref['rotate'] = None
-class BLS_RotateLight(bpy.types.Operator):
-    """Rotate BLS Light Mesh"""
-    bl_idname = "bls.rotate_light"
-    bl_label = "Rotate BLS Light"
-    bl_options = {"REGISTER", "UNDO"}
-    
-    #mouse and ui
-    mouseCo = FloatVectorProperty()
-    mouseCoNew = FloatVectorProperty(default=(0,0,0))
-    tmp_mouseCo = FloatVectorProperty()
-    obLoc = FloatVectorProperty()
-    
-    #values
-    first_value = FloatProperty()
-    tmp_value = FloatProperty()
-    backup_value = FloatProperty()
-    
-    #operator dependants
-    precision = BoolProperty()
-    
-    @classmethod
-    def poll(cls, context):
-        light = context.scene.objects.active
-        return context.area.type == 'VIEW_3D' and \
-               context.mode == 'OBJECT' and \
-               context.scene.BLStudio.initialized and \
-               light and \
-               isFamily(light) and \
-               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
-
-    def modal(self, context, event):
-        dist2d = lambda p1, p2: sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
-        
-        if event.type in {'MOUSEMOVE'}:
-            region = context.region  
-            loc2d = [region.width/2, region.height/2]
-            self.obLoc = (loc2d[0], loc2d[1], 0)
-            #
-            self.mouseCoNew = Vector((event.mouse_region_x, event.mouse_region_y, 0))
-            angle0 = atan2(self.mouseCo[0] - loc2d[0], self.mouseCo[1] - loc2d[1])
-            angle1 = atan2(self.mouseCoNew[0] - loc2d[0], self.mouseCoNew[1] - loc2d[1])
-            angle_diff = (angle1 - angle0)
-            new_angle = self.first_value + angle_diff
-            
-            context.area.header_text_set("Rot: {:^0.3f}".format(degrees(angle_diff)))
-            
-            obj_ref['rotate'].rotation_euler[2] = new_angle
-            self.tmp_value = new_angle
-            
-            return {'RUNNING_MODAL'}
-        elif event.type == 'LEFTMOUSE':
-            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
-            context.area.header_text_set()
-            context.scene.objects.active = context.scene.objects.active
-            return {'FINISHED'}
-        elif event.type in {'RIGHTMOUSE', 'ESC'}:
-            obj_ref['rotate'].rotation_euler[2] = self.backup_value
-            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
-            context.area.header_text_set()
-            context.scene.objects.active = context.scene.objects.active
-            return {'CANCELLED'}
-        else:
-            #return {'PASS_THROUGH'}
-            return {'RUNNING_MODAL'}
-
-        return {'RUNNING_MODAL'}
-
-    def invoke(self, context, event):
-        if context.space_data.type == 'VIEW_3D':
-            self.mouseCo = Vector((event.mouse_region_x, event.mouse_region_y, 0))
-            obj_ref['rotate'] = getLightController()
-            self.first_value = obj_ref['rotate'].rotation_euler[2]
-            self.backup_value = obj_ref['rotate'].rotation_euler[2]
-            args = (self, context)
-            self._handle = bpy.types.SpaceView3D.draw_handler_add(draw_callback_px, args, 'WINDOW', 'POST_PIXEL')
-            context.window_manager.modal_handler_add(self)
-            context.area.header_text_set("Rot: 0.000")
-            return {'RUNNING_MODAL'}
         else:
             self.report({'WARNING'}, "Active space must be a View3d")
             return {'CANCELLED'}
\ No newline at end of file
diff --git a/src/light_operators.py b/src/light_operators.py
index 47e65f1..ee1a224 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -1,77 +1,22 @@
 import bpy
 from bpy.props import BoolProperty, PointerProperty, FloatProperty, CollectionProperty, IntProperty, StringProperty
-from . window_operations import splitV3DtoBLS
 from . light_profiles import ListItem, update_list_index
 from . common import *
 import os
+from . import operators
 
 _ = os.sep
 
-from extensions_framework import util as efutil
+from . extensions_framework import util as efutil
 from . import bl_info
-
-def update_selection_override():
-    from . selectOperator import addon_keymaps
-    keylen = bool(len(addon_keymaps))
-    
-    selection_override = bpy.bls_selection_override_right if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT' else bpy.bls_selection_override_left
-    if keylen != selection_override:
-        from . selectOperator import add_shortkeys, remove_shortkeys
-        if selection_override:
-            add_shortkeys()
-        else:
-            remove_shortkeys()
-    return selection_override
     
 class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
-    initialized = BoolProperty(default = False)
-            
-    def get_light_hidden(self):
-        return getLightMesh().hide_render
-    
-    def set_light_hidden(self, context):
-        light = getLightMesh()
-        light.hide_render = context
-        light.hide = context
-        bpy.context.scene.frame_current = bpy.context.scene.frame_current # refresh hack
-        refreshMaterials()
-    
-    light_muted = BoolProperty(name="Mute Light", default=False, set=set_light_hidden, get=get_light_hidden)
-    
-    def get_selection_overriden(self):
-        if not (hasattr(bpy, 'bls_selection_override_left') and hasattr(bpy, 'bls_selection_override_right')):
-            bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)
-            bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
-        
-        return update_selection_override()
-    
-    def set_selection_overriden(self, context):
-        from . selectOperator import add_shortkeys, remove_shortkeys
-        if context:
-            add_shortkeys()
-        else:
-            remove_shortkeys()
-        
-        if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT':
-            bpy.bls_selection_override_right = context
-            efutil.write_config_value(bl_info['name'], 'defaults', 'selection_override_right', context)
-        else:
-            bpy.bls_selection_override_left = context
-            efutil.write_config_value(bl_info['name'], 'defaults', 'selection_override_left', context)
-        
-            
-    selection_overriden = BoolProperty(
-        name="Override Selection",
-        default = True,
-        set=set_selection_overriden,
-        get=get_selection_overriden
-    )
-    
+    initialized: BoolProperty(default = False)    
     
     ''' Profile List '''
-    profile_list = CollectionProperty(type = ListItem)
-    list_index = IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
-    last_empty = StringProperty(name="Name of last Empty holding profile", default="")
+    profile_list: CollectionProperty(type = ListItem)
+    list_index: IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
+    last_empty: StringProperty(name="Name of last Empty holding profile", default="")
     
 
 class CreateBlenderLightStudio(bpy.types.Operator):
@@ -87,23 +32,21 @@ class CreateBlenderLightStudio(bpy.types.Operator):
     def execute(self, context):
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
-        
-        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Object'+_,
-        directory=os.path.join(dir,"BLS.blend"+_+"Object"+_),
-        filename="BLENDER_LIGHT_STUDIO",
-        active_layer=False)
 
-        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Object'+_,
-        directory=os.path.join(dir,"BLS.blend"+_+"Object"+_),
-        filename="BLS_PANEL",
-        active_layer=False)
-        
-        cpanel = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLS_PANEL')][0]
-        cpanel.parent = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
+        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Collection'+_,
+        directory=os.path.join(dir,"BLS3.blend"+_+"Collection"+_),
+        filename="BLS",
+        active_collection=False)
 
         bpy.ops.bls_list.new_profile()
         
         context.scene.BLStudio.initialized = True
+
+        bpy.context.scene.render.engine = 'CYCLES'
+
+        # add the first light
+        # bpy.ops.object.select_all(action='DESELECT')
+        # bpy.ops.scene.add_blender_studio_light()
         
         return {"FINISHED"}
   
@@ -162,139 +105,28 @@ class AddBSLight(bpy.types.Operator):
         dir = os.path.dirname(script_file)
         
         scene = context.scene
-        bls = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
-    
-        # before
-        A = set(bpy.data.groups[:])
-        A_actions = set(bpy.data.actions[:]) # remove bugged actions (Blender 2.78 bug)
-        
-        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Group'+_,
-        directory=os.path.join(dir,"BLS.blend"+_+"Group"+_),
-        filename="BLS_Light",
-        active_layer=False)
-        
-        if bpy.data.actions.find("BLS_ROT_X") == -1:
-            bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Action'+_,
-            directory=os.path.join(dir,"BLS.blend"+_+"Action"+_),
-            filename="BLS_ROT_X",
-            active_layer=False)
-
-        if bpy.data.actions.find("BLS_ROT_Z") == -1:
-            bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Action'+_,
-            directory=os.path.join(dir,"BLS.blend"+_+"Action"+_),
-            filename="BLS_ROT_Z",
-            active_layer=False)
-            
+        bls_collection, profile_collection, profile, handle = blscol_profilecol_profile_handle(context)
 
-        #################
-        # maybe later
-        '''
-        filepath = os.path.join(dir,"BLS.blend") #os.path.join(os.sep, "BLS.blend")
+        filepath = os.path.join(dir,"BLS3.blend")
         # load a single scene we know the name of.
         with bpy.data.libraries.load(filepath) as (data_from, data_to):
-            data_to.groups = ["BLS_Light"]
+            data_to.collections = ["BLS_Light"]
             
-        for group in data_to.groups:
-            if group is not None:
-                print(group.name)
-                bpy.ops.object.group_link(group=group.name)
-        '''
-        #################
-        
-        # after operation
-        B = set(bpy.data.groups[:])
-
-        # whats the difference
-        new_objects = (A ^ B).pop().objects
-        
-        for ob in new_objects:
-            print(ob)
-            ob.use_fake_user = True
-        
-        lightGrp = [l for l in new_objects if l.name.startswith('BLS_LIGHT_GRP')][0]
-        profile = [ob for ob in bpy.context.scene.objects if ob and ob.name.startswith('BLS_PROFILE') and isFamily(ob)][0]
-        handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
-        lightGrp.parent = profile
-        
-        bpy.ops.object.select_all(action='DESELECT')
-        light = [p for p in new_objects if p.name.startswith('BLS_LIGHT_MESH')][0]
-        light.select = True
-        panel = [p for p in new_objects if p.name.startswith('BLS_CONTROLLER')][0]
-        panel.select = True
-        context.scene.objects.active = panel
-        
-        ##### Blender 2.78 workaround. Constraints cannot be appended
-        c = light.constraints.new('COPY_ROTATION')
-        c.target = panel
-        c.use_x = False
-        c.use_y = False
-        c.owner_space = 'LOCAL'
-        c.use_z = True
-        c.invert_z = True
-        
-        c = light.constraints.new('TRANSFORM')
-        c.target = panel
-        c.use_motion_extrapolate = True
-        c.map_from = 'SCALE'
-        c.from_min_x_scale = 0.1
-        c.from_max_x_scale = 20
-        c.from_min_y_scale = 0.1
-        c.from_max_y_scale = 20
-        c.from_min_z_scale = 0.1
-        c.from_max_z_scale = 20
-        
-        c.map_to_x_from = 'Z'
-        c.map_to_y_from = 'X'
-        c.map_to_z_from = 'Y'
-        
-        c.map_to = 'SCALE'
-        c.to_min_x_scale = 0.1
-        c.to_max_x_scale = 20
-        c.to_min_y_scale = 0.1
-        c.to_max_y_scale = 20
-        c.to_min_z_scale = 0.1
-        c.to_max_z_scale = 20
-        
-        ##
-        c = panel.constraints.new('LIMIT_LOCATION')
-        c.use_min_x = True
-        c.min_x = -2
-        c.use_max_x = True
-        c.max_x = 2
-        
-        c.use_min_y = True
-        c.min_y = -1
-        c.use_max_y = True
-        c.max_y = 1
-        
-        c = panel.constraints.new('LIMIT_SCALE')
-        c.use_min_x = True
-        c.min_x = 0.1
-        c.use_min_y = True
-        c.min_y = 0.1
-        c.use_min_z = True
-        c.min_z = 0.1
-        
-        ##
-        armature1 = [a for a in new_objects if a.name.startswith("BLS_Armature")][0]
-        armature2 = [a for a in new_objects if a.name.startswith("BLS_Armature2")][0]
-        
-        c = armature1.constraints.new('ACTION')
-        c.target = panel
-        c.action = bpy.data.actions["BLS_ROT_Z"]
-        c.min = -2
-        c.max = 2
-        c.frame_start = 1
-        c.frame_end = 500
+        for collection in data_to.collections:
+            if collection is not None:
+                profile_collection.children.link(collection)
+                new_objects = collection.objects
+                for ob in new_objects:
+                    ob.use_fake_user = True
+                
+                blslight = [l for l in new_objects if l.name.startswith('BLS_LIGHT')][0]
+                blslight.parent = profile 
+                
+                bpy.ops.object.select_all(action='DESELECT')
+                light = [p for p in new_objects if p.name.startswith('BLS_LIGHT_MESH')][0]
+                light.select_set(True)
+                context.view_layer.objects.active = light
         
-        c = armature2.constraints.new('ACTION')
-        c.target = panel
-        c.action = bpy.data.actions["BLS_ROT_X"]
-        c.transform_channel = 'LOCATION_Y'
-        c.min = -1
-        c.max = 1
-        c.frame_start = 1
-        c.frame_end = 500
         #####
         
         c = light.constraints.new('COPY_LOCATION')
@@ -303,9 +135,10 @@ class AddBSLight(bpy.types.Operator):
         c.use_y = True
         c.use_z = True
         c.use_offset = True
-        bpy.context.scene.frame_current = bpy.context.scene.frame_current # refresh hack
-        refreshMaterials()
-                
+        # scene.frame_current = bpy.context.scene.frame_current # refresh hack
+        # refreshMaterials()
+        
+        operators.update()
         return {"FINISHED"}
     
 class DeleteBSLight(bpy.types.Operator):
@@ -316,49 +149,24 @@ class DeleteBSLight(bpy.types.Operator):
     
     @classmethod
     def poll(cls, context):
-        light = context.scene.objects.active
+        light = context.active_object
         return context.area.type == 'VIEW_3D' and \
                context.mode == 'OBJECT' and \
                context.scene.BLStudio.initialized and \
                light and \
-               light.name.startswith('BLS_') and \
-               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+               light.name.startswith('BLS_LIGHT') and \
+               not light.name.startswith('BLS_PROFILE')
 
     def execute(self, context):
         scene = context.scene
-        oldlaysArea = context.area.spaces[0].layers[:]
-        oldlaysScene = context.scene.layers[:]
-        context.area.spaces[0].layers = [True]*20
-        context.scene.layers = [True]*20
-        
-        light = bpy.context.scene.objects.active
-        
-        
-        lightGrp = findLightGrp(light)
-        if lightGrp == None:
-            if light.parent and light.parent.name.startswith('BLS_PROFILE'):
-                light.select = False
-                self.report({'WARNING'}, "Delete Profile in order to delete Handle")
-                return {"CANCELLED"}
-            else:
-                scene.objects.unlink(light)
-                return {"FINISHED"}
-            
-        ending = lightGrp.name.split('.')[1]
-        
-        #obsToRemove = [ob for ob in scene.objects if not ob.name.startswith('BLS_PROFILE.') and ob.name.endswith(ending) and isFamily(ob)]
-        #print(obsToRemove)
-        for ob in family(lightGrp):
-            scene.objects.unlink(ob)
-            for gr in ob.users_group:
-                gr.objects.unlink(ob)
-            ob.user_clear()
-            ob.use_fake_user = False
-            bpy.data.objects.remove(ob)
-        
-        context.area.spaces[0].layers = oldlaysArea
-        context.scene.layers = oldlaysScene
+        light = context.object
+
+        for collection in light.users_collection:
+            if collection.name.startswith('BLS_Light'):
+                bpy.ops.object.delete({"selected_objects": collection.objects}, use_global=True)
+                bpy.data.collections.remove(collection)
                 
+        operators.update()
         return {"FINISHED"}
     
     def invoke(self, context, event):
@@ -370,21 +178,6 @@ class DeleteBSLight(bpy.types.Operator):
         col = layout.column(align=True)
         col.label(text="OK?")
     
-class PrepareBSLV3D(bpy.types.Operator):
-    bl_idname = "scene.prepare_blender_studio_light"
-    bl_label = "Prepare Layout"
-    bl_description = "Split current Viewport for easier Studio usage."
-    bl_options = {"REGISTER"}
-    
-    @classmethod
-    def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-    
-    def execute(self, context):
-        splitV3DtoBLS(context)
-        context.scene.render.engine="CYCLES"
-        return {"FINISHED"}
-    
 class BSL_MuteOtherLights(bpy.types.Operator):
     bl_idname = "object.mute_other_lights"
     bl_label = "Show Only This Light"
@@ -394,7 +187,7 @@ class BSL_MuteOtherLights(bpy.types.Operator):
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized \
-            and context.scene.objects.active and (context.scene.objects.active.name.startswith('BLS_CONTROLLER') or context.scene.objects.active.name.startswith('BLS_LIGHT_MESH'))
+            and context.active_object and (context.active_object.name.startswith('BLS_CONTROLLER') or context.active_object.name.startswith('BLS_LIGHT_MESH'))
     
     def execute(self, context):
         obs = context.scene.objects
@@ -409,8 +202,8 @@ class BSL_MuteOtherLights(bpy.types.Operator):
                 light.hide_render = True
                 light.hide = True
                 
-        context.scene.frame_current = context.scene.frame_current # refresh hack
-        refreshMaterials()
+        # context.scene.frame_current = context.scene.frame_current # refresh hack
+        # refreshMaterials()
     
         return {"FINISHED"}
     
@@ -430,8 +223,8 @@ class BSL_ShowAllLights(bpy.types.Operator):
             light.hide_render = False
             light.hide = False
                 
-        context.scene.frame_current = context.scene.frame_current # refresh hack
-        refreshMaterials()
+        # context.scene.frame_current = context.scene.frame_current # refresh hack
+        # refreshMaterials()
     
         return {"FINISHED"}
         
\ No newline at end of file
diff --git a/src/light_preview_list.py b/src/light_preview_list.py
index 014c7d1..052e9f8 100644
--- a/src/light_preview_list.py
+++ b/src/light_preview_list.py
@@ -75,7 +75,7 @@ def preview_enum_set(wm, context):
     name = preview_collections["main"].tex_previews[context][0]
     
     light = getLightMesh()
-    light.active_material.node_tree.nodes["Light Texture"].image = bpy.data.images.load(os.path.join(directory, name), True)
+    light.active_material.node_tree.nodes["Light Texture"].image = bpy.data.images.load(os.path.join(directory, name), check_existing=True)
     
     return None
 
diff --git a/src/light_profiles.py b/src/light_profiles.py
index fa63968..c5f9c29 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -1,7 +1,7 @@
 import bpy
 from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProperty, EnumProperty
 import os
-from . common import isFamily, family, findLightGrp, getLightHandle
+from . common import *
 from itertools import chain
 
 _ = os.sep
@@ -11,18 +11,18 @@ class ListItem(bpy.types.PropertyGroup):
     def update_name(self, context):
         print("{} : {}".format(repr(self.name), repr(context)))
                 
-    name = StringProperty(
+    name: StringProperty(
             name="Profile Name",
             default="Untitled")
 
-    empty_name = StringProperty(
-            name="Name of Empty holding profile",
+    empty_name: StringProperty(
+            name="Name of Empty that holds the profile",
             description="",
             default="")
             
 class BLS_UL_List(bpy.types.UIList):
     def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
-        custom_icon = 'OUTLINER_OB_LAMP' if index == context.scene.BLStudio.list_index else 'LAMP'
+        custom_icon = 'OUTLINER_OB_LIGHT' if index == context.scene.BLStudio.list_index else 'LIGHT'
 
         # Make sure your code supports all 3 layout types
         if self.layout_type in {'DEFAULT', 'COMPACT'}:
@@ -40,12 +40,19 @@ class LIST_OT_NewItem(bpy.types.Operator):
     bl_label = "Add a new Profile"
     bl_options = {"INTERNAL"}
     
-    handle = BoolProperty(default=True)
+    handle: BoolProperty(default=True)
 
     def execute(self, context):
         props = context.scene.BLStudio
         item = props.profile_list.add()
-        
+        bls_collection = get_bls_collection(context)
+
+        # unlink existing profiles
+        for profile in (prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)):
+            profile_collection = profile.users_collection[0]
+            bls_collection.children.unlink(profile_collection)
+        #
+
         idx = 0
         for id in (i.name.split('Profile ')[1] for i in props.profile_list if i.name.startswith('Profile ')):
             try:
@@ -63,10 +70,10 @@ class LIST_OT_NewItem(bpy.types.Operator):
         
         script_file = os.path.realpath(__file__)
         dir = os.path.dirname(script_file)
-        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Object'+_,
-        directory=os.path.join(dir,"BLS.blend"+_+"Object"+_),
-        filename="BLS_PROFILE.000",
-        active_layer=False)
+        bpy.ops.wm.append(filepath=_+'BLS3.blend'+_+'Object'+_,
+            directory=os.path.join(dir,"BLS3.blend"+_+"Object"+_),
+            filename="BLS_PROFILE.000",
+            active_collection=True)
         
         # after operation
         B = set(bpy.data.objects[:])
@@ -74,30 +81,29 @@ class LIST_OT_NewItem(bpy.types.Operator):
         # whats the difference
         profile = (A ^ B).pop()
         
-        profile.parent = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
+        profile.parent = [ob for ob in context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
         profile.use_fake_user = True
+        profile_collection = bpy.data.collections.new(profile.name)
+        profile_collection.use_fake_user = True
+        bls_collection = [c for c in context.scene.collection.children if c.name.startswith('BLS')][0]
+        bls_collection.children.link(profile_collection)
+        replace_link(profile, profile.name)
         
         item.empty_name = profile.name
         
         handle = None
         if self.handle:
-            bpy.ops.object.empty_add(type='PLAIN_AXES', radius=1, view_align=False, location=(0, 0, 0), layers=(True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
+            bpy.ops.object.empty_add()
             handle = context.active_object
             handle.name = "BLS_HANDLE"
-            handle.empty_draw_type = 'SPHERE'
+            handle.empty_display_type = 'SPHERE'
             handle.parent = profile
             handle.protected = True
             handle.use_fake_user = True
-            handle['last_layers'] = handle.layers[:]
+            replace_link(handle, profile.name)
         
-        #if len([prof for prof in profile.parent.children if prof.name.startswith('BLS_PROFILE.')]) > 1:
-        if len([prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)]) > 1:
-            #profile already exists
-            context.scene.objects.unlink(profile)
-            if handle: context.scene.objects.unlink(handle)
-        else:
-            #init last_empty for first profile
-            props.last_empty = profile.name
+        props.last_empty = profile.name
+        props.list_index = len(props.profile_list)-1
 
         return{'FINISHED'}
 
@@ -115,21 +121,21 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
  
     def execute(self, context):
         props = context.scene.BLStudio
-        list = props.profile_list
         index = props.list_index
  
-        list.remove(index)
+        props.profile_list.remove(index)
         
         ''' Delete/Switch Hierarchy stuff '''
         #delete objects from current profile           
         obsToRemove = family(context.scene.objects[props.last_empty])
+        collectionsToRemove = set()
         for ob in obsToRemove:
-            context.scene.objects.unlink(ob)
-            for gr in ob.users_group:
-                gr.objects.unlink(ob)
-            ob.user_clear()
+            collectionsToRemove.update(ob.users_collection)
             ob.use_fake_user = False
-            bpy.data.objects.remove(ob)
+        bpy.ops.object.delete({"selected_objects": obsToRemove}, use_global=True)
+        for c in collectionsToRemove:
+            if c.name.startswith('BLS_'):
+                bpy.data.collections.remove(c)
         
         # update index
         if index > 0:
@@ -261,10 +267,10 @@ class LIST_OT_MoveItem(bpy.types.Operator):
     """ Move an item in the list """
 
     bl_idname = "bls_list.move_profile"
-    bl_label = "Move an profile in the list"
+    bl_label = "Move profile in the list"
     bl_options = {"INTERNAL"}
 
-    direction = bpy.props.EnumProperty(
+    direction: bpy.props.EnumProperty(
                 items=(
                     ('UP', 'Up', ""),
                     ('DOWN', 'Down', ""),))
@@ -311,6 +317,7 @@ class LIST_OT_MoveItem(bpy.types.Operator):
 
 def update_list_index(self, context):
     props = context.scene.BLStudio
+    bls_collection = get_bls_collection(context)
     
     if len(props.profile_list) == 0: return
         
@@ -321,20 +328,14 @@ def update_list_index(self, context):
     print('Index update {}'.format(self.list_index))
         
     #unlink current profile
-    if context.scene.objects.find(props.last_empty) > -1: # in case of update after deletion
-        for ob in family(context.scene.objects[props.last_empty]):
-            ob['last_layers'] = ob.layers[:]
-            try:
-                context.scene.objects.unlink(ob)
-            except Exception:
-                print('Warning: Light Studio Profile corrupted. Handle with care!')
+    prof_idx = context.scene.objects.find(props.last_empty)
+    if prof_idx > -1: # in case of update after deletion
+        profile_collection = context.scene.objects[prof_idx].users_collection[0]
+        bls_collection.children.unlink(profile_collection)
         
     #link selected profile
-    for ob in family(bpy.data.objects[selected_profile.empty_name]):
-        print(ob.name)
-        context.scene.objects.link(ob)
-        ob.layers = [bool(l) for l in ob['last_layers']]
-        
+    bls_collection.children.link(bpy.data.collections[selected_profile.empty_name])
+    
     props.last_empty = selected_profile.empty_name
     
         
@@ -344,7 +345,7 @@ import json, time
 script_file = os.path.realpath(__file__)
 dir = os.path.dirname(script_file)
 
-VERSION = 1.01
+VERSION = 2.00
 def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
     plist = props.profile_list
     for profile in profiles:
@@ -356,7 +357,6 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             date = time.localtime()
             plist[-1].name += ' {}-{:02}-{:02} {:02}:{:02}'.format(str(date.tm_year)[-2:], date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
 
-        #lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
         profile_empty = context.scene.objects[plist[-1].empty_name]
         
         if version > 1:
@@ -376,30 +376,52 @@ def parse_profile(context, props, profiles, version=VERSION, internal_copy=False
             
             # whats the difference
             lgrp = (A ^ B).pop()
-            controller = [c for c in family(lgrp) if "BLS_CONTROLLER" in c.name][0]
-            props.light_radius = light['radius']
-            
-            controller.location.x = light['position'][0]
-            controller.location.y = light['position'][1]
-            controller.location.z = light['position'][2]
+
+            actuator = [c for c in family(lgrp) if "BLS_ROTATION" in c.name][0]
+            lmesh = [c for c in family(lgrp) if "BLS_LIGHT_MESH" in c.name][0]
+            lmesh.location.x = light['radius']
             
-            controller.scale.x = light['scale'][0]
-            controller.scale.y = light['scale'][1]
-            controller.scale.z = light['scale'][2]
+            actuator.rotation_euler.x = light['position'][0]
+            actuator.rotation_euler.y = light['position'][1]
+            actuator.rotation_euler.z = 0
             
-            controller.rotation_euler.z = light['rotation']
+            lmesh.scale.x = light['scale'][0]
+            lmesh.scale.y = light['scale'][1]
+            lmesh.scale.z = light['scale'][2]
             
-            props.light_muted = light['mute']
-            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[2].default_value = light['Intensity']
-            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
-            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
-            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
-            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
+            lmesh.rotation_euler.x = light['rotation']
+
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value = light['Texture Switch']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0] = light['Color Overlay'][0]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1] = light['Color Overlay'][1]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2] = light['Color Overlay'][2]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3] = light['Color Overlay'][3]
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Color Saturation']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Intensity']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Mask - Gradient Switch']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value = light['Mask - Gradient Type']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value = light['Mask - Gradient Amount']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value = light['Mask - Ring Switch']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value = light['Mask - Ring Inner Radius']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value = light['Mask - Ring Outer Radius']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value = light['Mask - Top to Bottom']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value = light['Mask - Bottom to Top']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value = light['Mask - Left to Right']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value = light['Mask - Right to Left']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value = light['Mask - Diagonal Top Left']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value = light['Mask - Diagonal Top Right']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value = light['Mask - Diagonal Bottom Right']
+            lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value = light['Mask - Diagonal Bottom Left']
+
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
+            # lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
             
             if os.path.isabs(light['tex']):
-                controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
+                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
             else:
-                controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
+                lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
                 
 class ImportProfiles(bpy.types.Operator):
     """ Import Profiles from File """
@@ -408,7 +430,7 @@ class ImportProfiles(bpy.types.Operator):
     bl_label = "Import Profiles"
     #bl_options = {"INTERNAL"}
     
-    filepath = bpy.props.StringProperty(default="*.bls", subtype="FILE_PATH")
+    filepath: bpy.props.StringProperty(default="*.bls", subtype="FILE_PATH")
  
     @classmethod
     def poll(self, context):
@@ -416,7 +438,6 @@ class ImportProfiles(bpy.types.Operator):
  
     def execute(self, context):
         props = context.scene.BLStudio
-        plist = props.profile_list
         
         with open(self.filepath, 'r') as f:
             file = f.read()
@@ -433,32 +454,53 @@ class ImportProfiles(bpy.types.Operator):
 
 def compose_profile(list_index):
     props = bpy.context.scene.BLStudio
-    
     profile_dict = {}
     profile_dict['name'] = props.profile_list[list_index].name
     profile_dict['lights']= []
     profile = bpy.data.objects[props.profile_list[list_index].empty_name]
-    lgroups = [lg for lg in family(profile) if "BLS_LIGHT_GRP" in lg.name]
+    profile_collection = get_collection(profile)
     handle = getLightHandle(profile)
-    print(profile, handle)
     profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
-    for lg in lgroups:
-        controller = [c for c in family(lg) if "BLS_CONTROLLER" in c.name][0]
-        lmesh = [l for l in family(lg) if "BLS_LIGHT_MESH" in l.name][0]
+    for light_collection in profile_collection.children:
+        lmesh = [ob for ob in light_collection.objects if ob.name.startswith('BLS_LIGHT_MESH')][0]
+        actuator = [ob for ob in light_collection.objects if ob.name.startswith('BLS_ROTATION')][0]
         light = {}
         light['radius'] = lmesh.location.x
-        light['position'] = [controller.location.x, controller.location.y, controller.location.z]
-        light['scale'] = [controller.scale.x, controller.scale.y, controller.scale.z]
-        light['rotation'] = controller.rotation_euler.z
-        light['mute'] = props.light_muted
-        texpath = controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath
+        light['position'] = [actuator.rotation_euler.x, actuator.rotation_euler.y]
+        light['scale'] = [lmesh.scale.x, lmesh.scale.y, lmesh.scale.z]
+        light['rotation'] = lmesh.rotation_euler.x
+        # view_layer = find_view_layer(light_collection, bpy.context.view_layer.layer_collection)
+        # light['mute'] = view_layer.exclude
+        texpath = lmesh.material_slots[0].material.node_tree.nodes["Light Texture"].image.filepath
         light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
         
-        light['Intensity'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[2].default_value
-        light['Opacity'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[3].default_value
-        light['Falloff'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[4].default_value
-        light['Color Saturation'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[5].default_value
-        light['Half'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[6].default_value
+        light['Texture Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
+        light['Color Overlay'] = [lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[0],
+                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[1],
+                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[2],
+                                  lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value[3]]
+        light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
+        light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
+        light['Mask - Gradient Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
+        light['Mask - Gradient Type'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[7].default_value
+        light['Mask - Gradient Amount'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[8].default_value
+        light['Mask - Ring Switch'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[9].default_value
+        light['Mask - Ring Inner Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[10].default_value
+        light['Mask - Ring Outer Radius'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[11].default_value
+        light['Mask - Top to Bottom'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[12].default_value
+        light['Mask - Bottom to Top'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[13].default_value
+        light['Mask - Left to Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[14].default_value
+        light['Mask - Right to Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[15].default_value
+        light['Mask - Diagonal Top Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[16].default_value
+        light['Mask - Diagonal Top Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[17].default_value
+        light['Mask - Diagonal Bottom Right'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[18].default_value
+        light['Mask - Diagonal Bottom Left'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[19].default_value
+
+        # light['Intensity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[2].default_value
+        # light['Opacity'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[3].default_value
+        # light['Falloff'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[4].default_value
+        # light['Color Saturation'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[5].default_value
+        # light['Half'] = lmesh.material_slots[0].material.node_tree.nodes["Group"].inputs[6].default_value
         
         profile_dict['lights'].append(light)
         
@@ -471,8 +513,8 @@ class ExportProfiles(bpy.types.Operator):
     bl_label = "Export"
     #bl_options = {"INTERNAL"}
     
-    filepath = bpy.props.StringProperty(default="profile.bls", subtype="FILE_PATH")
-    all = bpy.props.BoolProperty(default=False, name="Export All Profiles")
+    filepath: bpy.props.StringProperty(default="profile.bls", subtype="FILE_PATH")
+    all: bpy.props.BoolProperty(default=False, name="Export All Profiles")
  
     @classmethod
     def poll(self, context):
@@ -539,7 +581,7 @@ class CopyProfileToScene(bpy.types.Operator):
     def get_scenes(self, context):
         return ((s.name, s.name, "Scene name") for i,s in enumerate(bpy.data.scenes))#global_vars["scenes"]
     
-    sceneprop = EnumProperty(items = get_scenes)
+    sceneprop: EnumProperty(items = get_scenes)
     
     @classmethod
     def poll(self, context):
diff --git a/src/operators/__init__.py b/src/operators/__init__.py
new file mode 100644
index 0000000..e71d203
--- /dev/null
+++ b/src/operators/__init__.py
@@ -0,0 +1,16 @@
+# class UpdateChecker:
+#     def __init__(self):
+#         self.updated
+UPDATED = True
+
+def is_updated():
+    global UPDATED
+    return UPDATED
+
+def update():
+    global UPDATED
+    UPDATED = True
+
+def update_clear():
+    global UPDATED
+    UPDATED = False
\ No newline at end of file
diff --git a/src/operators/modal.py b/src/operators/modal.py
new file mode 100644
index 0000000..25ef9e2
--- /dev/null
+++ b/src/operators/modal.py
@@ -0,0 +1,413 @@
+import bpy
+
+from mathutils import *
+
+from . modal_utils import *
+from . import *
+
+from .modal_utils import shader2Dcolor
+from gpu_extras.batch import batch_for_shader
+import time
+
+last_time = time.time()
+def draw(self, area):
+    if area != bpy.context.area:
+        return
+
+    # draw something to refresh renderer? color won't work otherwise
+    shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
+    batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
+    #
+
+    self.panel.draw()
+    for b in Button.buttons:
+        b.draw(self.mouse_x, self.mouse_y)
+    for l in LightImage.lights:
+        l.draw()
+
+
+class BLS_OT_Rotate(bpy.types.Operator, MouseWidget):
+    bl_idname = "light_studio.rotate"
+    bl_label = "Rotate Light"
+    bl_options = {"REGISTER", "UNDO", "INTERNAL"}
+
+    def __init__(self):
+        super().__init__()
+        self.pivot = Vector((self.mouse_x, self.mouse_y))
+        self.base_object_rotation = 0
+        self.allow_precision_mode = True
+
+    def invoke(self, context, event):
+        super().invoke(context, event)
+        self.base_object_rotation = LightImage.selected_object._bls_mesh.rotation_euler.x
+        return {"RUNNING_MODAL"}
+    
+    def _finish(self, context, event):
+        context.area.header_text_set(text=None)
+
+    def _cancel(self, context, event):
+        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation
+        context.area.header_text_set(text=None)
+
+    def _modal(self, context, event):
+        LightImage.selected_object._bls_mesh.rotation_euler.x = self.base_object_rotation + self.angle()
+
+        context.area.header_text_set(text=f"Rot: {self.angle():.3f}")
+
+        return {"PASS_THROUGH"}
+
+class BLS_OT_Scale(bpy.types.Operator, MouseWidget):
+    bl_idname = "light_studio.scale"
+    bl_label = "Scale Light"
+    bl_options = {"GRAB_CURSOR", "BLOCKING", "REGISTER", "UNDO", "INTERNAL"}
+
+    def __init__(self):
+        super().__init__()
+        self.pivot = Vector((self.mouse_x, self.mouse_y))
+        self.base_object_scale = 0
+        self.allow_xy_keys = True
+        self.allow_precision_mode = True
+
+    def invoke(self, context, event):
+        super().invoke(context, event)
+        self.base_object_scale = LightImage.selected_object._bls_mesh.scale.copy()
+        return {"RUNNING_MODAL"}
+    
+    def _cancel(self, context, event):
+        LightImage.selected_object._bls_mesh.scale = self.base_object_scale
+        context.area.header_text_set(text=None)
+
+    def _finish(self, context, event):
+        context.area.header_text_set(text=None)
+
+    def _modal(self, context, event):
+        new_scale = self.base_object_scale * self.delta_length_factor()
+        if self.x_key:
+            new_scale.z = self.base_object_scale.z
+        if self.y_key:
+            new_scale.y = self.base_object_scale.y
+
+        LightImage.selected_object._bls_mesh.scale = new_scale
+
+        context.area.header_text_set(text=f"Scale X: {new_scale.z:.3f} Y: {new_scale.y:.3f}  [X/Y] Axis, [Shift] Precision mode")
+
+        if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+            return {"RUNNING_MODAL"}
+        return {"PASS_THROUGH"}
+
+GRABBING = False
+class BLS_OT_Grab(bpy.types.Operator, MouseWidget):
+    bl_idname = "light_studio.grab"
+    bl_label = "Grab Light"
+    bl_options = {"GRAB_CURSOR", "BLOCKING", "INTERNAL"}
+
+    canvas_width: bpy.props.FloatProperty()
+    canvas_height: bpy.props.FloatProperty()
+
+    def __init__(self):
+        super().__init__()
+        self.pivot = Vector((self.mouse_x, self.mouse_y))
+        self.base_object_rotation = Vector((0, 0, 0))
+        self.allow_xy_keys = True
+        self.continous = True
+        self.draw_guide = False
+        self.allow_precision_mode = True
+
+    def invoke(self, context, event):
+        super().invoke(context, event)
+        self.base_object_rotation = LightImage.selected_object._bls_actuator.rotation_euler.copy()
+        return {"RUNNING_MODAL"}
+    
+    def _cancel(self, context, event):
+        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation
+        global GRABBING
+        GRABBING = False
+        context.area.header_text_set(text=None)
+
+    def _finish(self, context, event):
+        global GRABBING
+        GRABBING = False
+        context.area.header_text_set(text=None)
+
+    def _modal(self, context, event):
+        dv = self.delta_vector()
+        if self.x_key:
+            dv.y = 0
+        if self.y_key:
+            dv.x = 0
+
+        x_factor = 2*pi / self.canvas_width
+        y_factor = pi / self.canvas_height
+
+        LightImage.selected_object._bls_actuator.rotation_euler = self.base_object_rotation.copy()
+        LightImage.selected_object._bls_actuator.rotation_euler.x += dv.x * x_factor
+        LightImage.selected_object._bls_actuator.rotation_euler.y += dv.y * y_factor
+        LightImage.selected_object._bls_actuator.rotation_euler.y = clamp(-pi/2 + 0.000001, LightImage.selected_object._bls_actuator.rotation_euler.y, pi/2 - 0.000001)
+
+        context.area.header_text_set(text=f"Move Dx: {dv.x * x_factor:.3f} Dy: {dv.y * y_factor:.3f}   [X/Y] Axis | [Shift] Precision Mode")
+
+        if event.value == "PRESS" and not event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+            return {"RUNNING_MODAL"}
+        return {"PASS_THROUGH"}
+
+panel_global = None
+# running_modals = 0
+class BLS_OT_control_panel(bpy.types.Operator):
+    bl_idname = "light_studio.control_panel"
+    bl_label = "Light Studio Control Panel"
+
+    mouse_x: bpy.props.IntProperty()
+    mouse_y: bpy.props.IntProperty()
+
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+
+    def __init__(self):
+        self.textinfo = "[S] Scale | [R] Rotate | [Shift] Precision mode | [Double/Triple Click] Mute, Isolate | [Right Click] Isolate | [+/-] Icon scale"
+        self.handler = None
+        self.panel = None
+        self.panel_moving = False
+        self.clicked_object = None
+        self.profile_collection = None
+        self.click_manager = ClickManager()
+        self.active_feature = None
+        self.precision_mode = False
+
+    def __del__(self):
+        self._unregister_handler()
+
+    def _unregister_handler(self):
+        # global running_modals
+        # running_modals = max(0, running_modals-1)
+        try:
+            bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
+        except ValueError:
+            pass
+
+    def _mouse_event(self, context, event):
+        area_mouse_x = event.mouse_x - context.area.x
+        area_mouse_y = event.mouse_y - context.area.y
+        dx = area_mouse_x - self.mouse_x
+        dy = area_mouse_y - self.mouse_y
+        self.mouse_x = area_mouse_x
+        self.mouse_y = area_mouse_y
+        return dx, dy, area_mouse_x, area_mouse_y
+
+    def invoke(self, context, event):
+        # global running_modals
+        # running_modals += 1
+        # if running_modals > 1:
+        #     return {"CANCELLED"}
+
+        self.handler = bpy.types.SpaceView3D.draw_handler_add(draw, (self, context.area), 'WINDOW', 'POST_PIXEL')
+        context.window_manager.modal_handler_add(self)
+
+        aw = context.area.width
+        ah = context.area.height
+        pw = min(aw-60, 600)
+        
+        global panel_global
+        if not panel_global:
+            panel_global = Panel(Vector((30, 25)), pw, pw*(9/16))
+        self.panel = panel_global
+
+        LightImage.default_size = 100
+
+        self.mouse_x = event.mouse_x - context.area.x
+        self.mouse_y = event.mouse_y - context.area.y
+
+        self.update_light_sets(context, always=True)
+
+        context.area.header_text_set(text=self.textinfo)
+
+        return {"RUNNING_MODAL"}
+    
+    def modal(self, context, event):
+        # print(event.type, event.value)
+        if not context.area or (context.object and not context.object.mode == 'OBJECT'):
+            self._unregister_handler()
+            return {"CANCELLED"}
+        try:
+            context.area.tag_redraw()
+
+            self.update_light_sets(context)
+            LightImage.refresh()
+
+            if event.type in {"MOUSEMOVE", "INBETWEEN_MOUSEMOVE"}:
+                dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                if self.clicked_object and self.panel_moving:
+                    # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                    # self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
+                    if isinstance(self.clicked_object, Panel):
+                        # dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                        self.clicked_object.move(Vector((dx * (.1 if self.precision_mode else 1), dy * (.1 if self.precision_mode else 1))))
+                    else:
+                        active_object = None
+                        if LightImage.selected_object:
+                            active_object = LightImage.selected_object
+                        if active_object and not GRABBING:
+                            bpy.ops.light_studio.grab('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y, canvas_width=self.panel.width, canvas_height=self.panel.height)
+                            self.panel_moving = False
+                    
+                    return {"RUNNING_MODAL"}
+
+                return {"PASS_THROUGH"}
+            
+            if event.value == "PRESS":
+                if event.type in {"R"}:
+                    active_object = None
+                    if LightImage.selected_object:
+                        active_object = LightImage.selected_object
+                    
+                    if active_object:
+                        bpy.ops.light_studio.rotate('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
+                        return {'RUNNING_MODAL'}
+                elif event.type in {"S"}:
+                    active_object = None
+                    if LightImage.selected_object:
+                        active_object = LightImage.selected_object
+                    
+                    if active_object:
+                        bpy.ops.light_studio.scale('INVOKE_DEFAULT', mouse_x=active_object.loc.x, mouse_y=active_object.loc.y)
+                        return {'RUNNING_MODAL'}
+
+                elif event.type == "RIGHTMOUSE":
+                    dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+                    self.clicked_object = self.find_clicked(area_mouse_x, area_mouse_y)
+
+                    if not self.clicked_object:
+                        return {"PASS_THROUGH"}
+                    
+                    if hasattr(self.clicked_object, 'mute'):
+                        muted_count = len([l for l in LightImage.lights if l.mute])
+                        unmuted_count = len(LightImage.lights) - muted_count
+                        if muted_count == 0:
+                            # no muted at start. mute all but selected
+                            for l in LightImage.lights:
+                                l.mute = True
+                            self.clicked_object.mute = False
+                        else:
+                            # some muted.
+                            if unmuted_count == 1 and self.clicked_object.mute == False:
+                                for l in LightImage.lights:
+                                    l.mute = False
+                            else:
+                                for l in LightImage.lights:
+                                    l.mute = True
+                                self.clicked_object.mute = False
+
+                    if hasattr(self.clicked_object, 'select'):
+                        self.clicked_object.select()
+                    
+                    return {"RUNNING_MODAL"}
+
+                # Left mouse button pressed            
+                elif event.type == "LEFTMOUSE":
+                    dx, dy, area_mouse_x, area_mouse_y = self._mouse_event(context, event)
+
+                    self.clicked_object = self.find_clicked(area_mouse_x, area_mouse_y)
+                    self.panel_moving = self.clicked_object != None
+                    
+                    click_result = self.click_manager.click(self.clicked_object)
+                    if hasattr(self.clicked_object, 'mute'):
+                        if click_result == "TRIPLE":
+                            muted_count = len([l for l in LightImage.lights if l.mute]) - 1
+                            unmuted_count = len(LightImage.lights) - muted_count
+                            if muted_count == 0:
+                                # no muted at start. mute all but selected
+                                for l in LightImage.lights:
+                                    l.mute = True
+                                self.clicked_object.mute = False
+                            else:
+                                # some muted.
+                                if unmuted_count == 1 and self.clicked_object.mute == True:
+                                    for l in LightImage.lights:
+                                        l.mute = False
+                                else:
+                                    for l in LightImage.lights:
+                                        l.mute = True
+                                    self.clicked_object.mute = False
+                        elif click_result == "DOUBLE":
+                            self.clicked_object.mute = not self.clicked_object.mute
+
+                    if hasattr(self.clicked_object, 'select'):
+                        self.clicked_object.select()
+
+                    if hasattr(self.clicked_object, 'click'):
+                        result = self.clicked_object.click()
+                        if result == "FINISHED":
+                            context.area.header_text_set(text=None)
+                            self._unregister_handler()
+                            return {"FINISHED"}
+                        return {"RUNNING_MODAL"}
+
+                    if self.clicked_object:
+                        return {"RUNNING_MODAL"}
+                    return {"PASS_THROUGH"}
+
+                elif event.type == "NUMPAD_PLUS":
+                    LightImage.change_default_size(LightImage.default_size+10)
+                    return {'RUNNING_MODAL'}
+                elif event.type == "NUMPAD_MINUS":
+                    LightImage.change_default_size(LightImage.default_size-10)
+                    return {'RUNNING_MODAL'}
+                elif event.type == "LEFT_SHIFT":
+                    self.precision_mode = True
+                    return {'RUNNING_MODAL'}
+                
+                # Return (Enter) key is pressed
+                elif event.type == "RET":
+                    context.area.header_text_set(text=None)
+                    self._unregister_handler()
+                    return {'FINISHED'}
+            
+            if event.value == "RELEASE":
+                context.area.header_text_set(text=self.textinfo)
+                if event.type == "LEFTMOUSE":
+                    self.panel_moving = False
+                elif event.type == "LEFT_SHIFT":
+                    self.precision_mode = False
+                    return {'RUNNING_MODAL'}
+
+            if event.value == "CLICK":
+                # Left mouse button clicked
+                if event.type == "LEFTMOUSE":
+                    return {"PASS_THROUGH"}
+        except:
+            self._unregister_handler()
+            import traceback
+            traceback.print_exc()
+            return {"CANCELLED"}
+        
+        return {"PASS_THROUGH"}
+
+    def update_light_sets(self, context, always=False):
+        bls_collection, profile_collection = blscol_profilecol(context)
+        if is_updated() or always or len(profile_collection.children) != len(LightImage.lights):
+            bls_lights = set(profile_collection.children)
+            working_set = set((l._collection for l in LightImage.lights))
+
+            to_delete = working_set.difference(bls_lights)
+            to_add =  bls_lights.difference(working_set)
+            
+            for col in to_delete:
+                LightImage.remove(col)
+
+            for col in to_add:
+                LightImage(context, self.panel, col)
+
+            update_clear()
+
+    def find_clicked(self, area_mouse_x, area_mouse_y):
+        for l in reversed(LightImage.lights):
+            if is_in_rect(l, Vector((area_mouse_x, area_mouse_y))):
+                return l
+        
+        for b in Button.buttons:
+            if is_in_rect(b, Vector((area_mouse_x, area_mouse_y))):
+                return b
+
+        if is_in_rect(self.panel, Vector((area_mouse_x, area_mouse_y))):
+            return self.panel
+        return None
\ No newline at end of file
diff --git a/src/operators/modal_utils.py b/src/operators/modal_utils.py
new file mode 100644
index 0000000..5e43d66
--- /dev/null
+++ b/src/operators/modal_utils.py
@@ -0,0 +1,505 @@
+import gpu, bgl, blf
+from gpu_extras.batch import batch_for_shader
+from mathutils import *
+from math import pi, fmod, radians, sin, cos, atan2
+from .. common import *
+from . import *
+import time
+
+shader2Dcolor = gpu.shader.from_builtin('2D_UNIFORM_COLOR')
+shader2Dcolor.bind()
+
+shader2Dtexture = gpu.shader.from_builtin('2D_IMAGE')
+shader2Dtexture.bind()
+
+class Rectangle:
+    def __init__(self, start_point, width, height):
+        self.point_lt = Vector((
+            min(start_point.x, start_point.x+width),
+            max(start_point.y, start_point.y+height),
+            ))
+        self.point_rb = Vector((
+            max(start_point.x, start_point.x+width),
+            min(start_point.y, start_point.y+height),
+            ))
+
+        self.rot = 0
+
+    @property
+    def loc(self):
+        return (self.point_lt + self.point_rb)/2
+
+    @loc.setter
+    def loc(self, loc):
+        d = loc - self.loc
+        self.point_lt += d
+        self.point_rb += d
+    
+    @property
+    def width(self):
+        return self.point_rb.x - self.point_lt.x
+
+    @width.setter
+    def width(self, width):
+        d = width - self.width
+        self.point_lt.x -= d/2
+        self.point_rb.x = self.point_lt.x + width
+
+    @property
+    def height(self):
+        return self.point_lt.y - self.point_rb.y
+
+    @height.setter
+    def height(self, height):
+        d = height - self.height
+        self.point_lt.y += d/2
+        self.point_rb.y = self.point_lt.y - height
+
+    def get_verts(self):
+        def rotate(x1, y1, offset):
+            x1 -= offset.x
+            y1 -= offset.y
+            x2 = cos(self.rot) * x1 - sin(self.rot) * y1
+            y2 = sin(self.rot) * x1 + cos(self.rot) * y1
+            x2 += offset.x
+            y2 += offset.y
+            return (x2, y2)
+        
+        loc = self.loc # prevent property from recomputing
+        return (
+            rotate(self.point_lt.x, self.point_lt.y, loc),
+            rotate(self.point_lt.x, self.point_rb.y, loc),
+            rotate(self.point_rb.x, self.point_lt.y, loc),
+            rotate(self.point_rb.x, self.point_rb.y, loc),
+        )
+
+    def get_tex_coords(self):
+        return ((0, 1), (0, 0), (1, 1), (1, 0))
+
+    def move(self, loc_diff):
+        rect = self.panel if hasattr(self, 'panel') else self
+
+        new_loc = self.loc + loc_diff
+        new_loc.x = clamp(rect.point_lt.x, new_loc.x, rect.point_rb.x)
+        new_loc.y = clamp(rect.point_rb.y, new_loc.y, rect.point_lt.y)
+        self.loc = new_loc
+
+class Panel(Rectangle):
+    def __init__(self, loc, width, height):
+        super().__init__(loc, width, height)
+        self.button_exit = Button(Vector((0,0)), 'X', 30)
+        self.button_exit.function = lambda x: "FINISHED"
+
+        self.button_send_to_bottom = Button(Vector((0,0)), 'Send to Bottom')
+        def send_light_to_bottom(args):
+            light = LightImage.selected_object
+            lights = LightImage.lights
+            lights.insert(0, lights.pop(lights.index(light)))
+        self.button_send_to_bottom.function = send_light_to_bottom
+
+        self._move_buttons()
+
+    def _move_buttons(self):
+        self.button_exit.loc = Vector((
+            self.point_rb.x - self.button_exit.dimensions[0]/4,
+            self.point_lt.y - self.button_exit.dimensions[1]/4,
+        ))
+
+        self.button_send_to_bottom.loc = Vector((
+            self.point_lt.x + self.button_send_to_bottom.dimensions[0]/2,
+            self.point_rb.y - self.button_exit.dimensions[1]/2,
+        ))
+
+    def draw(self):
+        shader2Dcolor.uniform_float("color", (0.05, 0.05, 0.05, 1))
+        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
+
+    def move(self, loc_diff):
+        super().move(loc_diff)
+
+        for l in LightImage.lights:
+            l.update_visual_location()
+        
+        self._move_buttons()
+
+class Button(Rectangle):
+    buttons = []
+    def __init__(self, loc, text, size=15):
+        self.font_size = size
+        self.font_color = (.25, .25, .25, 1)
+        self.bg_color = (.5, .5, .5, 1)
+        self.bg_color_selected = (.7, .7, .7, 1)
+        self.font_id = len(Button.buttons)
+        self.text = text
+        blf.color(self.font_id, *self.font_color)
+        blf.position(self.font_id, *loc, 0)
+        blf.size(self.font_id, self.font_size, 72)
+        self.dimensions = blf.dimensions(self.font_id, text)
+        self.function = lambda args : None
+
+        super().__init__(loc, self.dimensions[0]+5, self.dimensions[1]+5)
+        Button.buttons.append(self)
+
+    def draw(self, mouse_x, mouse_y):
+        # draw something to refresh buffer?
+        shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
+        batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
+
+        if is_in_rect(self, Vector((mouse_x, mouse_y))):
+            shader2Dcolor.uniform_float("color", self.bg_color_selected)
+        else:
+            shader2Dcolor.uniform_float("color", self.bg_color)
+        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
+        blf.size(self.font_id, self.font_size, 72)
+        blf.position(self.font_id, self.point_lt.x + 2.5, self.point_rb.y + 2.5, 0)
+        blf.draw(self.font_id, self.text)
+
+    def click(self, args=None):
+        return self.function(args)
+
+view_layers = []
+
+class Border(Rectangle):
+    weight = 5
+
+    def __init__(self, light_image, color):
+        self.color = color
+        self.light_image = light_image
+        super().__init__(Vector((0, 0)), 100, 100)
+
+    def draw(self):
+        shader2Dcolor.uniform_float("color", self.color)
+        batch_for_shader(shader2Dcolor, 'TRI_STRIP', {"pos": self.get_verts()}).draw(shader2Dcolor)
+
+    def get_verts(self):
+        self.point_lt = self.light_image.point_lt.copy()
+        self.point_lt.x -= self.weight
+        self.point_lt.y += self.weight
+
+        self.point_rb = self.light_image.point_rb.copy()
+        self.point_rb.x += self.weight
+        self.point_rb.y -= self.weight
+        
+        self.rot = self.light_image.rot
+
+        return super().get_verts()
+
+
+class LightImage(Rectangle):
+    selected_object = None
+    lights = []
+    @classmethod
+    def find_idx(cls, bls_light_collection):
+        for idx, l in enumerate(cls.lights):
+            if l._collection == bls_light_collection:
+                return idx
+        return -1
+    @classmethod
+    def remove(cls, bls_light_collection):
+        del cls.lights[cls.find_idx(bls_light_collection)]
+
+    def delete(self):
+        del LightImage.lights[LightImage.lights.index(self)]
+    
+    @classmethod
+    def refresh(cls):
+        cls.selected_object = None
+        for l in cls.lights:
+            try:
+                if l.update_from_bls():
+                    l.update_visual_location()
+            except ReferenceError:
+                l.delete()
+            
+    
+    default_size = 100
+    @classmethod
+    def change_default_size(cls, value):
+        cls.default_size = value
+        for l in cls.lights:
+            l.width = value
+            l.height = value
+        
+    def panel_loc_to_area_px_lt(self):
+        panel_px_loc = Vector((self.panel.width * self.panel_loc.x, -self.panel.height * (1-self.panel_loc.y)))
+        return panel_px_loc + self.panel.point_lt - Vector((LightImage.default_size*self._scale.y/2, LightImage.default_size*self._scale.z/2))
+    
+    def _update_panel_loc(self):
+        self.panel_loc.x = (self._bls_rot.x + pi) % (2*pi) / (2*pi)
+        self.panel_loc.y = fmod(self._bls_rot.y + pi/2, pi) / (pi)
+
+    def update_from_bls(self):
+        if self._bls_mesh.select_get():
+            LightImage.selected_object = self
+
+        updated = False
+        if self._bls_rot != self._bls_actuator.rotation_euler:
+            updated |= True
+            self._bls_rot = self._bls_actuator.rotation_euler.copy()
+        if self.rot != self._bls_mesh.rotation_euler.x:
+            updated |= True
+            self.rot = self._bls_mesh.rotation_euler.x
+        if self._scale != self._bls_mesh.scale:
+            updated |= True
+            self._scale = self._bls_mesh.scale.copy()
+            self.width = LightImage.default_size * self._scale.y
+            self.height = LightImage.default_size * self._scale.z
+        
+        if updated:
+            self._update_panel_loc()
+
+        if self._image_path != self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath:
+            updated |= True
+            self.image = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image
+            self._image_path = self._bls_mesh.active_material.node_tree.nodes["Light Texture"].image.filepath
+        # this should run when image changes but sometimes Blender looses images... so it's run every time to be safe
+        if self.image.gl_load():
+            raise Exception
+        
+
+        return updated
+
+    def update_bls(self):
+        self._bls_actuator.rotation_euler = self._bls_rot
+        self._bls_mesh.rotation_euler.x = self.rot
+
+    def __init__(self, context, panel, bls_light_collection):
+        self.panel = panel
+        self.__panel_loc = Vector((.5, .5))
+
+        self._collection = bls_light_collection
+        self._bls_mesh = [m for m in bls_light_collection.objects if m.name.startswith("BLS_LIGHT_MESH")][0]
+        self._bls_actuator = self._bls_mesh.parent
+        self._view_layer = find_view_layer(self._collection, context.view_layer.layer_collection)
+        
+        self._image_path = ""
+        self._bls_rot = None
+        self._scale = None
+
+        super().__init__(Vector((0,0)), LightImage.default_size, LightImage.default_size)
+        self.update_from_bls()
+        self.update_visual_location()
+        
+        LightImage.lights.append(self)
+
+        self.mute_border = Border(self, (.7, 0, 0, 1))
+        self.select_border = Border(self, (.2, .9, .2, 1))
+        self.select_border.weight = 2
+    
+    @property
+    def mute(self):
+        return self._view_layer.exclude
+    
+    @mute.setter
+    def mute(self, value):
+        self._view_layer.exclude = value
+
+    @property
+    def panel_loc(self):
+        return self.__panel_loc
+    
+    @panel_loc.setter
+    def panel_loc(self, pos):
+        self.__panel_loc = pos
+        self._bls_rot = Vector((
+            (self.panel_loc.x -.5) * (2*pi),
+            (self.panel_loc.y -.5) * (pi),
+            self._bls_rot.z
+        ))
+        self.update_visual_location() # update self.loc
+
+    def select(self):
+        if self.mute:
+            return
+        bpy.ops.object.select_all(action='DESELECT')
+        bpy.context.view_layer.objects.active = self._bls_mesh
+        self._bls_mesh.select_set(True)
+
+    def draw(self):
+        try:
+            select = self._bls_mesh.select_get()
+        except ReferenceError:
+            return
+        
+        # draw something to refresh buffer?
+        shader2Dcolor.uniform_float("color", (0, 0, 0, 0))
+        batch_for_shader(shader2Dcolor, 'POINTS', {"pos": [(0,0), ]}).draw(shader2Dcolor)
+        
+        if self.mute:
+            self.mute_border.draw()
+        if select:
+            self.select_border.draw()
+
+        bgl.glActiveTexture(bgl.GL_TEXTURE0)
+        bgl.glBindTexture(bgl.GL_TEXTURE_2D, self.image.bindcode)
+        shader2Dtexture.uniform_int("image", 0)
+
+        batch_for_shader(
+            shader2Dtexture, 'TRI_STRIP',
+            {
+                "pos": self.get_verts(),
+                "texCoord": self.get_tex_coords(),
+            }
+        ).draw(shader2Dtexture)
+
+    def update_visual_location(self):
+        self.loc = self.panel_loc_to_area_px_lt() + Vector((self.width/2, self.height/2))
+
+    def move(self, loc_diff):
+        super().move(loc_diff)
+
+        self.panel_loc = Vector((
+            (self.loc.x-self.panel.loc.x) / self.panel.width +.5,
+            clamp(0.0001, (self.loc.y-self.panel.loc.y) / self.panel.height +.5, 0.9999),
+        ))
+
+        self.update_bls()
+
+def is_in_rect(rect, loc):
+    return (loc.x >= rect.point_lt.x and loc.x <= rect.point_rb.x) and (loc.y >= rect.point_rb.y and loc.y <= rect.point_lt.y)
+
+def clamp(minimum, x, maximum):
+    return max(minimum, min(x, maximum))
+
+class ClickManager:
+    def __init__(self):
+        self.times = [0, 0, 0]
+        self.objects = [None, None, None]
+    
+    def click(self, object):
+        self.times.append(time.time())
+        self.objects.append(object)
+        if len(self.times) > 3:
+            del self.times[0]
+            del self.objects[0]
+        
+        if self.objects[0] == self.objects[1] == self.objects[2]:
+            if self.times[2] - self.times[0] <= .5:
+                return "TRIPLE"
+        if self.objects[1] == self.objects[2]:
+            if self.times[2] - self.times[1] <= .5:
+                return "DOUBLE"
+
+class MouseWidget:
+    mouse_x: bpy.props.IntProperty()
+    mouse_y: bpy.props.IntProperty()
+    
+    def __init__(self):
+        self._start_position = Vector((0, 0))
+        self._end_position = Vector((0, 0))
+        self._reference_end_position = Vector((0, 0))
+        self._base_rotation = 0
+        self.handler = None
+
+        self.draw_guide = True
+
+        self.allow_xy_keys = False
+        self.x_key = False
+        self.y_key = False
+
+        self.continous = False
+
+        self.allow_precision_mode = False
+        self.precision_mode = False
+        self.precision_offset = Vector((0,0))
+
+    def invoke(self, context, event):
+        mouse_x = event.mouse_x - context.area.x
+        mouse_y = event.mouse_y - context.area.y
+
+        self._start_position = Vector((self.mouse_x, self.mouse_y))
+        self._end_position = Vector((mouse_x, mouse_y))
+        self._reference_end_position = self._end_position
+        vec = self._end_position - self._start_position
+        self._base_rotation = atan2(vec.y, vec.x)
+
+        self.handler = bpy.types.SpaceView3D.draw_handler_add(self._draw, (context, event,), 'WINDOW', 'POST_PIXEL')
+        context.window_manager.modal_handler_add(self)
+
+    def _cancel(self, context, event): pass
+    def _finish(self, context, event): pass
+
+    def modal(self, context, event):
+        # print(event.type, event.value)
+        if not context.area:
+            self._unregister_handler()
+            self._cancel(context, event)
+            return {"CANCELLED"}
+
+        if event.type in {"ESC", "RIGHTMOUSE"}:
+            self._unregister_handler()
+            self._cancel(context, event)
+            return {'CANCELLED'}
+
+        if event.type == "RET" or (not self.continous and event.type == "LEFTMOUSE"):
+            self._unregister_handler()
+            self._finish(context, event)
+            return {'FINISHED'}
+
+        if self.continous and event.value == "RELEASE" and event.type == "LEFTMOUSE":
+            self._unregister_handler()
+            self._finish(context, event)
+            return {'FINISHED'}
+
+        self.mouse_x = event.mouse_x - context.area.x
+        self.mouse_y = event.mouse_y - context.area.y
+        self._end_position = Vector((self.mouse_x, self.mouse_y))
+        
+        if self.allow_xy_keys:
+            if event.value == "PRESS":
+                if event.type == "X":
+                    self.x_key = not self.x_key
+                    self.y_key = False
+                if event.type == "Y":
+                    self.y_key = not self.y_key
+                    self.x_key = False
+
+        if self.allow_precision_mode and event.value == "PRESS" and event.type == "LEFT_SHIFT":
+            self.precision_mode = True
+            self._precision_mode_mid_stop = self._end_position.copy()
+        elif self.allow_precision_mode and event.value == "RELEASE" and event.type == "LEFT_SHIFT" and self.precision_mode: #last condition in case when operator invoked with shift already pressed
+            self.precision_mode = False
+            self.precision_offset += self._end_position - self._precision_mode_mid_stop
+
+        return self._modal(context, event)
+
+    def __del__(self):
+        self._unregister_handler()
+
+    def _unregister_handler(self):
+        try:
+            bpy.types.SpaceView3D.draw_handler_remove(self.handler, 'WINDOW')
+        except ValueError:
+            pass
+    
+    def length(self):
+        return (self._start_position - self._reference_end_position - self.delta_vector()).length
+    
+    def delta_vector(self):
+        if self.precision_mode:
+            return self._precision_mode_mid_stop - self._reference_end_position - self.precision_offset*.9 + (self._end_position - self._precision_mode_mid_stop) * .1
+        return self._end_position - self._reference_end_position - self.precision_offset*.9
+    
+    def delta_length_factor(self):
+        return self.length() / ((self._start_position - self._reference_end_position).length)
+
+    def angle(self):
+        vec = self._reference_end_position - self._start_position + self.delta_vector() + self.precision_offset*.9
+        return atan2(vec.y, vec.x) - self._base_rotation
+
+    def _draw(self, context, event):
+        # first draw to reset buffer
+        shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
+        batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0,0), (0,0))}).draw(shader2Dcolor)
+        
+        if self.draw_guide:
+            shader2Dcolor.uniform_float("color", (.5, .5, .5, .5))
+            batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position[:]), (self._end_position[:]))}).draw(shader2Dcolor)
+
+        if self.allow_xy_keys:
+            if self.x_key:
+                shader2Dcolor.uniform_float("color", (1, 0, 0, .5))
+                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((0, self._start_position.y), (context.area.width, self._start_position.y))}).draw(shader2Dcolor)
+            elif self.y_key:
+                shader2Dcolor.uniform_float("color", (0, 1, 0, .5))
+                batch_for_shader(shader2Dcolor, 'LINES', {"pos": ((self._start_position.x, 0), (self._start_position.x, context.area.height))}).draw(shader2Dcolor)
\ No newline at end of file
diff --git a/src/selectOperator.py b/src/selectOperator.py
index 358cf6e..88e172f 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -8,13 +8,13 @@ class SelectionOperator(bpy.types.Operator):
     bl_label = "Custom selection"
     bl_options = {"UNDO", "UNDO_GROUPED"}
 
-    extend = BoolProperty(default = False)
-    deselect = BoolProperty(default = False)
-    toggle = BoolProperty(default = False)
-    center = BoolProperty(default = False)
-    enumerate = BoolProperty(default = False)
-    object = BoolProperty(default = False)
-    location = IntVectorProperty(default = (0,0),subtype ='XYZ', size = 2)
+    extend: BoolProperty(default = False)
+    deselect: BoolProperty(default = False)
+    toggle: BoolProperty(default = False)
+    center: BoolProperty(default = False)
+    enumerate: BoolProperty(default = False)
+    object: BoolProperty(default = False)
+    location: IntVectorProperty(default = (0,0),subtype ='XYZ', size = 2)
 
     @classmethod
     def poll(cls, context):
@@ -127,9 +127,7 @@ def add_shortkeys():
     
     addon_keymaps.append(addon_km)
     
-def remove_shortkeys():
-    wm = bpy.context.window_manager
-        
+def remove_shortkeys():        
     for km in addon_keymaps:
         for kmi in addin_kmis:
             km.keymap_items.remove(kmi)
diff --git a/src/texs/ramp_A.tif b/src/texs/ramp_A.tif
deleted file mode 100644
index d3d163a..0000000
Binary files a/src/texs/ramp_A.tif and /dev/null differ
diff --git a/src/texs/ramp_B.tif b/src/texs/ramp_B.tif
deleted file mode 100644
index 337deeb..0000000
Binary files a/src/texs/ramp_B.tif and /dev/null differ
diff --git a/src/texs/ramp_C.tif b/src/texs/ramp_C.tif
deleted file mode 100644
index 9bca620..0000000
Binary files a/src/texs/ramp_C.tif and /dev/null differ
diff --git a/src/texs/ramp_CUT.tif b/src/texs/ramp_CUT.tif
deleted file mode 100644
index e2ade47..0000000
Binary files a/src/texs/ramp_CUT.tif and /dev/null differ
diff --git a/src/window_operations.py b/src/window_operations.py
deleted file mode 100644
index 73dff7e..0000000
--- a/src/window_operations.py
+++ /dev/null
@@ -1,90 +0,0 @@
-import bpy
-
-# original source https://github.com/dustractor/ui_teardown_recreate
-
-def get_mergables(areas):
-    xs,ys = dict(),dict()
-    for a in areas:
-        xs[a.x] = a
-        ys[a.y] = a
-    for area in reversed(areas):
-        tx = area.x + area.width + 1
-        ty = area.y + area.height + 1
-        if tx in xs and xs[tx].y == area.y and xs[tx].height == area.height:
-            return area,xs[tx]
-        elif ty in ys and ys[ty].x == area.x and ys[ty].width == area.width:
-            return area,ys[ty]
-    return None,None
-
-def teardown(context):
-    while len(context.screen.areas) > 1:
-        a,b = get_mergables(context.screen.areas)
-        if a and b:
-            bpy.ops.screen.area_join(min_x=a.x,min_y=a.y,max_x=b.x,max_y=b.y)
-            area = context.screen.areas[0]
-            region = area.regions[0]
-            blend_data = context.blend_data
-            bpy.ops.screen.screen_full_area(dict(screen=context.screen,window=context.window,region=region,area=area,blend_data=blend_data))
-            bpy.ops.screen.back_to_previous(dict(screen=context.screen,window=context.window,region=region,area=area,blend_data=blend_data))
-
-def area_from_ptr(ptr):
-    for screen in bpy.data.screens:
-        for area in screen.areas:
-            if area.as_pointer() == ptr:
-                return area
-
-def split_area(window,screen,region,area,xtype,direction="VERTICAL",factor=0.5,mouse_x=-100,mouse_y=-100):
-    beforeptrs = set(list((a.as_pointer() for a in screen.areas)))
-    bpy.ops.screen.area_split(dict(region=region,area=area,screen=screen,window=window),direction=direction,factor=factor)
-    afterptrs = set(list((a.as_pointer() for a in screen.areas)))
-    newareaptr = list(afterptrs-beforeptrs)
-    newarea = area_from_ptr(newareaptr[0])
-    newarea.type = xtype
-    return newarea
-
-
-def splitV3DtoBLS(context):
-    window = context.window
-    region = context.region
-    screen = context.screen
-    main = context.area
-    
-    main.type = "INFO"
-    
-    ctrlPanel = split_area(window,screen,region,main,"VIEW_3D",direction="HORIZONTAL",factor=0.3)
-    ctrlPanel.spaces[0].lock_camera_and_layers = False
-    ctrlPanel.spaces[0].layers = [False]*19 + [True]
-    ctrlPanel.spaces[0].show_relationship_lines
-    ctrlPanel.spaces[0].viewport_shade = 'MATERIAL'
-    
-    override = {'window': window, 'screen': screen, 'area': ctrlPanel, 'region': ctrlPanel.regions[2], 'scene': context.scene}
-    if ctrlPanel.spaces[0].region_3d.is_perspective: bpy.ops.view3d.view_persportho(override)
-    bpy.ops.view3d.viewnumpad(override, type = 'TOP')
-    
-    #nodeEditor = split_area(window,screen,region,ctrlPanel,"NODE_EDITOR",direction="VERTICAL",factor=0.51)
-    
-    main.type = "VIEW_3D"
-    
-    
-    
-'''
-def test_contains(bounds,point):
-    ax,ay,bx,by = bounds
-    x,y = point
-    return (ax <= x <= bx) and (ay <= y <= by)
-def example_layout(context):
-    window = context.window
-    region = context.region
-    screen = context.screen
-    main = context.screen.areas[0]
-    main.type = "TEXT_EDITOR"
-    info = split_area(window,screen,region,main,"INFO",direction="HORIZONTAL",factor=0.99)
-    properties = split_area(window,screen,region,main,"PROPERTIES",direction="VERTICAL",factor=0.85)
-    timeline = split_area(window,screen,region,main,"TIMELINE",direction="HORIZONTAL",factor=0.1)
-    v3d = split_area(window,screen,region,main,"VIEW_3D",direction="VERTICAL",factor=0.7)
-    lightPanel = split_area(window,screen,region,v3d,"VIEW_3D",direction="HORIZONTAL",factor=0.3)
-    lightPanel.spaces[0].lock_camera_and_layers = False
-    #split2 = split_area(window,screen,region,other,"NODE_EDITOR",direction="HORIZONTAL",factor=0.6)
-    #split3 = split_area(window,screen,region,other,"IMAGE_EDITOR",direction="VERTICAL",factor=0.7)
-    #split4 = split_area(window,screen,region,other,"VIEW_3D",direction="VERTICAL",factor=0.7)
-'''

commit 08b6425b214bd3d3171d0e5f59c65b02ae9c3fa1
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Jan 6 10:23:06 2020 -0800

    Update README.md

diff --git a/README.md b/README.md
index ae34f61..095caff 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,3 @@
-# Light Studio plugin for Blender
+# LeoMoon LightStudio plugin for Blender
 ## More Info / Download
 https://leomoon.com/downloads/plugins/leomoon-lightstudio/

commit 4fe80c0d192c5af48dc856960823492c2c3b15eb
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Jan 6 10:09:16 2020 -0800

    Update README.md

diff --git a/README.md b/README.md
index 514608a..ae34f61 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,3 @@
 # Light Studio plugin for Blender
 ## More Info / Download
-https://leomoon.com/downloads/plugins/blender-light-studio/
+https://leomoon.com/downloads/plugins/leomoon-lightstudio/

commit 73ce5f8511ba7dc965cd66507b6999b6b90b5227
Author: Amin Persia <leomoon@gmail.com>
Date:   Mon Jan 6 10:08:04 2020 -0800

    re-branded to LeoMoon LightStudio

diff --git a/src/__init__.py b/src/__init__.py
index 45a4132..a0d5356 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -1,27 +1,9 @@
-'''
-Copyright (C) 2015 Marcin Zielinski
-martin.zielinsky at gmail.com
-
-Created by Marcin Zielinski
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-'''
+#Created by Striam Sp. z o.o.
 
 bl_info = {
-    "name": "Blender Light Studio",
+    "name": "LeoMoon LightStudio",
     "description": "Easy setup for complex studio lighting",
-    "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
+    "author": "LeoMoon Studios",
     "version": (2, 3, 11),
     "blender": (2, 79, 0),
     "location": "View3D -> Tools -> Light Studio",
@@ -76,4 +58,4 @@ def unregister():
     except: traceback.print_exc()
     
     print("Unregistered {}".format(bl_info["name"]))
-    
\ No newline at end of file
+    

commit 15bdd0750f18ad0dcd4bbd1beac836f78eab64f6
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Nov 23 19:46:57 2018 -0800

    blender version changed to 2.79

diff --git a/src/__init__.py b/src/__init__.py
index 314201c..45a4132 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -23,7 +23,7 @@ bl_info = {
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
     "version": (2, 3, 11),
-    "blender": (2, 78, 0),
+    "blender": (2, 79, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
     "category": "User Interface" }

commit c057e265b9d4a62a9d0555efa09cad53451dd3df
Merge: d2e78bf ba1df81
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Nov 23 19:44:23 2018 -0800

    Merge pull request #14 from leomoon-studios/dev
    
    Dev

commit ba1df8120c27bb908eb0394df846f3e3061efbb5
Merge: 2561c38 d2e78bf
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Nov 23 19:44:01 2018 -0800

    Merge branch 'master' into dev

commit 2561c381be34da7ecf64a59351499f1a12e420ac
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Nov 23 19:35:12 2018 -0800

    readme change

diff --git a/README.md b/README.md
index 71db2c9..514608a 100644
--- a/README.md
+++ b/README.md
@@ -1,108 +1,3 @@
 # Light Studio plugin for Blender
-## Introduction
-Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptaszynski and inspired by HDR Light Studio 5 lighting system.
-
-[![Light Studio plugin for Blender](http://img.youtube.com/vi/I6KVYMLFR98/0.jpg)](https://www.youtube.com/watch?v=I6KVYMLFR98)
-
-## Features
-  - Add/Remove lights around objects (0,0,0)
-  - Add unlimited number of lights
-  - Each light has options like intensity, color, scale, distance, etc.
-  - Easy 2D manipulation of light which translates to 3D positioning of light
-  - Realistic HDR light textures included
-  - Each light can have different light texture
-  - Toggle lights
-  - Isolate light
-  - Lights are selectable to use render layers
-  - 3D Edit operator - interactive light placement and adjustment:
-	- Click on object to reposition light in one of two modes: reflection or normal [N].
-	- [S] Scale light mesh
-	- [G] Grab (meant to be used in rendered preview)
-	- [R] Rotate
-  - Import/Export of light profiles
-
-## Donations
-The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
-
-## Funded by
-  - LeoMoon Studios
-
-## Donors
-  - Damir Simovski
-  - Krzysztof Czerwiski x2
-  - Paul Kotelevets
-
-## Programmers
-  - Marcin Zielinski
-
-## Prototype and Initial Scene by
-  - Maciek Ptaszynski
-
-## Changelog
-  - 2.3.5:
-    - Bugfix
-  - 2.3.4:
-    - Bugfix for left-click selection
-  - 2.3.3:
-    - Bugfix (light scale and rotation not exporting, profiles not copying correctly)
-    - Button to easily fix broken texture paths
-  - 2.3.2:
-    - Fix for left-click selection
-  - 2.3.1:
-    - Import/Export profiles
-  - 2.3.0:
-    - 3D Edit (first iteration of Light Brush)
-    - Bugfixes
-  - 2.2.1:
-    - Added Blender 2.78 support
-  - 2.1:
-    - Added the ability to delete lights like other objects
-    - Added more HDR lights
-    - Added light previews
-    - All HDR lights now have transparency
-    - GUI changes
-    - Bug fixes
-  - 2.0.1:
-    - Added Light Profiles feature
-	- Added light preview for each light
-  - 1.2.3:
-    - Solved Linux problems
-  - 1.2.2:
-    - Linux paths bugfix
-    - Control plane highlights when new light added
-  - 1.2.1:
-    - Minor bugfix
-  - 1.2.0:
-    - Protection from accidental deletion
-    - Light objects made selectable
-    - Control plane lights up when corresponding light object is selected, and vice versa
-  - 1.1.1:
-    - Added Light visibility toggles
-    - Added Light Distance option
-  - 1.1.0: 
-    - Automatically switch to cycles after clicking "Prepare Light Studio"
-  - 1.0.1:
-    - Some fixes
-  - 1.0.0:
-    - Beta release
-
-## How to install
-  - 01: Download "[Blender Light Studio](https://leomoon.com/projects/plugins/blender-light-studio/)"
-  - 02: Open Blender and go to File -> User Preferences... -> Addons
-  - 03: Click on "Install from File..." and select "blender-light-studio.zip"
-  - 04: After installation, the new plugin should show up and you can enable it
-    - If it doesn't, search for "studio" and enable the plugin
-  - 06: Close "User Preferences..."
-  - 07: Go to the new tab called "Light Studio"
-  - 08: Click on "Create Light Studio"
-  - 09: Click on "Prepare Layout"
-  - 10: Start adding lights by clicking "Add Light" and moving them around using the new split viewport
-  - 11: Use the options for the selected light and light your scene
-  - 12: Happy Blending!
-
-## Future Ideas
-  - Copy profile to scene (internal) operator
-  - Add ability to export (render) the light setup as environment texture (Equirectangular Panoramic EXR)
-
-## Compatibility
-Tested with Blender 2.78a
+## More Info / Download
+https://leomoon.com/downloads/plugins/blender-light-studio/

commit 1c032575e573b810c21e85d21aa781db213bdabf
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Sat Nov 24 03:45:52 2018 +0100

    2.3.11
    
    bugfix: profiles

diff --git a/src/__init__.py b/src/__init__.py
index 92d7dcd..314201c 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 6),
+    "version": (2, 3, 11),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
@@ -44,19 +44,28 @@ modules = developer_utils.setup_addon_modules(__path__, __name__, "bpy" in local
 
 import traceback
 
-from . light_operators import Blender_Light_Studio_Properties
+from . light_operators import Blender_Light_Studio_Properties, update_selection_override
 from . import deleteOperator
 from . import selectOperator
 from . import light_preview_list
+
+def config_load():
+    from extensions_framework import util as efutil
+    bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
+    bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)
+    
+    update_selection_override()
+    
 def register():
     try: bpy.utils.register_module(__name__)
     except: traceback.print_exc()
     bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
     bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
-    selectOperator.add_shortkeys()
     deleteOperator.add_shortkeys()
+    config_load() # select operator shortkeys
     light_preview_list.register()
     
+    
     print("Registered {} with {} modules".format(bl_info["name"], len(modules)))
     
 
diff --git a/src/common.py b/src/common.py
index 56f006b..d203267 100644
--- a/src/common.py
+++ b/src/common.py
@@ -48,9 +48,13 @@ def getLightController():
 
 
 def findLightProfile(ob):
+    if ob.name.startswith('BLS_PROFILE'):
+        return ob
+    
     while ob.parent:
         ob = ob.parent
         if ob.name.startswith('BLS_PROFILE'): return ob
+        
     return None
 
 def getLightHandle(ob=None):
diff --git a/src/gui.py b/src/gui.py
index 7c3dde6..b109b40 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -147,7 +147,10 @@ class BLS_ProfileImportExport(bpy.types.Panel):
         col.operator('bls_list.export_profiles', text="Export Selected Profile")
         col.operator('bls_list.export_profiles', text="Export All Profiles").all=True
         col.operator('bls_list.import_profiles')
-        
+
+from extensions_framework import util as efutil
+from . import bl_info
+
 class BLS_Misc(bpy.types.Panel):
     bl_idname = "bls_misc"
     bl_label = "Misc"
@@ -157,7 +160,7 @@ class BLS_Misc(bpy.types.Panel):
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.BLStudio.initialized
                 
     def draw(self, context):
         layout = self.layout
@@ -168,9 +171,9 @@ class BLS_Misc(bpy.types.Panel):
         col = layout.column(align=True)
         col.operator('bls.find_missing_textures')
         
-        if context.user_preferences.inputs.select_mouse == 'LEFT':
-            box = layout.box()
-            col = box.column()
-            col.label("Disable in case of problems")
-            col.label("using manipulators")
-            col.prop(props, 'selection_overriden')   
\ No newline at end of file
+        box = layout.box()
+        col = box.column()
+        col.label("Disable in case of problems")
+        col.label("eg. using manipulators")
+        col.prop(props, 'selection_overriden')
+        
\ No newline at end of file
diff --git a/src/light_brush.py b/src/light_brush.py
index ffd357a..5bdb40f 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -91,11 +91,12 @@ def raycast(context, event, diff):
     #####
     profile = findLightGrp(controller).parent
     handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
+    lightmesh = getLightMesh()
     position = intersect_line_sphere(
         location - handle.location,
         (normal if diff else view_vector.reflect(normal)) + location - handle.location,
         Vector((0,0,0)),
-        context.scene.BLStudio.light_radius,
+        lightmesh.location.x,
         False,
         )[0]
     
diff --git a/src/light_operators.py b/src/light_operators.py
index 7c28d54..47e65f1 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -7,6 +7,22 @@ import os
 
 _ = os.sep
 
+from extensions_framework import util as efutil
+from . import bl_info
+
+def update_selection_override():
+    from . selectOperator import addon_keymaps
+    keylen = bool(len(addon_keymaps))
+    
+    selection_override = bpy.bls_selection_override_right if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT' else bpy.bls_selection_override_left
+    if keylen != selection_override:
+        from . selectOperator import add_shortkeys, remove_shortkeys
+        if selection_override:
+            add_shortkeys()
+        else:
+            remove_shortkeys()
+    return selection_override
+    
 class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     initialized = BoolProperty(default = False)
             
@@ -23,17 +39,34 @@ class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     light_muted = BoolProperty(name="Mute Light", default=False, set=set_light_hidden, get=get_light_hidden)
     
     def get_selection_overriden(self):
-        from . selectOperator import addon_keymaps
-        #print(addon_keymaps)
-        return len(addon_keymaps)
+        if not (hasattr(bpy, 'bls_selection_override_left') and hasattr(bpy, 'bls_selection_override_right')):
+            bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)
+            bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
+        
+        return update_selection_override()
+    
     def set_selection_overriden(self, context):
         from . selectOperator import add_shortkeys, remove_shortkeys
         if context:
             add_shortkeys()
         else:
             remove_shortkeys()
+        
+        if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT':
+            bpy.bls_selection_override_right = context
+            efutil.write_config_value(bl_info['name'], 'defaults', 'selection_override_right', context)
+        else:
+            bpy.bls_selection_override_left = context
+            efutil.write_config_value(bl_info['name'], 'defaults', 'selection_override_left', context)
+        
             
-    selection_overriden = BoolProperty(name="Override Selection", default=True, set=set_selection_overriden, get=get_selection_overriden)
+    selection_overriden = BoolProperty(
+        name="Override Selection",
+        default = True,
+        set=set_selection_overriden,
+        get=get_selection_overriden
+    )
+    
     
     ''' Profile List '''
     profile_list = CollectionProperty(type = ListItem)
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 1e531aa..fa63968 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -1,5 +1,5 @@
 import bpy
-from bpy.props import StringProperty, PointerProperty, FloatProperty, EnumProperty
+from bpy.props import BoolProperty, StringProperty, PointerProperty, FloatProperty, EnumProperty
 import os
 from . common import isFamily, family, findLightGrp, getLightHandle
 from itertools import chain
@@ -39,6 +39,8 @@ class LIST_OT_NewItem(bpy.types.Operator):
     bl_idname = "bls_list.new_profile"
     bl_label = "Add a new Profile"
     bl_options = {"INTERNAL"}
+    
+    handle = BoolProperty(default=True)
 
     def execute(self, context):
         props = context.scene.BLStudio
@@ -77,23 +79,25 @@ class LIST_OT_NewItem(bpy.types.Operator):
         
         item.empty_name = profile.name
         
-        bpy.ops.object.empty_add(type='PLAIN_AXES', radius=1, view_align=False, location=(0, 0, 0), layers=(True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
-        handle = context.active_object
-        handle.parent = profile
-        handle.name = "BLS_HANDLE"
-        handle.protected = True
-        handle['last_layers'] = handle.layers[:]
-        handle.empty_draw_type = 'SPHERE'
+        handle = None
+        if self.handle:
+            bpy.ops.object.empty_add(type='PLAIN_AXES', radius=1, view_align=False, location=(0, 0, 0), layers=(True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
+            handle = context.active_object
+            handle.name = "BLS_HANDLE"
+            handle.empty_draw_type = 'SPHERE'
+            handle.parent = profile
+            handle.protected = True
+            handle.use_fake_user = True
+            handle['last_layers'] = handle.layers[:]
         
         #if len([prof for prof in profile.parent.children if prof.name.startswith('BLS_PROFILE.')]) > 1:
         if len([prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)]) > 1:
             #profile already exists
             context.scene.objects.unlink(profile)
-            context.scene.objects.unlink(handle)
+            if handle: context.scene.objects.unlink(handle)
         else:
             #init last_empty for first profile
             props.last_empty = profile.name
-        
 
         return{'FINISHED'}
 
@@ -181,7 +185,7 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         # whats the difference
         new_objects = (A ^ B)
         
-        # make light material single user and update selection drivers
+        # make light material single user and update selection drivers]
         bpy.ops.group.objects_remove_all()
         bpy.ops.group.create(name='BLS_Light')
         
@@ -219,13 +223,14 @@ class LIST_OT_CopyItem(bpy.types.Operator):
             ob.hide_select = True
             
             if ob.name.startswith('BLS_LIGHT_MESH.') or \
+               ob.name.startswith('BLS_HANDLE') or \
                ob.name.startswith('BLS_CONTROLLER.'):
                 ob.hide = False
                 ob.hide_select = False
                 
         profileName = props.profile_list[props.list_index].name
         
-        bpy.ops.bls_list.new_profile()
+        bpy.ops.bls_list.new_profile(handle=False)
         lastItemId = len(props.profile_list)-1
         
         # parent objects to new profile
@@ -233,6 +238,9 @@ class LIST_OT_CopyItem(bpy.types.Operator):
             scene.objects.unlink(ob)
             if ob.name.startswith('BLS_LIGHT_GRP.'):
                 ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
+            elif ob.name.startswith('BLS_HANDLE.'):
+                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
+                
             
         props.profile_list[len(props.profile_list)-1].name = profileName + ' Copy'
         
@@ -316,7 +324,10 @@ def update_list_index(self, context):
     if context.scene.objects.find(props.last_empty) > -1: # in case of update after deletion
         for ob in family(context.scene.objects[props.last_empty]):
             ob['last_layers'] = ob.layers[:]
-            context.scene.objects.unlink(ob)
+            try:
+                context.scene.objects.unlink(ob)
+            except Exception:
+                print('Warning: Light Studio Profile corrupted. Handle with care!')
         
     #link selected profile
     for ob in family(bpy.data.objects[selected_profile.empty_name]):
@@ -333,7 +344,8 @@ import json, time
 script_file = os.path.realpath(__file__)
 dir = os.path.dirname(script_file)
 
-def parse_profile(context, props, profiles, internal_copy=False):
+VERSION = 1.01
+def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
     plist = props.profile_list
     for profile in profiles:
         print(profile)
@@ -346,6 +358,12 @@ def parse_profile(context, props, profiles, internal_copy=False):
 
         #lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
         profile_empty = context.scene.objects[plist[-1].empty_name]
+        
+        if version > 1:
+            handle = getLightHandle(profile_empty)    
+            handle.location.x = profile['handle_position'][0]
+            handle.location.y = profile['handle_position'][1]
+            handle.location.z = profile['handle_position'][2]
 
         for light in profile["lights"]:
             # before
@@ -365,11 +383,6 @@ def parse_profile(context, props, profiles, internal_copy=False):
             controller.location.y = light['position'][1]
             controller.location.z = light['position'][2]
             
-            handle = getLightHandle(controller)
-            handle.location.x = light['handle_position'][0]
-            handle.location.y = light['handle_position'][1]
-            handle.location.z = light['handle_position'][2]
-            
             controller.scale.x = light['scale'][0]
             controller.scale.y = light['scale'][1]
             controller.scale.z = light['scale'][2]
@@ -410,7 +423,7 @@ class ImportProfiles(bpy.types.Operator):
         f.closed
         
         file = json.loads(file)
-        parse_profile(context, props, file["profiles"])
+        parse_profile(context, props, file["profiles"], float(file["version"]))
  
         return{'FINISHED'}
     
@@ -424,16 +437,17 @@ def compose_profile(list_index):
     profile_dict = {}
     profile_dict['name'] = props.profile_list[list_index].name
     profile_dict['lights']= []
-    lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
-    print(lgroups)
+    profile = bpy.data.objects[props.profile_list[list_index].empty_name]
+    lgroups = [lg for lg in family(profile) if "BLS_LIGHT_GRP" in lg.name]
+    handle = getLightHandle(profile)
+    print(profile, handle)
+    profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
     for lg in lgroups:
         controller = [c for c in family(lg) if "BLS_CONTROLLER" in c.name][0]
         lmesh = [l for l in family(lg) if "BLS_LIGHT_MESH" in l.name][0]
         light = {}
         light['radius'] = lmesh.location.x
         light['position'] = [controller.location.x, controller.location.y, controller.location.z]
-        handle = getLightHandle(lg)
-        light['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
         light['scale'] = [controller.scale.x, controller.scale.y, controller.scale.z]
         light['rotation'] = controller.rotation_euler.z
         light['mute'] = props.light_muted
@@ -472,18 +486,20 @@ class ExportProfiles(bpy.types.Operator):
         export_file = {}
         date = time.localtime()
         export_file['date'] = '{}-{:02}-{:02} {:02}:{:02}'.format(date.tm_year, date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
-        export_file['version'] = '1'
+        export_file['version'] = VERSION
         profiles_to_export = export_file['profiles'] = []
         
         if self.all:
             for p in range(len(props.profile_list)):
-                profiles_to_export.append(compose_profile(p))
+                try:
+                    profiles_to_export.append(compose_profile(p))
+                except Exception:
+                    self.report({'WARNING'}, 'Malformed profile %s. Omitting.' % props.profile_list[p].name)
         else:
-            profiles_to_export.append(compose_profile(index))
-        
-        #file = open(self.filepath, 'w')
-        #file.write(json.dumps(export_file, indent=4))
-        #file.close()
+            try:
+                profiles_to_export.append(compose_profile(index))
+            except Exception:
+                self.report({'WARNING'}, 'Malformed profile %s. Omitting.' % props.profile_list[index].name)
         
         with open(self.filepath, 'w') as f:
             f.write(json.dumps(export_file, indent=4))
diff --git a/src/selectOperator.py b/src/selectOperator.py
index fa84025..358cf6e 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -6,6 +6,7 @@ class SelectionOperator(bpy.types.Operator):
     """ Custom selection """
     bl_idname = "view3d.select_custom" 
     bl_label = "Custom selection"
+    bl_options = {"UNDO", "UNDO_GROUPED"}
 
     extend = BoolProperty(default = False)
     deselect = BoolProperty(default = False)

commit d2e78bf6b0cb5651a23bb46fe7422c8b81766108
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Mon Sep 24 20:19:53 2018 +0200

    v2.3.10
    bugfix

diff --git a/src/__init__.py b/src/__init__.py
index 05ecaf1..8b431b4 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 9),
+    "version": (2, 3, 10),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
diff --git a/src/selectOperator.py b/src/selectOperator.py
index fa84025..358cf6e 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -6,6 +6,7 @@ class SelectionOperator(bpy.types.Operator):
     """ Custom selection """
     bl_idname = "view3d.select_custom" 
     bl_label = "Custom selection"
+    bl_options = {"UNDO", "UNDO_GROUPED"}
 
     extend = BoolProperty(default = False)
     deselect = BoolProperty(default = False)

commit 5077528047bbf159c24d215e83967326ef1eacb5
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Thu Mar 22 16:43:26 2018 -0700

    Update README.md

diff --git a/README.md b/README.md
index 819930b..514608a 100644
--- a/README.md
+++ b/README.md
@@ -1,124 +1,3 @@
 # Light Studio plugin for Blender
-## Introduction
-Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptaszynski and inspired by HDR Light Studio 5 lighting system.
-
-[![Light Studio plugin for Blender](http://img.youtube.com/vi/NWPeuJ6I5kc/0.jpg)](https://www.youtube.com/watch?v=NWPeuJ6I5kc)
-
-## Features
-  - Add/Remove lights around objects (0,0,0)
-  - Add unlimited number of lights
-  - Each light has options like intensity, color, scale, distance, etc.
-  - Easy 2D manipulation of light which translates to 3D positioning of light
-  - Realistic HDR light textures included
-  - Each light can have different light texture
-  - Toggle lights
-  - Isolate light
-  - Lights are selectable to use render layers
-  - 3D Edit operator - interactive light placement and adjustment:
-	- Click on object to reposition light in one of two modes: reflection or normal [N].
-	- [S] Scale light mesh
-	- [G] Grab (meant to be used in rendered preview)
-	- [R] Rotate
-  - Import/Export of light profiles
-
-## Donations
-Future development of this project depends on community donations. All proceeds will go towards the development. You can donate using "[THIS LINK](https://www.paypal.me/leomoon)" and make sure to include which project you want to support.
-
-## Funded by
-  - LeoMoon Studios
-
-## Donors
-  - Damir Simovski
-  - Krzysztof Czerwiski x2
-  - Paul Kotelevets
-  - Jacinto Carbajosa Fermoso x2
-  - Tiago Santos
-
-## Programmers
-  - Marcin Zielinski
-
-## Prototype and Initial Scene by
-  - Maciek Ptaszynski
-
-## Changelog
-  - 2.3.9:
-    - Bugfix
-  - 2.3.8:
-    - State of Selection Override is now stored between sessions
-  - 2.3.6:
-    - Added empty for each profile for easy movement
-    - Added copy profile to scene
-    - Added auto refresh light textures
-    - Light distance is animatable now
-    - Fixed left click (partially)
-    - Fixed blend autopacking
-  - 2.3.5:
-    - Bugfix
-  - 2.3.4:
-    - Bugfix for left-click selection
-  - 2.3.3:
-    - Bugfix (light scale and rotation not exporting, profiles not copying correctly)
-    - Button to easily fix broken texture paths
-  - 2.3.2:
-    - Fix for left-click selection
-  - 2.3.1:
-    - Import/Export profiles
-  - 2.3.0:
-    - 3D Edit (first iteration of Light Brush)
-    - Bugfixes
-  - 2.2.1:
-    - Added Blender 2.78 support
-  - 2.1:
-    - Added the ability to delete lights like other objects
-    - Added more HDR lights
-    - Added light previews
-    - All HDR lights now have transparency
-    - GUI changes
-    - Bug fixes
-  - 2.0.1:
-    - Added Light Profiles feature
-	- Added light preview for each light
-  - 1.2.3:
-    - Solved Linux problems
-  - 1.2.2:
-    - Linux paths bugfix
-    - Control plane highlights when new light added
-  - 1.2.1:
-    - Minor bugfix
-  - 1.2.0:
-    - Protection from accidental deletion
-    - Light objects made selectable
-    - Control plane lights up when corresponding light object is selected, and vice versa
-  - 1.1.1:
-    - Added Light visibility toggles
-    - Added Light Distance option
-  - 1.1.0: 
-    - Automatically switch to cycles after clicking "Prepare Light Studio"
-  - 1.0.1:
-    - Some fixes
-  - 1.0.0:
-    - Beta release
-
-## How to install
-  - 01: Download "[Blender Light Studio](https://leomoon.com/downloads/plugins/blender-light-studio/)"
-  - 02: Open Blender and go to File -> User Preferences... -> Addons
-  - 03: Click on "Install from File..." and select "blender-light-studio.zip"
-  - 04: After installation, the new plugin should show up and you can enable it
-    - If it doesn't, search for "studio" and enable the plugin
-  - 06: Close "User Preferences..."
-  - 07: Go to the new tab called "Light Studio"
-  - 08: Click on "Create Light Studio"
-  - 09: Click on "Prepare Layout"
-  - 10: Start adding lights by clicking "Add Light" and moving them around using the new split viewport
-  - 11: Use the options for the selected light and light your scene
-  - 12: Happy Blending!
-
-## Known Issues
-  - In case of problems with left click selection, manipulators or overlapping selection please disable Override Selection checkbox under Misc. panel
-  
-## Future Ideas
-  - Copy profile to scene (internal) operator
-  - Add ability to export (render) the light setup as environment texture (Equirectangular Panoramic EXR)
-
-## Compatibility
-Tested with Blender 2.78a
+## More Info / Download
+https://leomoon.com/downloads/plugins/blender-light-studio/

commit 125aa785c6af6ab7362f690ba7f89b0112bfc01d
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Sun Feb 11 18:38:48 2018 -0800

    Added Tiago Santos to donation list

diff --git a/README.md b/README.md
index 802d1f8..819930b 100644
--- a/README.md
+++ b/README.md
@@ -32,6 +32,7 @@ Future development of this project depends on community donations. All proceeds
   - Krzysztof Czerwiski x2
   - Paul Kotelevets
   - Jacinto Carbajosa Fermoso x2
+  - Tiago Santos
 
 ## Programmers
   - Marcin Zielinski

commit b056ad740936476d6d4f5c53b4ca8db8a37b67ac
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Mon Jan 8 12:12:17 2018 -0800

    Update README.md

diff --git a/README.md b/README.md
index e8fdfd1..802d1f8 100644
--- a/README.md
+++ b/README.md
@@ -22,7 +22,7 @@ Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptas
   - Import/Export of light profiles
 
 ## Donations
-Future development of this project depends on community donations. All proceeds will go towards the development. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)" and make sure to include which project you want to support.
+Future development of this project depends on community donations. All proceeds will go towards the development. You can donate using "[THIS LINK](https://www.paypal.me/leomoon)" and make sure to include which project you want to support.
 
 ## Funded by
   - LeoMoon Studios

commit eb308516474486a6fcc097c90fe4852ecb4e563f
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Sun Jul 30 21:18:30 2017 -0700

    changing build to leomoon.com

diff --git a/build/blender_light_studio.zip b/build/blender_light_studio.zip
deleted file mode 100644
index 4ee6c77..0000000
Binary files a/build/blender_light_studio.zip and /dev/null differ

commit 627f666a86fe932b9e19171e09ed7f9332ab9c4c
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Sun Jul 30 20:55:51 2017 -0700

    2.3.9 bugfix

diff --git a/README.md b/README.md
index 33785cc..e8fdfd1 100644
--- a/README.md
+++ b/README.md
@@ -40,6 +40,8 @@ Future development of this project depends on community donations. All proceeds
   - Maciek Ptaszynski
 
 ## Changelog
+  - 2.3.9:
+    - Bugfix
   - 2.3.8:
     - State of Selection Override is now stored between sessions
   - 2.3.6:

commit 41aa01bcf7537c961084d5000b937a7bc0d6f53d
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Mon Jul 31 05:26:59 2017 +0200

    v2.3.9 bugfix

diff --git a/src/__init__.py b/src/__init__.py
index 6e21bf0..05ecaf1 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -49,8 +49,6 @@ from . import deleteOperator
 from . import selectOperator
 from . import light_preview_list
 
-from bpy.app.handlers import persistent
-@persistent
 def config_load():
     from extensions_framework import util as efutil
     bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)

commit 5f119352455c7e52f7f3a2c71590aa0acf760159
Merge: d9bef47 7b1f2a0
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Mon Jul 31 05:19:31 2017 +0200

    Merge branch 'master' of https://github.com/leomoon-studios/blender-light-studio.git

commit d9bef471d95f7468db8babb6a5f6663f267d4810
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Mon Jul 31 05:19:01 2017 +0200

    v2.3.9 bugfix

diff --git a/src/__init__.py b/src/__init__.py
index 0f149b6..6e21bf0 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 8),
+    "version": (2, 3, 9),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
@@ -44,28 +44,29 @@ modules = developer_utils.setup_addon_modules(__path__, __name__, "bpy" in local
 
 import traceback
 
-from . light_operators import Blender_Light_Studio_Properties
+from . light_operators import Blender_Light_Studio_Properties, update_selection_override
 from . import deleteOperator
 from . import selectOperator
 from . import light_preview_list
 
 from bpy.app.handlers import persistent
 @persistent
-def ConfigLoad(scene):
+def config_load():
     from extensions_framework import util as efutil
     bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
-    bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)    
+    bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)
+    
+    update_selection_override()
     
 def register():
     try: bpy.utils.register_module(__name__)
     except: traceback.print_exc()
     bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
     bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
-    selectOperator.add_shortkeys()
     deleteOperator.add_shortkeys()
+    config_load() # select operator shortkeys
     light_preview_list.register()
     
-    bpy.app.handlers.load_post.append(ConfigLoad)
     
     print("Registered {} with {} modules".format(bl_info["name"], len(modules)))
     
@@ -73,7 +74,6 @@ def register():
 def unregister():
     selectOperator.remove_shortkeys()
     deleteOperator.remove_shortkeys()
-    bpy.app.handlers.load_post.remove(ConfigLoad)
     try: bpy.utils.unregister_module(__name__)
     except: traceback.print_exc()
     
diff --git a/src/gui.py b/src/gui.py
index ee36baf..b109b40 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -160,7 +160,7 @@ class BLS_Misc(bpy.types.Panel):
     
     @classmethod
     def poll(cls, context):
-        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' #and context.scene.BLStudio.initialized
                 
     def draw(self, context):
         layout = self.layout
diff --git a/src/light_operators.py b/src/light_operators.py
index 2e1a07c..47e65f1 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -9,6 +9,20 @@ _ = os.sep
 
 from extensions_framework import util as efutil
 from . import bl_info
+
+def update_selection_override():
+    from . selectOperator import addon_keymaps
+    keylen = bool(len(addon_keymaps))
+    
+    selection_override = bpy.bls_selection_override_right if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT' else bpy.bls_selection_override_left
+    if keylen != selection_override:
+        from . selectOperator import add_shortkeys, remove_shortkeys
+        if selection_override:
+            add_shortkeys()
+        else:
+            remove_shortkeys()
+    return selection_override
+    
 class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     initialized = BoolProperty(default = False)
             
@@ -25,24 +39,11 @@ class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     light_muted = BoolProperty(name="Mute Light", default=False, set=set_light_hidden, get=get_light_hidden)
     
     def get_selection_overriden(self):
-        from . selectOperator import addon_keymaps
-        keylen = bool(len(addon_keymaps))
-        #print(addon_keymaps)
-        
-    
         if not (hasattr(bpy, 'bls_selection_override_left') and hasattr(bpy, 'bls_selection_override_right')):
             bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)
             bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
-                        
-        selection_override = bpy.bls_selection_override_right if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT' else bpy.bls_selection_override_left
-            
-        if keylen != selection_override:
-            from . selectOperator import add_shortkeys, remove_shortkeys
-            if selection_override:
-                add_shortkeys()
-            else:
-                remove_shortkeys()
-        return selection_override
+        
+        return update_selection_override()
     
     def set_selection_overriden(self, context):
         from . selectOperator import add_shortkeys, remove_shortkeys

commit 7b1f2a0bfefc5572c900e00fdaa61d387e129de8
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Thu Jul 20 21:56:46 2017 -0700

    changed youtube video link

diff --git a/README.md b/README.md
index 2aea2ca..33785cc 100644
--- a/README.md
+++ b/README.md
@@ -2,7 +2,7 @@
 ## Introduction
 Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptaszynski and inspired by HDR Light Studio 5 lighting system.
 
-[![Light Studio plugin for Blender](http://img.youtube.com/vi/I6KVYMLFR98/0.jpg)](https://www.youtube.com/watch?v=I6KVYMLFR98)
+[![Light Studio plugin for Blender](http://img.youtube.com/vi/NWPeuJ6I5kc/0.jpg)](https://www.youtube.com/watch?v=NWPeuJ6I5kc)
 
 ## Features
   - Add/Remove lights around objects (0,0,0)

commit c3b3f5d2a220138f531e046d10a39632c9b20253
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Tue Jul 11 17:52:41 2017 +0200

    v 2.3.8
    save selection override state

diff --git a/README.md b/README.md
index 0a0372c..2aea2ca 100644
--- a/README.md
+++ b/README.md
@@ -40,6 +40,8 @@ Future development of this project depends on community donations. All proceeds
   - Maciek Ptaszynski
 
 ## Changelog
+  - 2.3.8:
+    - State of Selection Override is now stored between sessions
   - 2.3.6:
     - Added empty for each profile for easy movement
     - Added copy profile to scene
@@ -108,6 +110,9 @@ Future development of this project depends on community donations. All proceeds
   - 11: Use the options for the selected light and light your scene
   - 12: Happy Blending!
 
+## Known Issues
+  - In case of problems with left click selection, manipulators or overlapping selection please disable Override Selection checkbox under Misc. panel
+  
 ## Future Ideas
   - Copy profile to scene (internal) operator
   - Add ability to export (render) the light setup as environment texture (Equirectangular Panoramic EXR)
diff --git a/build/blender_light_studio.zip b/build/blender_light_studio.zip
index 3669d79..4ee6c77 100644
Binary files a/build/blender_light_studio.zip and b/build/blender_light_studio.zip differ
diff --git a/src/__init__.py b/src/__init__.py
index 2a536cd..0f149b6 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 7),
+    "version": (2, 3, 8),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
@@ -48,6 +48,14 @@ from . light_operators import Blender_Light_Studio_Properties
 from . import deleteOperator
 from . import selectOperator
 from . import light_preview_list
+
+from bpy.app.handlers import persistent
+@persistent
+def ConfigLoad(scene):
+    from extensions_framework import util as efutil
+    bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
+    bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)    
+    
 def register():
     try: bpy.utils.register_module(__name__)
     except: traceback.print_exc()
@@ -57,12 +65,15 @@ def register():
     deleteOperator.add_shortkeys()
     light_preview_list.register()
     
+    bpy.app.handlers.load_post.append(ConfigLoad)
+    
     print("Registered {} with {} modules".format(bl_info["name"], len(modules)))
     
 
 def unregister():
     selectOperator.remove_shortkeys()
     deleteOperator.remove_shortkeys()
+    bpy.app.handlers.load_post.remove(ConfigLoad)
     try: bpy.utils.unregister_module(__name__)
     except: traceback.print_exc()
     
diff --git a/src/gui.py b/src/gui.py
index 7c3dde6..ee36baf 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -147,7 +147,10 @@ class BLS_ProfileImportExport(bpy.types.Panel):
         col.operator('bls_list.export_profiles', text="Export Selected Profile")
         col.operator('bls_list.export_profiles', text="Export All Profiles").all=True
         col.operator('bls_list.import_profiles')
-        
+
+from extensions_framework import util as efutil
+from . import bl_info
+
 class BLS_Misc(bpy.types.Panel):
     bl_idname = "bls_misc"
     bl_label = "Misc"
@@ -168,9 +171,9 @@ class BLS_Misc(bpy.types.Panel):
         col = layout.column(align=True)
         col.operator('bls.find_missing_textures')
         
-        if context.user_preferences.inputs.select_mouse == 'LEFT':
-            box = layout.box()
-            col = box.column()
-            col.label("Disable in case of problems")
-            col.label("using manipulators")
-            col.prop(props, 'selection_overriden')   
\ No newline at end of file
+        box = layout.box()
+        col = box.column()
+        col.label("Disable in case of problems")
+        col.label("eg. using manipulators")
+        col.prop(props, 'selection_overriden')
+        
\ No newline at end of file
diff --git a/src/light_operators.py b/src/light_operators.py
index 7c28d54..2e1a07c 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -7,6 +7,8 @@ import os
 
 _ = os.sep
 
+from extensions_framework import util as efutil
+from . import bl_info
 class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     initialized = BoolProperty(default = False)
             
@@ -24,16 +26,46 @@ class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     
     def get_selection_overriden(self):
         from . selectOperator import addon_keymaps
+        keylen = bool(len(addon_keymaps))
         #print(addon_keymaps)
-        return len(addon_keymaps)
+        
+    
+        if not (hasattr(bpy, 'bls_selection_override_left') and hasattr(bpy, 'bls_selection_override_right')):
+            bpy.bls_selection_override_left = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_left', False)
+            bpy.bls_selection_override_right = efutil.find_config_value(bl_info['name'], 'defaults', 'selection_override_right', True)
+                        
+        selection_override = bpy.bls_selection_override_right if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT' else bpy.bls_selection_override_left
+            
+        if keylen != selection_override:
+            from . selectOperator import add_shortkeys, remove_shortkeys
+            if selection_override:
+                add_shortkeys()
+            else:
+                remove_shortkeys()
+        return selection_override
+    
     def set_selection_overriden(self, context):
         from . selectOperator import add_shortkeys, remove_shortkeys
         if context:
             add_shortkeys()
         else:
             remove_shortkeys()
+        
+        if bpy.context.user_preferences.inputs.select_mouse == 'RIGHT':
+            bpy.bls_selection_override_right = context
+            efutil.write_config_value(bl_info['name'], 'defaults', 'selection_override_right', context)
+        else:
+            bpy.bls_selection_override_left = context
+            efutil.write_config_value(bl_info['name'], 'defaults', 'selection_override_left', context)
+        
             
-    selection_overriden = BoolProperty(name="Override Selection", default=True, set=set_selection_overriden, get=get_selection_overriden)
+    selection_overriden = BoolProperty(
+        name="Override Selection",
+        default = True,
+        set=set_selection_overriden,
+        get=get_selection_overriden
+    )
+    
     
     ''' Profile List '''
     profile_list = CollectionProperty(type = ListItem)

commit e19a9e8fd4de966e1206fddd8021977787d060f7
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Fri Mar 24 15:41:36 2017 -0700

    Update README.md

diff --git a/README.md b/README.md
index 56022cf..0a0372c 100644
--- a/README.md
+++ b/README.md
@@ -22,7 +22,7 @@ Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptas
   - Import/Export of light profiles
 
 ## Donations
-Future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of the proceeds will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
+Future development of this project depends on community donations. All proceeds will go towards the development. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)" and make sure to include which project you want to support.
 
 ## Funded by
   - LeoMoon Studios

commit 764e1ec0153c59e5e57cb1601def00679240f87c
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Fri Mar 24 11:59:02 2017 -0700

    Update README.md

diff --git a/README.md b/README.md
index d42ea79..56022cf 100644
--- a/README.md
+++ b/README.md
@@ -22,7 +22,7 @@ Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptas
   - Import/Export of light profiles
 
 ## Donations
-The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
+Future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of the proceeds will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
 
 ## Funded by
   - LeoMoon Studios

commit 97fbeaba3c00fe8d06f46b571bb199ba68cc261c
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Wed Mar 22 02:02:43 2017 +0100

    build

diff --git a/build/blender_light_studio.zip b/build/blender_light_studio.zip
new file mode 100644
index 0000000..3669d79
Binary files /dev/null and b/build/blender_light_studio.zip differ

commit 878242d226680a8e77ba57e4071a6ae0a3cc61e4
Author: Amin Persia <leomoon@gmail.com>
Date:   Tue Mar 21 11:33:10 2017 -0700

    removed build since build is hosted on leomoon.com

diff --git a/build/blender_light_studio.zip b/build/blender_light_studio.zip
deleted file mode 100644
index b0db7f6..0000000
Binary files a/build/blender_light_studio.zip and /dev/null differ

commit c68c62251fa67b513546fe067b5ed4896ba4aced
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Tue Mar 21 18:30:06 2017 +0100

    fix: light brush

diff --git a/src/__init__.py b/src/__init__.py
index 92d7dcd..2a536cd 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 6),
+    "version": (2, 3, 7),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
diff --git a/src/light_brush.py b/src/light_brush.py
index ffd357a..5bdb40f 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -91,11 +91,12 @@ def raycast(context, event, diff):
     #####
     profile = findLightGrp(controller).parent
     handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
+    lightmesh = getLightMesh()
     position = intersect_line_sphere(
         location - handle.location,
         (normal if diff else view_vector.reflect(normal)) + location - handle.location,
         Vector((0,0,0)),
-        context.scene.BLStudio.light_radius,
+        lightmesh.location.x,
         False,
         )[0]
     

commit 2845428ff5bbfef81ce69747e50eac1ada617706
Merge: 3bc5808 a4099dd
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Mar 16 05:08:09 2017 +0100

    Merge branch 'master' of https://github.com/leomoon-studios/blender-light-studio.git

commit 3bc5808986769d0ead97acf190eb6fa5e9d92395
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Mar 16 05:06:54 2017 +0100

    added backward compatibility for old bls files

diff --git a/build/blender_light_studio.zip b/build/blender_light_studio.zip
index 716d47b..b0db7f6 100644
Binary files a/build/blender_light_studio.zip and b/build/blender_light_studio.zip differ
diff --git a/src/light_profiles.py b/src/light_profiles.py
index c67b6e8..2925d89 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -333,7 +333,8 @@ import json, time
 script_file = os.path.realpath(__file__)
 dir = os.path.dirname(script_file)
 
-def parse_profile(context, props, profiles, internal_copy=False):
+VERSION = 1.01
+def parse_profile(context, props, profiles, version=VERSION, internal_copy=False):
     plist = props.profile_list
     for profile in profiles:
         print(profile)
@@ -347,10 +348,11 @@ def parse_profile(context, props, profiles, internal_copy=False):
         #lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
         profile_empty = context.scene.objects[plist[-1].empty_name]
         
-        handle = getLightHandle(profile_empty)    
-        handle.location.x = profile['handle_position'][0]
-        handle.location.y = profile['handle_position'][1]
-        handle.location.z = profile['handle_position'][2]
+        if version > 1:
+            handle = getLightHandle(profile_empty)    
+            handle.location.x = profile['handle_position'][0]
+            handle.location.y = profile['handle_position'][1]
+            handle.location.z = profile['handle_position'][2]
 
         for light in profile["lights"]:
             # before
@@ -410,7 +412,7 @@ class ImportProfiles(bpy.types.Operator):
         f.closed
         
         file = json.loads(file)
-        parse_profile(context, props, file["profiles"])
+        parse_profile(context, props, file["profiles"], float(file["version"]))
  
         return{'FINISHED'}
     
@@ -473,7 +475,7 @@ class ExportProfiles(bpy.types.Operator):
         export_file = {}
         date = time.localtime()
         export_file['date'] = '{}-{:02}-{:02} {:02}:{:02}'.format(date.tm_year, date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
-        export_file['version'] = '1.01'
+        export_file['version'] = VERSION
         profiles_to_export = export_file['profiles'] = []
         
         if self.all:

commit a4099ddc5d10b8882d93fdeb9e8c9e4d21ec5694
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 15 20:56:09 2017 -0700

    fixed download link

diff --git a/README.md b/README.md
index a70f480..d42ea79 100644
--- a/README.md
+++ b/README.md
@@ -95,7 +95,7 @@ The speed of future development of this plugin depends on community donations. I
     - Beta release
 
 ## How to install
-  - 01: Download "[Blender Light Studio](https://leomoon.com/projects/plugins/blender-light-studio/)"
+  - 01: Download "[Blender Light Studio](https://leomoon.com/downloads/plugins/blender-light-studio/)"
   - 02: Open Blender and go to File -> User Preferences... -> Addons
   - 03: Click on "Install from File..." and select "blender-light-studio.zip"
   - 04: After installation, the new plugin should show up and you can enable it

commit cc8108c12eedb288e35e477aba206bba6bf53279
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Mar 16 04:29:42 2017 +0100

    build

diff --git a/build/blender_light_studio.zip b/build/blender_light_studio.zip
new file mode 100644
index 0000000..716d47b
Binary files /dev/null and b/build/blender_light_studio.zip differ
diff --git a/src/common.py b/src/common.py
index 56f006b..d203267 100644
--- a/src/common.py
+++ b/src/common.py
@@ -48,9 +48,13 @@ def getLightController():
 
 
 def findLightProfile(ob):
+    if ob.name.startswith('BLS_PROFILE'):
+        return ob
+    
     while ob.parent:
         ob = ob.parent
         if ob.name.startswith('BLS_PROFILE'): return ob
+        
     return None
 
 def getLightHandle(ob=None):
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 1e531aa..c67b6e8 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -346,6 +346,11 @@ def parse_profile(context, props, profiles, internal_copy=False):
 
         #lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
         profile_empty = context.scene.objects[plist[-1].empty_name]
+        
+        handle = getLightHandle(profile_empty)    
+        handle.location.x = profile['handle_position'][0]
+        handle.location.y = profile['handle_position'][1]
+        handle.location.z = profile['handle_position'][2]
 
         for light in profile["lights"]:
             # before
@@ -365,11 +370,6 @@ def parse_profile(context, props, profiles, internal_copy=False):
             controller.location.y = light['position'][1]
             controller.location.z = light['position'][2]
             
-            handle = getLightHandle(controller)
-            handle.location.x = light['handle_position'][0]
-            handle.location.y = light['handle_position'][1]
-            handle.location.z = light['handle_position'][2]
-            
             controller.scale.x = light['scale'][0]
             controller.scale.y = light['scale'][1]
             controller.scale.z = light['scale'][2]
@@ -424,16 +424,17 @@ def compose_profile(list_index):
     profile_dict = {}
     profile_dict['name'] = props.profile_list[list_index].name
     profile_dict['lights']= []
-    lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
-    print(lgroups)
+    profile = bpy.data.objects[props.profile_list[list_index].empty_name]
+    lgroups = [lg for lg in family(profile) if "BLS_LIGHT_GRP" in lg.name]
+    handle = getLightHandle(profile)
+    print(profile, handle)
+    profile_dict['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
     for lg in lgroups:
         controller = [c for c in family(lg) if "BLS_CONTROLLER" in c.name][0]
         lmesh = [l for l in family(lg) if "BLS_LIGHT_MESH" in l.name][0]
         light = {}
         light['radius'] = lmesh.location.x
         light['position'] = [controller.location.x, controller.location.y, controller.location.z]
-        handle = getLightHandle(lg)
-        light['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
         light['scale'] = [controller.scale.x, controller.scale.y, controller.scale.z]
         light['rotation'] = controller.rotation_euler.z
         light['mute'] = props.light_muted
@@ -472,7 +473,7 @@ class ExportProfiles(bpy.types.Operator):
         export_file = {}
         date = time.localtime()
         export_file['date'] = '{}-{:02}-{:02} {:02}:{:02}'.format(date.tm_year, date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
-        export_file['version'] = '1'
+        export_file['version'] = '1.01'
         profiles_to_export = export_file['profiles'] = []
         
         if self.all:

commit 8f48cccb2b6154e811a28cda8b54d71b8b6637c6
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 15 18:48:30 2017 -0700

    readme update

diff --git a/README.md b/README.md
index fdaa84e..a70f480 100644
--- a/README.md
+++ b/README.md
@@ -31,6 +31,7 @@ The speed of future development of this plugin depends on community donations. I
   - Damir Simovski
   - Krzysztof Czerwiski x2
   - Paul Kotelevets
+  - Jacinto Carbajosa Fermoso x2
 
 ## Programmers
   - Marcin Zielinski
@@ -44,7 +45,7 @@ The speed of future development of this plugin depends on community donations. I
     - Added copy profile to scene
     - Added auto refresh light textures
     - Light distance is animatable now
-    - Fixed left click
+    - Fixed left click (partially)
     - Fixed blend autopacking
   - 2.3.5:
     - Bugfix

commit eb1a4f1ffc327b95d76650e95570fb4b88ce3806
Merge: 353c0b7 5e231bf
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 15 18:35:43 2017 -0700

    Merge pull request #5 from leomoon-studios/dev
    
    fix: profile handle location export

commit 5e231bf1871c90bde4e0792b54168c1806a3581d
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Mar 16 02:25:19 2017 +0100

    fix: profile handle location export

diff --git a/src/common.py b/src/common.py
index 3b52b5e..56f006b 100644
--- a/src/common.py
+++ b/src/common.py
@@ -46,6 +46,27 @@ def getLightController():
     light_no = lightGrp.name.split('.')[1]
     return obs[obs.find('BLS_CONTROLLER.'+light_no)]
 
+
+def findLightProfile(ob):
+    while ob.parent:
+        ob = ob.parent
+        if ob.name.startswith('BLS_PROFILE'): return ob
+    return None
+
+def getLightHandle(ob=None):
+    if not ob:
+        ob = bpy.context.scene.objects.active
+
+    p = findLightProfile(ob)
+    if not p:
+        return None
+    
+    h = [h for h in p.children if h.name.startswith('BLS_HANDLE')]
+    if len(h):
+        return h[0]
+    else:
+        return None
+
 import bpy
 def refreshMaterials():
     #controllers = [ob for ob in family(findLightGrp(context.active_object).parent) if ob.name.startswith('BLS_CONTROLLER.')]
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 1c6781c..1e531aa 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -1,7 +1,7 @@
 import bpy
 from bpy.props import StringProperty, PointerProperty, FloatProperty, EnumProperty
 import os
-from . common import isFamily, family, findLightGrp
+from . common import isFamily, family, findLightGrp, getLightHandle
 from itertools import chain
 
 _ = os.sep
@@ -365,6 +365,11 @@ def parse_profile(context, props, profiles, internal_copy=False):
             controller.location.y = light['position'][1]
             controller.location.z = light['position'][2]
             
+            handle = getLightHandle(controller)
+            handle.location.x = light['handle_position'][0]
+            handle.location.y = light['handle_position'][1]
+            handle.location.z = light['handle_position'][2]
+            
             controller.scale.x = light['scale'][0]
             controller.scale.y = light['scale'][1]
             controller.scale.z = light['scale'][2]
@@ -427,6 +432,8 @@ def compose_profile(list_index):
         light = {}
         light['radius'] = lmesh.location.x
         light['position'] = [controller.location.x, controller.location.y, controller.location.z]
+        handle = getLightHandle(lg)
+        light['handle_position'] = [handle.location.x, handle.location.y, handle.location.z]
         light['scale'] = [controller.scale.x, controller.scale.y, controller.scale.z]
         light['rotation'] = controller.rotation_euler.z
         light['mute'] = props.light_muted

commit 353c0b7ee70d038375d2b01bd837a3058fb5f9df
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 15 17:57:34 2017 -0700

    bugfix

diff --git a/README.md b/README.md
index 2c02432..fdaa84e 100644
--- a/README.md
+++ b/README.md
@@ -43,6 +43,7 @@ The speed of future development of this plugin depends on community donations. I
     - Added empty for each profile for easy movement
     - Added copy profile to scene
     - Added auto refresh light textures
+    - Light distance is animatable now
     - Fixed left click
     - Fixed blend autopacking
   - 2.3.5:

commit fe320e8c9c6bb1e521d1b6d1d4c3eb8cdc9ee165
Merge: aaf91aa d0feccf
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 15 17:56:21 2017 -0700

    Merge pull request #4 from leomoon-studios/dev
    
    radius is animatable now

commit aaf91aace8f800ac7f068cab937a2618d96cf4f2
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 15 17:54:45 2017 -0700

    2.3.6

diff --git a/README.md b/README.md
index 71db2c9..2c02432 100644
--- a/README.md
+++ b/README.md
@@ -39,6 +39,12 @@ The speed of future development of this plugin depends on community donations. I
   - Maciek Ptaszynski
 
 ## Changelog
+  - 2.3.6:
+    - Added empty for each profile for easy movement
+    - Added copy profile to scene
+    - Added auto refresh light textures
+    - Fixed left click
+    - Fixed blend autopacking
   - 2.3.5:
     - Bugfix
   - 2.3.4:

commit ba2502257b94fa5c966946878bff18123c8b18a8
Merge: bed1262 2e800bd
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 15 17:52:09 2017 -0700

    Merge pull request #3 from leomoon-studios/dev
    
    Merging Dev

commit d0feccfadb3f07386a987d206c254266c3df5731
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Mar 16 01:49:37 2017 +0100

    radius is animatable now

diff --git a/src/gui.py b/src/gui.py
index 0a9b05e..7c3dde6 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -107,7 +107,7 @@ class BLS_Selected(bpy.types.Panel):
                         col.prop(input, 'default_value', input.name)
             except:
                 col.label("BLS_light material is not valid.")
-            col.prop(context.scene.BLStudio, 'light_radius')
+            col.prop(getLightMesh(), 'location', index=0) #light radius
                 
 class BLS_Visibility(bpy.types.Panel):
     bl_idname = "bls_visibility"
diff --git a/src/light_operators.py b/src/light_operators.py
index ad02588..7c28d54 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -9,13 +9,7 @@ _ = os.sep
 
 class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     initialized = BoolProperty(default = False)
-    
-    def get_light_x(self):
-        return getLightMesh().location.x
-    
-    def set_light_x(self, context):
-        getLightMesh().location.x = context
-        
+            
     def get_light_hidden(self):
         return getLightMesh().hide_render
     
@@ -26,7 +20,6 @@ class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
         bpy.context.scene.frame_current = bpy.context.scene.frame_current # refresh hack
         refreshMaterials()
     
-    light_radius = FloatProperty(name="Light Distance", default=30.0, min=0.5, set=set_light_x, step=5, get=get_light_x)
     light_muted = BoolProperty(name="Mute Light", default=False, set=set_light_hidden, get=get_light_hidden)
     
     def get_selection_overriden(self):

commit 2e800bd4497c865df590b0e890193859e594e0bc
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Mar 16 01:28:01 2017 +0100

    empty handle, copy profile to scene, auto refresh of tex dir

diff --git a/src/common.py b/src/common.py
index cb36644..3b52b5e 100644
--- a/src/common.py
+++ b/src/common.py
@@ -31,10 +31,14 @@ def findLightGrp(ob):
     return None
 
 def getLightMesh():
-    obs = bpy.context.scene.objects
-    lightGrp = obs.active
-    light_no = lightGrp.name.split('.')[1]
-    return obs[obs.find('BLS_LIGHT_MESH.'+light_no)]
+    #obs = bpy.context.scene.objects
+    #lightGrp = obs.active
+    #light_no = lightGrp.name.split('.')[1]
+    #return obs[obs.find('BLS_LIGHT_MESH.'+light_no)]
+
+    lg = findLightGrp(bpy.context.scene.objects.active)
+    lm = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH")]
+    return lm[0] if len(lm) else None
 
 def getLightController():
     obs = bpy.context.scene.objects
diff --git a/src/deleteOperator.py b/src/deleteOperator.py
index b300f92..016fec3 100644
--- a/src/deleteOperator.py
+++ b/src/deleteOperator.py
@@ -22,7 +22,9 @@ class DeleteOperator(bpy.types.Operator):
             context.scene.objects.active = obj
             if hasattr(obj, 'use_fake_user'):
                 obj.use_fake_user = False
-            bpy.ops.scene.delete_blender_studio_light()
+            ret = bpy.ops.scene.delete_blender_studio_light()
+            if 'CANCELLED' in ret:
+                self.report({'WARNING', 'ERROR'}, "Delete Profile in order to delete Handle")
         
         bpy.ops.object.delete(use_global=self.use_global)
 
diff --git a/src/gui.py b/src/gui.py
index 4b7d572..0a9b05e 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -44,7 +44,7 @@ class BLS_ProfileList(bpy.types.Panel):
         col = row.column(align=True)
         col.operator('bls_list.new_profile', icon='ZOOMIN', text="")
         col.operator('bls_list.delete_profile', icon='ZOOMOUT', text="")
-        col.operator('bls_list.copy_profile', icon='GHOST', text="")
+        col.operator('bls_list.copy_profile_menu', icon='GHOST', text="")
         
         col.separator()
         col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
@@ -144,9 +144,9 @@ class BLS_ProfileImportExport(bpy.types.Panel):
         props = scene.BLStudio
               
         col = layout.column(align=True)
-        col.operator('bls.export_profiles', text="Export Selected Profile")
-        col.operator('bls.export_profiles', text="Export All Profiles").all=True
-        col.operator('bls.import_profiles')
+        col.operator('bls_list.export_profiles', text="Export Selected Profile")
+        col.operator('bls_list.export_profiles', text="Export All Profiles").all=True
+        col.operator('bls_list.import_profiles')
         
 class BLS_Misc(bpy.types.Panel):
     bl_idname = "bls_misc"
@@ -166,4 +166,11 @@ class BLS_Misc(bpy.types.Panel):
         props = scene.BLStudio
               
         col = layout.column(align=True)
-        col.operator('bls.find_missing_textures')  
\ No newline at end of file
+        col.operator('bls.find_missing_textures')
+        
+        if context.user_preferences.inputs.select_mouse == 'LEFT':
+            box = layout.box()
+            col = box.column()
+            col.label("Disable in case of problems")
+            col.label("using manipulators")
+            col.prop(props, 'selection_overriden')   
\ No newline at end of file
diff --git a/src/light_brush.py b/src/light_brush.py
index 1d99ac2..ffd357a 100644
--- a/src/light_brush.py
+++ b/src/light_brush.py
@@ -89,10 +89,11 @@ def raycast(context, event, diff):
     normal.normalize()
     
     #####
-    
+    profile = findLightGrp(controller).parent
+    handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
     position = intersect_line_sphere(
-        location,
-        (normal if diff else view_vector.reflect(normal)) + location,
+        location - handle.location,
+        (normal if diff else view_vector.reflect(normal)) + location - handle.location,
         Vector((0,0,0)),
         context.scene.BLStudio.light_radius,
         False,
diff --git a/src/light_operators.py b/src/light_operators.py
index fb3eefe..ad02588 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -9,7 +9,7 @@ _ = os.sep
 
 class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     initialized = BoolProperty(default = False)
-      
+    
     def get_light_x(self):
         return getLightMesh().location.x
     
@@ -24,7 +24,7 @@ class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
         light.hide_render = context
         light.hide = context
         bpy.context.scene.frame_current = bpy.context.scene.frame_current # refresh hack
-        refreshMaterials()  
+        refreshMaterials()
     
     light_radius = FloatProperty(name="Light Distance", default=30.0, min=0.5, set=set_light_x, step=5, get=get_light_x)
     light_muted = BoolProperty(name="Mute Light", default=False, set=set_light_hidden, get=get_light_hidden)
@@ -186,7 +186,9 @@ class AddBSLight(bpy.types.Operator):
             ob.use_fake_user = True
         
         lightGrp = [l for l in new_objects if l.name.startswith('BLS_LIGHT_GRP')][0]
-        lightGrp.parent = [ob for ob in bpy.context.scene.objects if ob and ob.name.startswith('BLS_PROFILE') and isFamily(ob)][0]
+        profile = [ob for ob in bpy.context.scene.objects if ob and ob.name.startswith('BLS_PROFILE') and isFamily(ob)][0]
+        handle = [ob for ob in profile.children if ob.name.startswith('BLS_HANDLE')][0]
+        lightGrp.parent = profile
         
         bpy.ops.object.select_all(action='DESELECT')
         light = [p for p in new_objects if p.name.startswith('BLS_LIGHT_MESH')][0]
@@ -268,7 +270,13 @@ class AddBSLight(bpy.types.Operator):
         c.frame_start = 1
         c.frame_end = 500
         #####
-
+        
+        c = light.constraints.new('COPY_LOCATION')
+        c.target = handle
+        c.use_x = True
+        c.use_y = True
+        c.use_z = True
+        c.use_offset = True
         bpy.context.scene.frame_current = bpy.context.scene.frame_current # refresh hack
         refreshMaterials()
                 
@@ -299,7 +307,17 @@ class DeleteBSLight(bpy.types.Operator):
         
         light = bpy.context.scene.objects.active
         
+        
         lightGrp = findLightGrp(light)
+        if lightGrp == None:
+            if light.parent and light.parent.name.startswith('BLS_PROFILE'):
+                light.select = False
+                self.report({'WARNING'}, "Delete Profile in order to delete Handle")
+                return {"CANCELLED"}
+            else:
+                scene.objects.unlink(light)
+                return {"FINISHED"}
+            
         ending = lightGrp.name.split('.')[1]
         
         #obsToRemove = [ob for ob in scene.objects if not ob.name.startswith('BLS_PROFILE.') and ob.name.endswith(ending) and isFamily(ob)]
diff --git a/src/light_preview_list.py b/src/light_preview_list.py
index 93ffaf1..014c7d1 100644
--- a/src/light_preview_list.py
+++ b/src/light_preview_list.py
@@ -1,8 +1,12 @@
 import os
+from time import time
 import bpy
 from . common import getLightMesh, isFamily
 
 _ = os.sep
+script_file = os.path.realpath(__file__)
+dir = os.path.dirname(script_file)
+directory=os.path.join(dir,"textures_real_lights")
     
 def enum_previews_from_directory_items(self, context):
     """EnumProperty callback"""
@@ -19,9 +23,13 @@ def enum_previews_from_directory_items(self, context):
 
     # Get the preview collection (defined in register func).
     pcoll = preview_collections["main"]
-
-    if not pcoll.updated:
+    
+    dir_up = os.path.getmtime(directory)
+    if pcoll.initiated and dir_up <= pcoll.dir_update_time:
         return pcoll.tex_previews
+    pcoll.dir_update_time = dir_up
+    pcoll.clear()
+    
 
     print("Scanning directory: %s" % directory)
 
@@ -35,12 +43,12 @@ def enum_previews_from_directory_items(self, context):
         for i, name in enumerate(image_paths):
             # generates a thumbnail preview for a file.
             filepath = os.path.join(directory, name)
-            thumb = pcoll.load(filepath, filepath, 'IMAGE')
+            thumb = pcoll.load(filepath, filepath, 'IMAGE', True)
             basename = os.path.splitext(name)[0]
             enum_items.append((name, basename, name, thumb.icon_id, i))
 
     pcoll.tex_previews = enum_items
-    pcoll.updated = False
+    pcoll.initiated = True
     return pcoll.tex_previews
 
 
@@ -67,9 +75,6 @@ def preview_enum_set(wm, context):
     name = preview_collections["main"].tex_previews[context][0]
     
     light = getLightMesh()
-    script_file = os.path.realpath(__file__)
-    dir = os.path.dirname(script_file)
-    directory=os.path.join(dir,"textures_real_lights")
     light.active_material.node_tree.nodes["Light Texture"].image = bpy.data.images.load(os.path.join(directory, name), True)
     
     return None
@@ -87,7 +92,8 @@ def register():
     import bpy.utils.previews
     pcoll = bpy.utils.previews.new()
     pcoll.bls_tex_previews = ()
-    pcoll.updated = True
+    pcoll.initiated = False
+    pcoll.dir_update_time = os.path.getmtime(directory)
 
     preview_collections["main"] = pcoll
 
@@ -100,3 +106,4 @@ def unregister():
     for pcoll in preview_collections.values():
         bpy.utils.previews.remove(pcoll)
     preview_collections.clear()
+    
\ No newline at end of file
diff --git a/src/light_profiles.py b/src/light_profiles.py
index af64e46..1c6781c 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -1,5 +1,5 @@
 import bpy
-from bpy.props import StringProperty, PointerProperty, FloatProperty
+from bpy.props import StringProperty, PointerProperty, FloatProperty, EnumProperty
 import os
 from . common import isFamily, family, findLightGrp
 from itertools import chain
@@ -77,14 +77,23 @@ class LIST_OT_NewItem(bpy.types.Operator):
         
         item.empty_name = profile.name
         
+        bpy.ops.object.empty_add(type='PLAIN_AXES', radius=1, view_align=False, location=(0, 0, 0), layers=(True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False))
+        handle = context.active_object
+        handle.parent = profile
+        handle.name = "BLS_HANDLE"
+        handle.protected = True
+        handle['last_layers'] = handle.layers[:]
+        handle.empty_draw_type = 'SPHERE'
+        
         #if len([prof for prof in profile.parent.children if prof.name.startswith('BLS_PROFILE.')]) > 1:
         if len([prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)]) > 1:
             #profile already exists
             context.scene.objects.unlink(profile)
+            context.scene.objects.unlink(handle)
         else:
             #init last_empty for first profile
             props.last_empty = profile.name
-            
+        
 
         return{'FINISHED'}
 
@@ -130,7 +139,7 @@ class LIST_OT_CopyItem(bpy.types.Operator):
     """ Copy an item in the list """
 
     bl_idname = "bls_list.copy_profile"
-    bl_label = "Copy an profile in the list"
+    bl_label = "Copy profile"
     bl_options = {"INTERNAL"}
 
     @classmethod
@@ -311,6 +320,7 @@ def update_list_index(self, context):
         
     #link selected profile
     for ob in family(bpy.data.objects[selected_profile.empty_name]):
+        print(ob.name)
         context.scene.objects.link(ob)
         ob.layers = [bool(l) for l in ob['last_layers']]
         
@@ -322,10 +332,61 @@ def update_list_index(self, context):
 import json, time
 script_file = os.path.realpath(__file__)
 dir = os.path.dirname(script_file)
+
+def parse_profile(context, props, profiles, internal_copy=False):
+    plist = props.profile_list
+    for profile in profiles:
+        print(profile)
+        bpy.ops.bls_list.new_profile()
+        props.list_index = len(plist)-1
+        plist[-1].name = profile["name"]
+        if not internal_copy:
+            date = time.localtime()
+            plist[-1].name += ' {}-{:02}-{:02} {:02}:{:02}'.format(str(date.tm_year)[-2:], date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
+
+        #lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
+        profile_empty = context.scene.objects[plist[-1].empty_name]
+
+        for light in profile["lights"]:
+            # before
+            A = set(profile_empty.children)
+            
+            bpy.ops.scene.add_blender_studio_light()
+            
+            # after operation
+            B = set(profile_empty.children)
+            
+            # whats the difference
+            lgrp = (A ^ B).pop()
+            controller = [c for c in family(lgrp) if "BLS_CONTROLLER" in c.name][0]
+            props.light_radius = light['radius']
+            
+            controller.location.x = light['position'][0]
+            controller.location.y = light['position'][1]
+            controller.location.z = light['position'][2]
+            
+            controller.scale.x = light['scale'][0]
+            controller.scale.y = light['scale'][1]
+            controller.scale.z = light['scale'][2]
+            
+            controller.rotation_euler.z = light['rotation']
+            
+            props.light_muted = light['mute']
+            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[2].default_value = light['Intensity']
+            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
+            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
+            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
+            controller.material_slots[1].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
+            
+            if os.path.isabs(light['tex']):
+                controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
+            else:
+                controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
+                
 class ImportProfiles(bpy.types.Operator):
     """ Import Profiles from File """
  
-    bl_idname = "bls.import_profiles"
+    bl_idname = "bls_list.import_profiles"
     bl_label = "Import Profiles"
     #bl_options = {"INTERNAL"}
     
@@ -344,53 +405,7 @@ class ImportProfiles(bpy.types.Operator):
         f.closed
         
         file = json.loads(file)
-        for profile in file["profiles"]:
-            print(profile)
-            bpy.ops.bls_list.new_profile()
-            props.list_index = len(plist)-1
-            date = time.localtime()
-            plist[-1].name = profile["name"] + ' {}-{:02}-{:02} {:02}:{:02}'.format(str(date.tm_year)[-2:], date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
-            
-            #lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
-            profile_empty = context.scene.objects[plist[-1].empty_name]
-            
-            for light in profile["lights"]:
-                # before
-                A = set(profile_empty.children)
-                
-                bpy.ops.scene.add_blender_studio_light()
-                
-                # after operation
-                B = set(profile_empty.children)
-                
-                # whats the difference
-                lgrp = (A ^ B).pop()
-                controller = [c for c in family(lgrp) if "BLS_CONTROLLER" in c.name][0]
-                props.light_radius = light['radius']
-                
-                controller.location.x = light['position'][0]
-                controller.location.y = light['position'][1]
-                controller.location.z = light['position'][2]
-                
-                controller.scale.x = light['scale'][0]
-                controller.scale.y = light['scale'][1]
-                controller.scale.z = light['scale'][2]
-                
-                controller.rotation_euler.z = light['rotation']
-                
-                props.light_muted = light['mute']
-                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[2].default_value = light['Intensity']
-                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
-                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
-                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
-                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
-                
-                if os.path.isabs(light['tex']):
-                    controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
-                else:
-                    controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
-                    
-        
+        parse_profile(context, props, file["profiles"])
  
         return{'FINISHED'}
     
@@ -431,7 +446,7 @@ def compose_profile(list_index):
 class ExportProfiles(bpy.types.Operator):
     """ Export Profiles to File """
  
-    bl_idname = "bls.export_profiles"
+    bl_idname = "bls_list.export_profiles"
     bl_label = "Export"
     #bl_options = {"INTERNAL"}
     
@@ -459,6 +474,9 @@ class ExportProfiles(bpy.types.Operator):
         else:
             profiles_to_export.append(compose_profile(index))
         
+        #file = open(self.filepath, 'w')
+        #file.write(json.dumps(export_file, indent=4))
+        #file.close()
         
         with open(self.filepath, 'w') as f:
             f.write(json.dumps(export_file, indent=4))
@@ -471,7 +489,7 @@ class ExportProfiles(bpy.types.Operator):
         context.window_manager.fileselect_add(self)
         return {'RUNNING_MODAL'}
     
-class ExportProfiles(bpy.types.Operator):
+class FindMissingTextures(bpy.types.Operator):
     """ Find Missing Textures """
  
     bl_idname = "bls.find_missing_textures"
@@ -486,4 +504,65 @@ class ExportProfiles(bpy.types.Operator):
     def execute(self, context):
         bpy.ops.file.find_missing_files(directory=os.path.join(dir, "textures_real_lights"))        
         bpy.context.scene.frame_current = bpy.context.scene.frame_current
-        return{'FINISHED'}
\ No newline at end of file
+        return{'FINISHED'}
+
+class CopyProfileToScene(bpy.types.Operator):
+    """ Copy Light Profile to Scene """
+ 
+    bl_idname = "bls_list.copy_profile_to_scene"
+    bl_label = "Copy Profile to Scene"
+    bl_property = "sceneprop"
+    
+    def get_scenes(self, context):
+        return ((s.name, s.name, "Scene name") for i,s in enumerate(bpy.data.scenes))#global_vars["scenes"]
+    
+    sceneprop = EnumProperty(items = get_scenes)
+    
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        index = props.list_index
+        
+        profiles = [compose_profile(index),]
+        
+        context.screen.scene = bpy.data.scenes[self.sceneprop]
+        context.scene.render.engine = 'CYCLES'
+        if not context.scene.BLStudio.initialized:
+            bpy.ops.scene.create_blender_light_studio()
+        
+        parse_profile(context, context.scene.BLStudio, profiles, internal_copy=True)
+        
+        return{'FINISHED'}
+        
+    def invoke(self, context, event):
+        wm = context.window_manager
+        wm.invoke_search_popup(self)
+        return {'FINISHED'}
+    
+
+class CopyProfileMenu(bpy.types.Operator):
+    """ Copy Light Profile """
+ 
+    bl_idname = "bls_list.copy_profile_menu"
+    bl_label = "Copy Profile"
+
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+    
+    def execute(self, context):
+        wm = context.window_manager
+        def draw(self, context):
+            layout = self.layout
+            layout.operator_context='INVOKE_AREA'
+            col = layout.column(align=True)
+            col.operator('bls_list.copy_profile')
+            col.operator('bls_list.copy_profile_to_scene')
+
+        wm.popup_menu(draw, title="Copy Profile")
+        return {'FINISHED'}
\ No newline at end of file
diff --git a/src/selectOperator.py b/src/selectOperator.py
index bb9e449..fa84025 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -1,6 +1,6 @@
 import bpy
 from bpy.props import BoolProperty, IntVectorProperty
-from . common import isFamily, findLightGrp, family, refreshMaterials
+from . common import isFamily, findLightGrp, getLightMesh, family, refreshMaterials
 
 class SelectionOperator(bpy.types.Operator):
     """ Custom selection """
@@ -13,35 +13,45 @@ class SelectionOperator(bpy.types.Operator):
     center = BoolProperty(default = False)
     enumerate = BoolProperty(default = False)
     object = BoolProperty(default = False)
+    location = IntVectorProperty(default = (0,0),subtype ='XYZ', size = 2)
 
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
     
     def execute(self, context):
-        deactivate=''
-        if context.active_object:
-            obname = context.active_object.name
-            deactivate = obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.')
-        result = bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object)
+        #deactivate=False
+        #if context.active_object:
+        #    obname = context.active_object.name
+        #    deactivate = obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.')
+            
+        #result = bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object)
+        result = bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object, location=(self.location[0], self.location[1]))
         if 'FINISHED' not in result:
-            return result
-        
+            return {'PASS_THROUGH'}
         if context.active_object:
             obname = context.active_object.name
             if obname.startswith('BLS_CONTROLLER.'):
-                lno = obname.split('.')[1]
-                lno = context.scene.objects.find('BLS_LIGHT_MESH.'+lno)
-                if lno is not -1:
-                    context.scene.objects[lno].select = True
+                lm = getLightMesh()
+                if lm:
+                    lm.select = True
                 
-            if deactivate or obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.'):
-                refreshMaterials()
+            #if deactivate or obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.'):
+            #    refreshMaterials()
                     
             context.scene.frame_current = context.scene.frame_current
             refreshMaterials()
         
-        return result
+        if context.user_preferences.inputs.select_mouse == 'RIGHT':
+            return {'FINISHED'}
+        elif self.toggle:
+            return {'FINISHED'}
+        return {'PASS_THROUGH'}
+
+    def invoke(self, context, event):
+        self.location[0] = event.mouse_region_x
+        self.location[1] = event.mouse_region_y
+        return self.execute(context)
 
 addon_keymaps = []
 addin_kmis = []

commit ea9c20ad5f23a121b718c87758a5b8643a87c415
Merge: 0132a04 bed1262
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Mar 16 01:25:25 2017 +0100

    Merge branch 'master' of https://github.com/leomoon-studios/blender-light-studio.git into dev

commit bed12625fdb56961130b5e61f2995925f8c7ddfb
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Mar 8 12:28:28 2017 -0800

    Update README.md

diff --git a/README.md b/README.md
index fc0d53b..71db2c9 100644
--- a/README.md
+++ b/README.md
@@ -30,6 +30,7 @@ The speed of future development of this plugin depends on community donations. I
 ## Donors
   - Damir Simovski
   - Krzysztof Czerwiski x2
+  - Paul Kotelevets
 
 ## Programmers
   - Marcin Zielinski

commit c9367690b316e9eebe35357d729ffd3e0dae0dcf
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Tue Feb 21 13:14:18 2017 -0800

    Update README.md

diff --git a/README.md b/README.md
index 7476566..fc0d53b 100644
--- a/README.md
+++ b/README.md
@@ -21,6 +21,9 @@ Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptas
 	- [R] Rotate
   - Import/Export of light profiles
 
+## Donations
+The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
+
 ## Funded by
   - LeoMoon Studios
 
@@ -34,9 +37,6 @@ Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptas
 ## Prototype and Initial Scene by
   - Maciek Ptaszynski
 
-## Donations
-The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
-
 ## Changelog
   - 2.3.5:
     - Bugfix

commit e8c3c525c8a52bc67cc803f84c47ba4b6af983e8
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Tue Feb 21 13:11:39 2017 -0800

    Update README.md

diff --git a/README.md b/README.md
index fc0d53b..7476566 100644
--- a/README.md
+++ b/README.md
@@ -21,9 +21,6 @@ Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptas
 	- [R] Rotate
   - Import/Export of light profiles
 
-## Donations
-The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
-
 ## Funded by
   - LeoMoon Studios
 
@@ -37,6 +34,9 @@ The speed of future development of this plugin depends on community donations. I
 ## Prototype and Initial Scene by
   - Maciek Ptaszynski
 
+## Donations
+The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
+
 ## Changelog
   - 2.3.5:
     - Bugfix

commit 4de95618e632e2c88fb4367178d233cfcdd3201c
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Tue Feb 21 12:45:52 2017 -0800

    updated compatibility

diff --git a/README.md b/README.md
index 24cca00..fc0d53b 100644
--- a/README.md
+++ b/README.md
@@ -31,7 +31,7 @@ The speed of future development of this plugin depends on community donations. I
   - Damir Simovski
   - Krzysztof Czerwiski x2
 
-## Main Programmer
+## Programmers
   - Marcin Zielinski
 
 ## Prototype and Initial Scene by
@@ -99,9 +99,9 @@ The speed of future development of this plugin depends on community donations. I
   - 11: Use the options for the selected light and light your scene
   - 12: Happy Blending!
 
-## Future Ideas to Implement
+## Future Ideas
   - Copy profile to scene (internal) operator
   - Add ability to export (render) the light setup as environment texture (Equirectangular Panoramic EXR)
 
 ## Compatibility
-Tested with Blender 2.78
+Tested with Blender 2.78a

commit 0132a04df397441a8626e7a73eaa5ec842ee50e6
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Sat Feb 18 00:35:20 2017 +0100

    fix for blend auto packing

diff --git a/src/light_preview_list.py b/src/light_preview_list.py
index 89e26f1..93ffaf1 100644
--- a/src/light_preview_list.py
+++ b/src/light_preview_list.py
@@ -69,8 +69,8 @@ def preview_enum_set(wm, context):
     light = getLightMesh()
     script_file = os.path.realpath(__file__)
     dir = os.path.dirname(script_file)
-    directory=os.path.join(dir,"textures_real_lights"+_)
-    light.active_material.node_tree.nodes["Light Texture"].image.filepath = directory + name
+    directory=os.path.join(dir,"textures_real_lights")
+    light.active_material.node_tree.nodes["Light Texture"].image = bpy.data.images.load(os.path.join(directory, name), True)
     
     return None
 

commit a73a538bd20cd14d5fc1926aab0a13e051d54b4e
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Sat Feb 11 19:38:41 2017 +0100

    no build in dev

diff --git a/build/blender-light-studio.zip b/build/blender-light-studio.zip
deleted file mode 100644
index de6e667..0000000
Binary files a/build/blender-light-studio.zip and /dev/null differ

commit c193928748d900c0bf22083e9d021e366919244a
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Sat Feb 11 19:37:22 2017 +0100

    another left click fix

diff --git a/src/__init__.py b/src/__init__.py
index 4c71674..92d7dcd 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 5),
+    "version": (2, 3, 6),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
diff --git a/src/gui.py b/src/gui.py
index bfc2cf1..4b7d572 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -166,11 +166,4 @@ class BLS_Misc(bpy.types.Panel):
         props = scene.BLStudio
               
         col = layout.column(align=True)
-        col.operator('bls.find_missing_textures')
-        
-        if context.user_preferences.inputs.select_mouse == 'LEFT':
-            box = layout.box()
-            col = box.column()
-            col.label("Disable in case of problems")
-            col.label("using manipulators")
-            col.prop(props, 'selection_overriden')    
\ No newline at end of file
+        col.operator('bls.find_missing_textures')  
\ No newline at end of file
diff --git a/src/light_profiles.py b/src/light_profiles.py
index b5d96df..af64e46 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -459,9 +459,6 @@ class ExportProfiles(bpy.types.Operator):
         else:
             profiles_to_export.append(compose_profile(index))
         
-        #file = open(self.filepath, 'w')
-        #file.write(json.dumps(export_file, indent=4))
-        #file.close()
         
         with open(self.filepath, 'w') as f:
             f.write(json.dumps(export_file, indent=4))
diff --git a/src/selectOperator.py b/src/selectOperator.py
index d9f34f1..bb9e449 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -13,7 +13,6 @@ class SelectionOperator(bpy.types.Operator):
     center = BoolProperty(default = False)
     enumerate = BoolProperty(default = False)
     object = BoolProperty(default = False)
-    location = IntVectorProperty(default = (0,0),subtype ='XYZ', size = 2)
 
     @classmethod
     def poll(cls, context):
@@ -24,10 +23,9 @@ class SelectionOperator(bpy.types.Operator):
         if context.active_object:
             obname = context.active_object.name
             deactivate = obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.')
-            
-        result = bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object, location=(self.location[0] , self.location[1] ))
+        result = bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object)
         if 'FINISHED' not in result:
-            return {'PASS_THROUGH'}
+            return result
         
         if context.active_object:
             obname = context.active_object.name
@@ -43,16 +41,7 @@ class SelectionOperator(bpy.types.Operator):
             context.scene.frame_current = context.scene.frame_current
             refreshMaterials()
         
-        if context.user_preferences.inputs.select_mouse == 'RIGHT':
-            return {'FINISHED'}
-        elif self.toggle:
-            return {'FINISHED'}
-        return {'PASS_THROUGH'}
-
-    def invoke(self, context, event):
-        self.location[0] = event.mouse_region_x
-        self.location[1] = event.mouse_region_y
-        return self.execute(context)
+        return result
 
 addon_keymaps = []
 addin_kmis = []

commit d0251406435d3f944658016638d45be2ff0021f1
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Feb 10 10:14:23 2017 -0800

    updated future ideas

diff --git a/README.md b/README.md
index 068452c..24cca00 100644
--- a/README.md
+++ b/README.md
@@ -69,7 +69,8 @@ The speed of future development of this plugin depends on community donations. I
   - 1.2.2:
     - Linux paths bugfix
     - Control plane highlights when new light added
-  - 1.2.1: Minor bugfix
+  - 1.2.1:
+    - Minor bugfix
   - 1.2.0:
     - Protection from accidental deletion
     - Light objects made selectable
@@ -99,10 +100,8 @@ The speed of future development of this plugin depends on community donations. I
   - 12: Happy Blending!
 
 ## Future Ideas to Implement
-  - Exporting/importing light profiles (using XML file or blend).
   - Copy profile to scene (internal) operator
-  - Modal operator to controll position (click to place) and parameters (strength, size, etc.) of lights in 3D Viewport.
-  - Add ability to export (render) the light setup as environment texture (Equirectangular Panoramic)
+  - Add ability to export (render) the light setup as environment texture (Equirectangular Panoramic EXR)
 
 ## Compatibility
 Tested with Blender 2.78

commit 857a92937ca5d6010a734a87e2dee075b7039ff8
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Feb 10 10:03:26 2017 -0800

    readme change

diff --git a/README.md b/README.md
index 897fe38..068452c 100644
--- a/README.md
+++ b/README.md
@@ -29,7 +29,7 @@ The speed of future development of this plugin depends on community donations. I
 
 ## Donors
   - Damir Simovski
-  - Krzysztof Czerwiski
+  - Krzysztof Czerwiski x2
 
 ## Main Programmer
   - Marcin Zielinski
@@ -64,7 +64,8 @@ The speed of future development of this plugin depends on community donations. I
   - 2.0.1:
     - Added Light Profiles feature
 	- Added light preview for each light
-  - 1.2.3: Solved Linux problems
+  - 1.2.3:
+    - Solved Linux problems
   - 1.2.2:
     - Linux paths bugfix
     - Control plane highlights when new light added
@@ -78,8 +79,10 @@ The speed of future development of this plugin depends on community donations. I
     - Added Light Distance option
   - 1.1.0: 
     - Automatically switch to cycles after clicking "Prepare Light Studio"
-  - 1.0.1: Some fixes
-  - 1.0.0: Beta release
+  - 1.0.1:
+    - Some fixes
+  - 1.0.0:
+    - Beta release
 
 ## How to install
   - 01: Download "[Blender Light Studio](https://leomoon.com/projects/plugins/blender-light-studio/)"

commit 165ea7d6f275c9b173cd757f5fc6b00a7f856937
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Thu Feb 9 06:55:30 2017 +0100

    v2.3.5 bugfix

diff --git a/README.md b/README.md
index 74ed4f7..897fe38 100644
--- a/README.md
+++ b/README.md
@@ -38,6 +38,8 @@ The speed of future development of this plugin depends on community donations. I
   - Maciek Ptaszynski
 
 ## Changelog
+  - 2.3.5:
+    - Bugfix
   - 2.3.4:
     - Bugfix for left-click selection
   - 2.3.3:
diff --git a/build/blender-light-studio.zip b/build/blender-light-studio.zip
index 4674b5e..de6e667 100644
Binary files a/build/blender-light-studio.zip and b/build/blender-light-studio.zip differ
diff --git a/src/__init__.py b/src/__init__.py
index 256fe82..4c71674 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 4),
+    "version": (2, 3, 5),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
@@ -62,7 +62,7 @@ def register():
 
 def unregister():
     selectOperator.remove_shortkeys()
-    #deleteOperator.remove_shortkeys()
+    deleteOperator.remove_shortkeys()
     try: bpy.utils.unregister_module(__name__)
     except: traceback.print_exc()
     
diff --git a/src/gui.py b/src/gui.py
index a47651a..bfc2cf1 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -158,7 +158,7 @@ class BLS_Misc(bpy.types.Panel):
     @classmethod
     def poll(cls, context):
         return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
-            
+                
     def draw(self, context):
         layout = self.layout
         scene = context.scene
@@ -166,4 +166,11 @@ class BLS_Misc(bpy.types.Panel):
         props = scene.BLStudio
               
         col = layout.column(align=True)
-        col.operator('bls.find_missing_textures')
\ No newline at end of file
+        col.operator('bls.find_missing_textures')
+        
+        if context.user_preferences.inputs.select_mouse == 'LEFT':
+            box = layout.box()
+            col = box.column()
+            col.label("Disable in case of problems")
+            col.label("using manipulators")
+            col.prop(props, 'selection_overriden')    
\ No newline at end of file
diff --git a/src/light_operators.py b/src/light_operators.py
index 4041849..fb3eefe 100644
--- a/src/light_operators.py
+++ b/src/light_operators.py
@@ -29,6 +29,19 @@ class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
     light_radius = FloatProperty(name="Light Distance", default=30.0, min=0.5, set=set_light_x, step=5, get=get_light_x)
     light_muted = BoolProperty(name="Mute Light", default=False, set=set_light_hidden, get=get_light_hidden)
     
+    def get_selection_overriden(self):
+        from . selectOperator import addon_keymaps
+        #print(addon_keymaps)
+        return len(addon_keymaps)
+    def set_selection_overriden(self, context):
+        from . selectOperator import add_shortkeys, remove_shortkeys
+        if context:
+            add_shortkeys()
+        else:
+            remove_shortkeys()
+            
+    selection_overriden = BoolProperty(name="Override Selection", default=True, set=set_selection_overriden, get=get_selection_overriden)
+    
     ''' Profile List '''
     profile_list = CollectionProperty(type = ListItem)
     list_index = IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
diff --git a/src/selectOperator.py b/src/selectOperator.py
index 6223a1b..d9f34f1 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -43,7 +43,9 @@ class SelectionOperator(bpy.types.Operator):
             context.scene.frame_current = context.scene.frame_current
             refreshMaterials()
         
-        if self.toggle:
+        if context.user_preferences.inputs.select_mouse == 'RIGHT':
+            return {'FINISHED'}
+        elif self.toggle:
             return {'FINISHED'}
         return {'PASS_THROUGH'}
 
@@ -53,6 +55,7 @@ class SelectionOperator(bpy.types.Operator):
         return self.execute(context)
 
 addon_keymaps = []
+addin_kmis = []
 def add_shortkeys():
     def prepKmi(kmi):
         kmi.properties.toggle = False
@@ -67,21 +70,25 @@ def add_shortkeys():
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     prepKmi(addon_kmi)
+    addin_kmis.append(addon_kmi)
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     addon_kmi.shift = True
     prepKmi(addon_kmi)
     addon_kmi.properties.toggle = True
+    addin_kmis.append(addon_kmi)
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     addon_kmi.ctrl = True
     prepKmi(addon_kmi)
     addon_kmi.properties.center = True
     addon_kmi.properties.object = True
+    addin_kmis.append(addon_kmi)
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     addon_kmi.alt = True
     addon_kmi.properties.enumerate = True
+    addin_kmis.append(addon_kmi)
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     addon_kmi.shift = True
@@ -90,6 +97,7 @@ def add_shortkeys():
     addon_kmi.properties.center = True
     addon_kmi.properties.extend = True
     addon_kmi.properties.toggle = True
+    addin_kmis.append(addon_kmi)
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     addon_kmi.ctrl = True
@@ -97,6 +105,7 @@ def add_shortkeys():
     prepKmi(addon_kmi)
     addon_kmi.properties.center = True
     addon_kmi.properties.enumerate = True
+    addin_kmis.append(addon_kmi)
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     addon_kmi.shift = True
@@ -104,6 +113,7 @@ def add_shortkeys():
     prepKmi(addon_kmi)
     addon_kmi.properties.enumerate = True
     addon_kmi.properties.toggle = True
+    addin_kmis.append(addon_kmi)
     
     addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
     addon_kmi.shift = True
@@ -113,12 +123,16 @@ def add_shortkeys():
     addon_kmi.properties.center = True
     addon_kmi.properties.enumerate = True
     addon_kmi.properties.toggle = True
+    addin_kmis.append(addon_kmi)
     
     addon_keymaps.append(addon_km)
     
 def remove_shortkeys():
     wm = bpy.context.window_manager
-    for km in addon_keymaps:
-        wm.keyconfigs.addon.keymaps.remove(km)
         
-    addon_keymaps.clear()
\ No newline at end of file
+    for km in addon_keymaps:
+        for kmi in addin_kmis:
+            km.keymap_items.remove(kmi)
+            
+    addon_keymaps.clear()
+    addin_kmis.clear()
\ No newline at end of file

commit 7d053109f46e93346380549e461878d2c7a26a1b
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Wed Feb 8 16:13:55 2017 +0100

    v2.3.4 final left-click selection fix

diff --git a/README.md b/README.md
index 3d475b8..74ed4f7 100644
--- a/README.md
+++ b/README.md
@@ -38,6 +38,8 @@ The speed of future development of this plugin depends on community donations. I
   - Maciek Ptaszynski
 
 ## Changelog
+  - 2.3.4:
+    - Bugfix for left-click selection
   - 2.3.3:
     - Bugfix (light scale and rotation not exporting, profiles not copying correctly)
     - Button to easily fix broken texture paths
diff --git a/build/blender-light-studio.zip b/build/blender-light-studio.zip
index 8a6f531..4674b5e 100644
Binary files a/build/blender-light-studio.zip and b/build/blender-light-studio.zip differ
diff --git a/src/__init__.py b/src/__init__.py
index 70e8d73..256fe82 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 3),
+    "version": (2, 3, 4),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
diff --git a/src/selectOperator.py b/src/selectOperator.py
index b05bde5..6223a1b 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -42,8 +42,10 @@ class SelectionOperator(bpy.types.Operator):
                     
             context.scene.frame_current = context.scene.frame_current
             refreshMaterials()
-            
-        return {'FINISHED'}
+        
+        if self.toggle:
+            return {'FINISHED'}
+        return {'PASS_THROUGH'}
 
     def invoke(self, context, event):
         self.location[0] = event.mouse_region_x

commit 7e2b54e506b30f7fadbae7b1bcaa9afa389462c3
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Tue Feb 7 21:49:57 2017 +0100

    v2.3.3 bugfix, fix for missing textures

diff --git a/README.md b/README.md
index ea87fc7..3d475b8 100644
--- a/README.md
+++ b/README.md
@@ -38,6 +38,9 @@ The speed of future development of this plugin depends on community donations. I
   - Maciek Ptaszynski
 
 ## Changelog
+  - 2.3.3:
+    - Bugfix (light scale and rotation not exporting, profiles not copying correctly)
+    - Button to easily fix broken texture paths
   - 2.3.2:
     - Fix for left-click selection
   - 2.3.1:
diff --git a/build/blender-light-studio.zip b/build/blender-light-studio.zip
index 2c6ef96..8a6f531 100644
Binary files a/build/blender-light-studio.zip and b/build/blender-light-studio.zip differ
diff --git a/src/__init__.py b/src/__init__.py
index cd6f746..70e8d73 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 2),
+    "version": (2, 3, 3),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
diff --git a/src/gui.py b/src/gui.py
index d1115a7..a47651a 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -146,4 +146,24 @@ class BLS_ProfileImportExport(bpy.types.Panel):
         col = layout.column(align=True)
         col.operator('bls.export_profiles', text="Export Selected Profile")
         col.operator('bls.export_profiles', text="Export All Profiles").all=True
-        col.operator('bls.import_profiles')
\ No newline at end of file
+        col.operator('bls.import_profiles')
+        
+class BLS_Misc(bpy.types.Panel):
+    bl_idname = "bls_misc"
+    bl_label = "Misc"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "TOOLS"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+            
+    def draw(self, context):
+        layout = self.layout
+        scene = context.scene
+        
+        props = scene.BLStudio
+              
+        col = layout.column(align=True)
+        col.operator('bls.find_missing_textures')
\ No newline at end of file
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 07c7b8a..b5d96df 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -172,22 +172,37 @@ class LIST_OT_CopyItem(bpy.types.Operator):
         # whats the difference
         new_objects = (A ^ B)
         
-        # make icon material single user and update selection drivers
+        # make light material single user and update selection drivers
         bpy.ops.group.objects_remove_all()
         bpy.ops.group.create(name='BLS_Light')
-        for ob in new_objects:
-            if ob.name.startswith('BLS_CONTROLLER.'):
-                for id, mat in enumerate(ob.data.materials):
+        
+        for lg in new_objects:
+            if lg.name.startswith('BLS_LIGHT_GRP.'):
+                controller = [c for c in family(lg) if c.name.startswith("BLS_CONTROLLER.")][0]
+                lmesh = [l for l in family(lg) if l.name.startswith("BLS_LIGHT_MESH.")][0]
+                
+                light_mat = None
+                for id, mat in enumerate(controller.data.materials):
                     if mat.name.startswith('BLS_icon_ctrl'):
                         mat = mat.copy()
-                        ob.data.materials[id] = mat
+                        controller.data.materials[id] = mat
                         
                         for d in mat.animation_data.drivers:
-                            d.driver.variables[0].targets[0].id = scene.objects['BLS_LIGHT_MESH.'+ob.name.split('.')[1]]
+                            d.driver.variables[0].targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
                         
                         for d in mat.node_tree.animation_data.drivers:
                             for v in d.driver.variables:
-                                v.targets[0].id = scene.objects['BLS_LIGHT_MESH.'+ob.name.split('.')[1]]
+                                v.targets[0].id = scene.objects['BLS_LIGHT_MESH.'+controller.name.split('.')[1]]
+                                
+                    elif mat.name.startswith('BLS_light'):
+                        #mat = mat.copy()
+                        light_mat = mat.copy()
+                        controller.data.materials[id] = light_mat
+                        light_mat.node_tree.nodes['Light Texture'].image = light_mat.node_tree.nodes['Light Texture'].image.copy()
+                        
+                for id, mat in enumerate(lmesh.data.materials):
+                    if mat.name.startswith('BLS_light'):
+                        lmesh.data.materials[id] = light_mat               
                             
         # revert visibility
         for ob in chain(obsToCopy, new_objects):
@@ -357,6 +372,12 @@ class ImportProfiles(bpy.types.Operator):
                 controller.location.y = light['position'][1]
                 controller.location.z = light['position'][2]
                 
+                controller.scale.x = light['scale'][0]
+                controller.scale.y = light['scale'][1]
+                controller.scale.z = light['scale'][2]
+                
+                controller.rotation_euler.z = light['rotation']
+                
                 props.light_muted = light['mute']
                 controller.material_slots[1].material.node_tree.nodes["Group"].inputs[2].default_value = light['Intensity']
                 controller.material_slots[1].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
@@ -391,6 +412,8 @@ def compose_profile(list_index):
         light = {}
         light['radius'] = lmesh.location.x
         light['position'] = [controller.location.x, controller.location.y, controller.location.z]
+        light['scale'] = [controller.scale.x, controller.scale.y, controller.scale.z]
+        light['rotation'] = controller.rotation_euler.z
         light['mute'] = props.light_muted
         texpath = controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath
         light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
@@ -449,4 +472,21 @@ class ExportProfiles(bpy.types.Operator):
     def invoke(self, context, event):
         self.filepath = "profile.bls"
         context.window_manager.fileselect_add(self)
-        return {'RUNNING_MODAL'}
\ No newline at end of file
+        return {'RUNNING_MODAL'}
+    
+class ExportProfiles(bpy.types.Operator):
+    """ Find Missing Textures """
+ 
+    bl_idname = "bls.find_missing_textures"
+    bl_label = "Find Missing Textures"
+    #bl_options = {"INTERNAL"}
+    
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        bpy.ops.file.find_missing_files(directory=os.path.join(dir, "textures_real_lights"))        
+        bpy.context.scene.frame_current = bpy.context.scene.frame_current
+        return{'FINISHED'}
\ No newline at end of file

commit c9ee179cc2498b9753b028d34333c1016f76b21c
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Tue Feb 7 18:41:33 2017 +0100

    v2.3.2 bugfix

diff --git a/README.md b/README.md
index 4ca9b4e..ea87fc7 100644
--- a/README.md
+++ b/README.md
@@ -19,6 +19,7 @@ Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptas
 	- [S] Scale light mesh
 	- [G] Grab (meant to be used in rendered preview)
 	- [R] Rotate
+  - Import/Export of light profiles
 
 ## Donations
 The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
@@ -37,6 +38,10 @@ The speed of future development of this plugin depends on community donations. I
   - Maciek Ptaszynski
 
 ## Changelog
+  - 2.3.2:
+    - Fix for left-click selection
+  - 2.3.1:
+    - Import/Export profiles
   - 2.3.0:
     - 3D Edit (first iteration of Light Brush)
     - Bugfixes
diff --git a/build/blender-light-studio.zip b/build/blender-light-studio.zip
index 453add2..2c6ef96 100644
Binary files a/build/blender-light-studio.zip and b/build/blender-light-studio.zip differ
diff --git a/src/__init__.py b/src/__init__.py
index 304caba..cd6f746 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 1),
+    "version": (2, 3, 2),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
diff --git a/src/selectOperator.py b/src/selectOperator.py
index 803272d..b05bde5 100644
--- a/src/selectOperator.py
+++ b/src/selectOperator.py
@@ -25,7 +25,10 @@ class SelectionOperator(bpy.types.Operator):
             obname = context.active_object.name
             deactivate = obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.')
             
-        bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object, location=(self.location[0] , self.location[1] ))
+        result = bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object, location=(self.location[0] , self.location[1] ))
+        if 'FINISHED' not in result:
+            return {'PASS_THROUGH'}
+        
         if context.active_object:
             obname = context.active_object.name
             if obname.startswith('BLS_CONTROLLER.'):

commit 3b2dab975c35527d669ca8df6418bdb6905d4808
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Tue Feb 7 05:55:26 2017 +0100

    v2.3.1 build

diff --git a/build/blender-light-studio.zip b/build/blender-light-studio.zip
index ce6d9df..453add2 100644
Binary files a/build/blender-light-studio.zip and b/build/blender-light-studio.zip differ

commit 2432e7e58ee308479df4bbac7ef19cb5aacd752f
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Tue Feb 7 05:53:14 2017 +0100

    v2.3.1 - profiles import/export

diff --git a/src/__init__.py b/src/__init__.py
index 3ca220a..304caba 100644
--- a/src/__init__.py
+++ b/src/__init__.py
@@ -22,7 +22,7 @@ bl_info = {
     "name": "Blender Light Studio",
     "description": "Easy setup for complex studio lighting",
     "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
-    "version": (2, 3, 0),
+    "version": (2, 3, 1),
     "blender": (2, 78, 0),
     "location": "View3D -> Tools -> Light Studio",
     "wiki_url": "",
diff --git a/src/gui.py b/src/gui.py
index 35dd464..d1115a7 100644
--- a/src/gui.py
+++ b/src/gui.py
@@ -47,10 +47,8 @@ class BLS_ProfileList(bpy.types.Panel):
         col.operator('bls_list.copy_profile', icon='GHOST', text="")
         
         col.separator()
-        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'         
-        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'         
-        
-        row = layout.row()
+        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'
+        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'
                 
 class BLS_Lights(bpy.types.Panel):
     bl_idname = "bls_lights"
@@ -126,4 +124,26 @@ class BLS_Visibility(bpy.types.Panel):
         layout = self.layout
         col = layout.column(align=True)
         col.operator('object.mute_other_lights')
-        col.operator('object.show_all_lights')
\ No newline at end of file
+        col.operator('object.show_all_lights')
+        
+class BLS_ProfileImportExport(bpy.types.Panel):
+    bl_idname = "bls_profile_import_export"
+    bl_label = "Import/Export"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "TOOLS"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+            
+    def draw(self, context):
+        layout = self.layout
+        scene = context.scene
+        
+        props = scene.BLStudio
+              
+        col = layout.column(align=True)
+        col.operator('bls.export_profiles', text="Export Selected Profile")
+        col.operator('bls.export_profiles', text="Export All Profiles").all=True
+        col.operator('bls.import_profiles')
\ No newline at end of file
diff --git a/src/light_profiles.py b/src/light_profiles.py
index 54a9fd1..07c7b8a 100644
--- a/src/light_profiles.py
+++ b/src/light_profiles.py
@@ -125,44 +125,6 @@ class LIST_OT_DeleteItem(bpy.types.Operator):
  
         return{'FINISHED'}
     
-    
-class LIST_OT_DeleteItem(bpy.types.Operator):
-    """ Delete the selected profile from the list """
- 
-    bl_idname = "bls_list.delete_profile"
-    bl_label = "Deletes an profile"
-    bl_options = {"INTERNAL"}
- 
-    @classmethod
-    def poll(self, context):
-        """ Enable if there's something in the list """
-        return len(context.scene.BLStudio.profile_list)
- 
-    def execute(self, context):
-        props = context.scene.BLStudio
-        list = props.profile_list
-        index = props.list_index
- 
-        list.remove(index)
-        
-        ''' Delete/Switch Hierarchy stuff '''
-        #delete objects from current profile           
-        obsToRemove = family(context.scene.objects[props.last_empty])
-        for ob in obsToRemove:
-            context.scene.objects.unlink(ob)
-            for gr in ob.users_group:
-                gr.objects.unlink(ob)
-            ob.user_clear()
-            ob.use_fake_user = False
-            bpy.data.objects.remove(ob)
-        
-        # update index
-        if index > 0:
-            index = index - 1
-        props.list_index = index
- 
-        return{'FINISHED'}
-    
 
 class LIST_OT_CopyItem(bpy.types.Operator):
     """ Copy an item in the list """
@@ -339,4 +301,152 @@ def update_list_index(self, context):
         
     props.last_empty = selected_profile.empty_name
     
-        
\ No newline at end of file
+        
+        
+# import/export
+import json, time
+script_file = os.path.realpath(__file__)
+dir = os.path.dirname(script_file)
+class ImportProfiles(bpy.types.Operator):
+    """ Import Profiles from File """
+ 
+    bl_idname = "bls.import_profiles"
+    bl_label = "Import Profiles"
+    #bl_options = {"INTERNAL"}
+    
+    filepath = bpy.props.StringProperty(default="*.bls", subtype="FILE_PATH")
+ 
+    @classmethod
+    def poll(self, context):
+        return True
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        plist = props.profile_list
+        
+        with open(self.filepath, 'r') as f:
+            file = f.read()
+        f.closed
+        
+        file = json.loads(file)
+        for profile in file["profiles"]:
+            print(profile)
+            bpy.ops.bls_list.new_profile()
+            props.list_index = len(plist)-1
+            date = time.localtime()
+            plist[-1].name = profile["name"] + ' {}-{:02}-{:02} {:02}:{:02}'.format(str(date.tm_year)[-2:], date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
+            
+            #lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
+            profile_empty = context.scene.objects[plist[-1].empty_name]
+            
+            for light in profile["lights"]:
+                # before
+                A = set(profile_empty.children)
+                
+                bpy.ops.scene.add_blender_studio_light()
+                
+                # after operation
+                B = set(profile_empty.children)
+                
+                # whats the difference
+                lgrp = (A ^ B).pop()
+                controller = [c for c in family(lgrp) if "BLS_CONTROLLER" in c.name][0]
+                props.light_radius = light['radius']
+                
+                controller.location.x = light['position'][0]
+                controller.location.y = light['position'][1]
+                controller.location.z = light['position'][2]
+                
+                props.light_muted = light['mute']
+                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[2].default_value = light['Intensity']
+                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[3].default_value = light['Opacity']
+                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[4].default_value = light['Falloff']
+                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[5].default_value = light['Color Saturation']
+                controller.material_slots[1].material.node_tree.nodes["Group"].inputs[6].default_value = light['Half']
+                
+                if os.path.isabs(light['tex']):
+                    controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = light['tex']
+                else:
+                    controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath = os.path.join(dir, "textures_real_lights", light['tex'])
+                    
+        
+ 
+        return{'FINISHED'}
+    
+    def invoke(self, context, event):
+        context.window_manager.fileselect_add(self)
+        return {'RUNNING_MODAL'}
+
+def compose_profile(list_index):
+    props = bpy.context.scene.BLStudio
+    
+    profile_dict = {}
+    profile_dict['name'] = props.profile_list[list_index].name
+    profile_dict['lights']= []
+    lgroups = [lg for lg in family(bpy.data.objects[props.profile_list[list_index].empty_name]) if "BLS_LIGHT_GRP" in lg.name]
+    print(lgroups)
+    for lg in lgroups:
+        controller = [c for c in family(lg) if "BLS_CONTROLLER" in c.name][0]
+        lmesh = [l for l in family(lg) if "BLS_LIGHT_MESH" in l.name][0]
+        light = {}
+        light['radius'] = lmesh.location.x
+        light['position'] = [controller.location.x, controller.location.y, controller.location.z]
+        light['mute'] = props.light_muted
+        texpath = controller.material_slots[1].material.node_tree.nodes["Light Texture"].image.filepath
+        light['tex'] = texpath.split(bpy.path.native_pathsep("\\textures_real_lights\\"))[-1]
+        
+        light['Intensity'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[2].default_value
+        light['Opacity'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[3].default_value
+        light['Falloff'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[4].default_value
+        light['Color Saturation'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[5].default_value
+        light['Half'] = controller.material_slots[1].material.node_tree.nodes["Group"].inputs[6].default_value
+        
+        profile_dict['lights'].append(light)
+        
+    return profile_dict
+        
+class ExportProfiles(bpy.types.Operator):
+    """ Export Profiles to File """
+ 
+    bl_idname = "bls.export_profiles"
+    bl_label = "Export"
+    #bl_options = {"INTERNAL"}
+    
+    filepath = bpy.props.StringProperty(default="profile.bls", subtype="FILE_PATH")
+    all = bpy.props.BoolProperty(default=False, name="Export All Profiles")
+ 
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        index = props.list_index
+            
+        export_file = {}
+        date = time.localtime()
+        export_file['date'] = '{}-{:02}-{:02} {:02}:{:02}'.format(date.tm_year, date.tm_mon, date.tm_mday, date.tm_hour, date.tm_min)
+        export_file['version'] = '1'
+        profiles_to_export = export_file['profiles'] = []
+        
+        if self.all:
+            for p in range(len(props.profile_list)):
+                profiles_to_export.append(compose_profile(p))
+        else:
+            profiles_to_export.append(compose_profile(index))
+        
+        #file = open(self.filepath, 'w')
+        #file.write(json.dumps(export_file, indent=4))
+        #file.close()
+        
+        with open(self.filepath, 'w') as f:
+            f.write(json.dumps(export_file, indent=4))
+        f.closed
+        
+        return{'FINISHED'}
+    
+    def invoke(self, context, event):
+        self.filepath = "profile.bls"
+        context.window_manager.fileselect_add(self)
+        return {'RUNNING_MODAL'}
\ No newline at end of file

commit 54f3a782592f12f3738053c5437f1a3b3bf28faa
Author: Amin Persia <leomoon@gmail.com>
Date:   Sun Feb 5 21:14:02 2017 -0800

    added gui

diff --git a/GUI b/GUI
new file mode 100644
index 0000000..98404f0
--- /dev/null
+++ b/GUI
@@ -0,0 +1,45 @@
+ Studio
+    [Delete Studio]
+    [Prepare Layout]
+
+ Profiles
+    ------------------------- [+]
+    | Profile 1               | [-]
+    |                         | [c]
+    |                         |
+    |                         | []
+    |                         | []
+    -------------------------
+
+ Lights
+    [Add Light]      [Delete Light]
+
+ Selected Light
+    [3D Edit]
+    -----------------------------
+    |                             |
+    |                             |
+    |                             |
+    |                             |
+    |                             |
+    | Soft Box A                  |
+    -----------------------------
+    [ ] Mute Light
+    Color:                [       ]
+    -----------------------------
+    |  Intensity:        2.000  |
+    |  Opacity:          1.000  |
+    |  Falloff:          1.000  |
+    |  Color Saturation: 0.300  |
+    |  Half:             0.000  |
+    |  Light Distance:  30.000  |
+    -----------------------------
+
+ Visibility Options
+    [Show Only This Light]
+    [Show All Lights]
+
+ Import / Export
+    [Export Selected Profile]
+    [Export All Profiles]
+    [Import Profile]
\ No newline at end of file

commit ad5c06084f6fb80c927a2d4dcd415901c8baa8d1
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Wed Feb 1 10:20:43 2017 -0800

    new donor

diff --git a/README.md b/README.md
index 1d21612..4ca9b4e 100644
--- a/README.md
+++ b/README.md
@@ -28,6 +28,7 @@ The speed of future development of this plugin depends on community donations. I
 
 ## Donors
   - Damir Simovski
+  - Krzysztof Czerwiski
 
 ## Main Programmer
   - Marcin Zielinski

commit 8663b04aeb5ffcade0b38ab7229e8b21b9240023
Author: theres1 <martin.zielinsky@gmail.com>
Date:   Mon Jan 30 05:23:48 2017 +0100

    zip

diff --git a/build/blender-light-studio.zip b/build/blender-light-studio.zip
new file mode 100644
index 0000000..ce6d9df
Binary files /dev/null and b/build/blender-light-studio.zip differ

commit 323786b5c403ae629bd4aa4bfe9fb723a4624c6e
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 27 11:20:48 2017 -0800

    added lic

diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..f015d11
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,675 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    {one line to give the program's name and a brief idea of what it does.}
+    Copyright (C) {year}  {name of author}
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    {project}  Copyright (C) {year}  {fullname}
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+

commit 2d7b2e89b54b34ac81980c14da03cf463213c5ff
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 27 11:20:00 2017 -0800

    donation

diff --git a/README.md b/README.md
index d275814..1d21612 100644
--- a/README.md
+++ b/README.md
@@ -27,7 +27,7 @@ The speed of future development of this plugin depends on community donations. I
   - LeoMoon Studios
 
 ## Donors
-  - NULL
+  - Damir Simovski
 
 ## Main Programmer
   - Marcin Zielinski

commit c767321344f9d319ff7bdbde170355259a663686
Author: Amin Persia <leomoon@gmail.com>
Date:   Fri Jan 27 10:47:56 2017 -0800

    upload

diff --git a/src/BLS.blend b/src/BLS.blend
new file mode 100644
index 0000000..68fa33d
Binary files /dev/null and b/src/BLS.blend differ
diff --git a/src/__init__.py b/src/__init__.py
new file mode 100644
index 0000000..3ca220a
--- /dev/null
+++ b/src/__init__.py
@@ -0,0 +1,70 @@
+'''
+Copyright (C) 2015 Marcin Zielinski
+martin.zielinsky at gmail.com
+
+Created by Marcin Zielinski
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+'''
+
+bl_info = {
+    "name": "Blender Light Studio",
+    "description": "Easy setup for complex studio lighting",
+    "author": "LeoMoon Studios, Marcin Zielinski, special thanks to Maciek Ptaszynski for initial scene",
+    "version": (2, 3, 0),
+    "blender": (2, 78, 0),
+    "location": "View3D -> Tools -> Light Studio",
+    "wiki_url": "",
+    "category": "User Interface" }
+    
+    
+import bpy      
+
+# load and reload submodules
+##################################    
+    
+from . import developer_utils
+modules = developer_utils.setup_addon_modules(__path__, __name__, "bpy" in locals())
+
+
+
+# register
+################################## 
+
+import traceback
+
+from . light_operators import Blender_Light_Studio_Properties
+from . import deleteOperator
+from . import selectOperator
+from . import light_preview_list
+def register():
+    try: bpy.utils.register_module(__name__)
+    except: traceback.print_exc()
+    bpy.types.Scene.BLStudio = bpy.props.PointerProperty(name="Blender Light Studio Properties", type = Blender_Light_Studio_Properties)
+    bpy.types.Object.protected = bpy.props.BoolProperty(name = 'protected', default = False)
+    selectOperator.add_shortkeys()
+    deleteOperator.add_shortkeys()
+    light_preview_list.register()
+    
+    print("Registered {} with {} modules".format(bl_info["name"], len(modules)))
+    
+
+def unregister():
+    selectOperator.remove_shortkeys()
+    #deleteOperator.remove_shortkeys()
+    try: bpy.utils.unregister_module(__name__)
+    except: traceback.print_exc()
+    
+    print("Unregistered {}".format(bl_info["name"]))
+    
\ No newline at end of file
diff --git a/src/common.py b/src/common.py
new file mode 100644
index 0000000..cb36644
--- /dev/null
+++ b/src/common.py
@@ -0,0 +1,52 @@
+def isFamily(ob=None):
+    if not ob:
+        ob = bpy.context.scene.objects.active
+
+    if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
+    if not ob.name.startswith('BLS_'): return False
+    while ob.parent:
+        ob = ob.parent
+        if ob.name.startswith('BLENDER_LIGHT_STUDIO'): return True
+    
+    return False
+
+def family(object):
+    ''' Object + Grand children without ancestors '''
+    family = [object.children[:]+(object,)]
+      
+    def rec(object, family):
+        family[0] += object.children
+        for ob in object.children:
+            rec(ob, family)
+        
+    for ob in object.children:
+        rec(ob, family)
+        
+    return family.pop()
+
+def findLightGrp(ob):
+    while ob.parent:
+        ob = ob.parent
+        if ob.name.startswith('BLS_LIGHT_GRP.'): return ob
+    return None
+
+def getLightMesh():
+    obs = bpy.context.scene.objects
+    lightGrp = obs.active
+    light_no = lightGrp.name.split('.')[1]
+    return obs[obs.find('BLS_LIGHT_MESH.'+light_no)]
+
+def getLightController():
+    obs = bpy.context.scene.objects
+    lightGrp = obs.active
+    light_no = lightGrp.name.split('.')[1]
+    return obs[obs.find('BLS_CONTROLLER.'+light_no)]
+
+import bpy
+def refreshMaterials():
+    #controllers = [ob for ob in family(findLightGrp(context.active_object).parent) if ob.name.startswith('BLS_CONTROLLER.')]
+    controllers = (ob for ob in bpy.context.scene.objects if ob.name.startswith('BLS_CONTROLLER.') and isFamily(ob))
+    for cntrl in controllers:
+        mat = [m for m in cntrl.data.materials if m.name.startswith('BLS_icon_ctrl')][0]
+        mixNode = mat.node_tree.nodes['Mix Shader'].inputs['Fac']
+        mixNode.default_value = mixNode.default_value
\ No newline at end of file
diff --git a/src/deleteOperator.py b/src/deleteOperator.py
new file mode 100644
index 0000000..b300f92
--- /dev/null
+++ b/src/deleteOperator.py
@@ -0,0 +1,61 @@
+import bpy
+from bpy.props import BoolProperty
+from . common import findLightGrp
+
+class DeleteOperator(bpy.types.Operator):
+    """ Custom delete """
+    bl_idname = "object.delete_custom" 
+    bl_label = "Custom Delete"
+    bl_options = {'REGISTER', 'UNDO'}
+
+    use_global = BoolProperty(default = False)
+
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
+    
+    def execute(self, context):
+        protected_groups = [findLightGrp(ob) for ob in context.selected_objects if ob.protected]
+        protected_objects = (ob for ob in context.selected_objects if ob.protected)
+        
+        for obj in protected_objects:
+            context.scene.objects.active = obj
+            if hasattr(obj, 'use_fake_user'):
+                obj.use_fake_user = False
+            bpy.ops.scene.delete_blender_studio_light()
+        
+        bpy.ops.object.delete(use_global=self.use_global)
+
+        return {'FINISHED'}
+
+    def invoke(self, context, event):
+        wm = context.window_manager
+        return wm.invoke_confirm(self, event)
+        
+addon_keymaps = []
+def add_shortkeys():       
+    wm = bpy.context.window_manager
+    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
+    addon_kmi.properties.use_global = False
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'X', 'PRESS')
+    addon_kmi.shift = True
+    addon_kmi.properties.use_global = True
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
+    addon_kmi.properties.use_global = False
+    
+    addon_kmi = addon_km.keymap_items.new(DeleteOperator.bl_idname, 'DEL', 'PRESS')
+    addon_kmi.shift = True
+    addon_kmi.properties.use_global = True
+    
+    addon_keymaps.append(addon_km)
+
+def remove_shortkeys():
+    wm = bpy.context.window_manager
+    for km in addon_keymaps:
+        wm.keyconfigs.addon.keymaps.remove(km)
+        
+    addon_keymaps.clear()
diff --git a/src/developer_utils.py b/src/developer_utils.py
new file mode 100644
index 0000000..f4c4535
--- /dev/null
+++ b/src/developer_utils.py
@@ -0,0 +1,38 @@
+import os
+import sys
+import pkgutil
+import importlib
+
+def setup_addon_modules(path, package_name, reload):
+    """
+    Imports and reloads all modules in this addon. 
+    
+    path -- __path__ from __init__.py
+    package_name -- __name__ from __init__.py
+    """
+    def get_submodule_names(path = path[0], root = ""):
+        module_names = []
+        for importer, module_name, is_package in pkgutil.iter_modules([path]):
+            if is_package:
+                sub_path = os.path.join(path, module_name)
+                sub_root = root + module_name + "."
+                module_names.extend(get_submodule_names(sub_path, sub_root))
+            else: 
+                module_names.append(root + module_name)
+        return module_names 
+
+    def import_submodules(names):
+        modules = []
+        for name in names:
+            modules.append(importlib.import_module("." + name, package_name))
+        return modules
+        
+    def reload_modules(modules):
+        for module in modules:
+            importlib.reload(module)
+    
+    names = get_submodule_names()
+    modules = import_submodules(names)        
+    if reload: 
+        reload_modules(modules) 
+    return modules
diff --git a/src/gui.py b/src/gui.py
new file mode 100644
index 0000000..35dd464
--- /dev/null
+++ b/src/gui.py
@@ -0,0 +1,129 @@
+import bpy
+import os
+from . common import getLightMesh
+
+class BLS_Studio(bpy.types.Panel):
+    bl_idname = "bls_studio"
+    bl_label = "Studio"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "TOOLS"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'    
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        if not context.scene.BLStudio.initialized: col.operator('scene.create_blender_light_studio')
+        if context.scene.BLStudio.initialized: col.operator('scene.delete_blender_light_studio')
+        col.operator('scene.prepare_blender_studio_light')
+
+class BLS_ProfileList(bpy.types.Panel):
+    bl_idname = "bls_profile_list"
+    bl_label = "Profiles"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "TOOLS"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+            
+    def draw(self, context):
+        layout = self.layout
+        scene = context.scene
+        
+        props = scene.BLStudio
+        
+        row = layout.row()
+        col = row.column()
+        col.template_list("BLS_UL_List", "Profile_List", props, "profile_list", props, "list_index", rows=5)
+        
+        col = row.column(align=True)
+        col.operator('bls_list.new_profile', icon='ZOOMIN', text="")
+        col.operator('bls_list.delete_profile', icon='ZOOMOUT', text="")
+        col.operator('bls_list.copy_profile', icon='GHOST', text="")
+        
+        col.separator()
+        col.operator('bls_list.move_profile', text='', icon="TRIA_UP").direction = 'UP'         
+        col.operator('bls_list.move_profile', text='', icon="TRIA_DOWN").direction = 'DOWN'         
+        
+        row = layout.row()
+                
+class BLS_Lights(bpy.types.Panel):
+    bl_idname = "bls_lights"
+    bl_label = "Lights"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "TOOLS"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.BLStudio.profile_list)
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        row = col.row(align=True)
+        row.operator('scene.add_blender_studio_light', text='Add Light')
+        row.operator('scene.delete_blender_studio_light', text='Delete Light')
+        
+class BLS_Selected(bpy.types.Panel):
+    bl_idname = "bls_selected"
+    bl_label = "Selected Light"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "TOOLS"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'    
+    
+    def draw(self, context):
+        if context.scene.objects.active and (context.scene.objects.active.name.startswith('BLS_CONTROLLER') or context.scene.objects.active.name.startswith('BLS_LIGHT_MESH')):
+            layout = self.layout
+            wm = context.window_manager
+            
+            col = layout.column(align=True)
+            col.operator('bls.light_brush', text="3D Edit", icon='CURSOR')
+            
+            box = layout.box()
+            col = box.column()
+            col.template_icon_view(wm, "bls_tex_previews", show_labels=True)
+            col.label(os.path.splitext(wm.bls_tex_previews)[0])
+            
+            col = layout.column(align=True)
+            col.prop(context.scene.BLStudio, 'light_muted')
+            
+            
+            layout.separator()
+            try:
+                bls_inputs = getLightMesh().active_material.node_tree.nodes["Group"].inputs
+                for input in bls_inputs[1:]:
+                    if input.type == "RGBA":
+                        layout.prop(input, 'default_value', input.name)
+                        col = layout.column(align=True)
+                    else:
+                        col.prop(input, 'default_value', input.name)
+            except:
+                col.label("BLS_light material is not valid.")
+            col.prop(context.scene.BLStudio, 'light_radius')
+                
+class BLS_Visibility(bpy.types.Panel):
+    bl_idname = "bls_visibility"
+    bl_label = "Visibility Options"
+    bl_space_type = "VIEW_3D"
+    bl_region_type = "TOOLS"
+    bl_category = "Light Studio"
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and len(context.scene.BLStudio.profile_list)
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        col.operator('object.mute_other_lights')
+        col.operator('object.show_all_lights')
\ No newline at end of file
diff --git a/src/light_brush.py b/src/light_brush.py
new file mode 100644
index 0000000..1d99ac2
--- /dev/null
+++ b/src/light_brush.py
@@ -0,0 +1,541 @@
+import bpy
+from bpy_extras import view3d_utils
+from math import *
+from mathutils.geometry import intersect_line_sphere
+from mathutils import Vector
+from bpy.props import *
+from . common import isFamily, family, findLightGrp, getLightMesh, getLightController
+
+
+           
+def raycast(context, event, diff):
+    controller = getLightController()
+    #####
+    """Run this function on left mouse, execute the ray cast"""
+    # get the context arguments
+    scene = context.scene
+    region = context.region
+    rv3d = context.region_data
+    coord = event.mouse_region_x, event.mouse_region_y
+
+    # get the ray from the viewport and mouse
+    view_vector = view3d_utils.region_2d_to_vector_3d(region, rv3d, coord)
+    ray_origin = view3d_utils.region_2d_to_origin_3d(region, rv3d, coord)
+    
+    ray_target = ray_origin + view_vector
+    
+    def visible_objects_and_duplis():
+        """Loop over (object, matrix) pairs (mesh only)"""
+
+        for obj in context.visible_objects:
+            if isFamily(obj):
+                continue
+            
+            if obj.type == 'MESH':
+                yield (obj, obj.matrix_world.copy())
+
+            if obj.dupli_type != 'NONE':
+                obj.dupli_list_create(scene)
+                for dob in obj.dupli_list:
+                    obj_dupli = dob.object
+                    if obj_dupli.type == 'MESH':
+                        yield (obj_dupli, dob.matrix.copy())
+
+            obj.dupli_list_clear()
+
+    def obj_ray_cast(obj, matrix):
+        """Wrapper for ray casting that moves the ray into object space"""
+
+        # get the ray relative to the object
+        matrix_inv = matrix.inverted()
+        ray_origin_obj = matrix_inv * ray_origin
+        ray_target_obj = matrix_inv * ray_target
+        ray_direction_obj = ray_target_obj - ray_origin_obj
+
+        # cast the ray
+        success, location, normal, face_index = obj.ray_cast(ray_origin_obj, ray_direction_obj)
+
+        if success:
+            return location, normal, face_index
+        else:
+            return None, None, None
+    
+    # cast rays and find the closest object
+    best_length_squared = -1.0
+    best_obj = None
+    normal = None
+    location = None
+
+    for obj, matrix in visible_objects_and_duplis():
+        if obj.type == 'MESH':
+            hit, hit_normal, face_index = obj_ray_cast(obj, matrix)
+            if hit is not None:
+                hit_world = matrix * hit
+                length_squared = (hit_world - ray_origin).length_squared
+                if best_obj is None or length_squared < best_length_squared:
+                    best_length_squared = length_squared
+                    best_obj = obj
+                    normal = hit_normal # local space
+                    location = hit_world
+                    
+
+    if best_obj is None:
+        return {'RUNNING_MODAL'}
+    
+    # convert normal from local space to global
+    matrix = best_obj.matrix_world
+    matrix_new = matrix.to_3x3().inverted().transposed()
+    normal = matrix_new * normal
+    normal.normalize()
+    
+    #####
+    
+    position = intersect_line_sphere(
+        location,
+        (normal if diff else view_vector.reflect(normal)) + location,
+        Vector((0,0,0)),
+        context.scene.BLStudio.light_radius,
+        False,
+        )[0]
+    
+    
+    if not position:
+        return {'RUNNING_MODAL'}
+   
+    # ctrl x
+    x,y,z = position
+    ctrl_x = (degrees(atan2(-x, y)) % 360) * (4/360) -2 +0.015
+    
+    # ctrl y
+    deg = copysign(degrees(Vector.angle(Vector((x,y,z)), Vector((x,y,0)))), z)
+    ctrl_y = deg / 90
+    
+    controller.location.x = ctrl_x
+    controller.location.y = ctrl_y
+
+class BLSLightBrush(bpy.types.Operator):
+    """Click on object to position light and reflection"""
+    bl_idname = "bls.light_brush"
+    bl_label = "Light Brush"
+    bl_options = {"UNDO"}
+    
+    pressed = BoolProperty(default=False)
+    aux = BoolProperty(default=False) # is aux operator working
+    diffuse_type = BoolProperty(default=False)
+    
+    @classmethod
+    def poll(cls, context):
+        light = context.scene.objects.active
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.BLStudio.initialized and \
+               light and \
+               isFamily(light) and \
+               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+
+    def modal(self, context, event):
+        #print(event.type, event.value)
+        if self.aux:
+            if event.type in {'LEFTMOUSE', 'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
+                self.aux = False
+            return {'RUNNING_MODAL'}
+        
+        context.area.header_text_set("[LM] Select Face,  [ESC/RM] Quit,  [N] %s,  [S] Scale, [G] Grab, [R] Rotate" % ('Reflection | [Normal]' if self.diffuse_type else '[Reflection] | Normal'))
+        
+        if event.type in {'MIDDLEMOUSE', 'WHEELUPMOUSE', 'WHEELDOWNMOUSE', 'Z', 'LEFT_SHIFT', 'LEFT_ALT', 'LEFT_CTRL'}:
+            # allow navigation
+            return {'PASS_THROUGH'}
+        elif event.type in {'RIGHTMOUSE', 'ESC', 'RET', 'NUMPAD_ENTER'}:
+            context.area.header_text_set()
+            return {'FINISHED'}
+        elif event.type == 'LEFTMOUSE':
+            if event.value == 'PRESS':
+                self.pressed = True
+                raycast(context, event, self.diffuse_type)
+            elif event.value == 'RELEASE':
+                self.pressed = False
+            return {'RUNNING_MODAL'}
+        elif self.pressed and event.type == 'MOUSEMOVE':
+            raycast(context, event, self.diffuse_type)
+            return {'RUNNING_MODAL'}
+        elif event.type == 'S':
+            self.aux = True
+            bpy.ops.bls.resize_light('INVOKE_DEFAULT')
+        elif event.type == 'G':
+            self.aux = True
+            bpy.ops.bls.move_light('INVOKE_DEFAULT')
+        elif event.type == 'R':
+            self.aux = True
+            bpy.ops.bls.rotate_light('INVOKE_DEFAULT')
+        elif event.type == 'N' and event.value == 'PRESS':
+            self.diffuse_type = not self.diffuse_type
+
+        #return {'PASS_THROUGH'}
+        return {'RUNNING_MODAL'}
+
+    def invoke(self, context, event):
+        if context.space_data.type == 'VIEW_3D':
+            context.window_manager.modal_handler_add(self)
+            return {'RUNNING_MODAL'}
+        else:
+            self.report({'WARNING'}, "Active space must be a View3d")
+            return {'CANCELLED'}
+
+
+########################################## Modal AUX Operators ##########################################
+from bpy_extras.view3d_utils import location_3d_to_region_2d as loc3d2d
+import bgl
+def draw_callback_px(self, context): 
+    region = context.region  
+    rv3d = context.space_data.region_3d
+            
+    init2d = self.obLoc[:2]
+    dest2d = self.mouseCoNew[:2]
+
+    # Line drawing
+    bgl.glPushAttrib(bgl.GL_ENABLE_BIT)
+    # glPushAttrib is done to return everything to normal after drawing
+    
+    bgl.glLineStipple(2, 0x9999)
+    bgl.glEnable(bgl.GL_LINE_STIPPLE)
+    
+    bgl.glEnable(bgl.GL_BLEND)
+    bgl.glColor4f(0.0, 0.0, 0.0, 1)
+    #bgl.glLineWidth(2)
+
+    bgl.glBegin(bgl.GL_LINE_STRIP)
+    bgl.glVertex2f(*init2d)
+    bgl.glVertex2f(*dest2d)
+    bgl.glEnd()
+    bgl.glPopAttrib()
+
+    # restore opengl defaults
+    bgl.glLineWidth(1)
+    bgl.glDisable(bgl.GL_BLEND)
+    bgl.glColor4f(0.0, 0.0, 0.0, 1.0)
+
+obj_ref = {}
+obj_ref['resize'] = None
+class BLS_ResizeLight(bpy.types.Operator):
+    """Resize BLS Light Mesh"""
+    bl_idname = "bls.resize_light"
+    bl_label = "Resize BLS Light"
+    bl_options = {"REGISTER", "UNDO"}
+    
+    #mouse and ui
+    mouseCo = FloatVectorProperty()
+    mouseCoNew = FloatVectorProperty(default=(0,0,0))
+    tmp_mouseCo = FloatVectorProperty()
+    obLoc = FloatVectorProperty()
+    
+    #values
+    first_value = FloatVectorProperty()
+    tmp_value = FloatVectorProperty()
+    backup_value = FloatVectorProperty()
+    
+    #operator dependants
+    axis = IntProperty(default=2) # x,y,xy
+    precision = BoolProperty()
+    
+    @classmethod
+    def poll(cls, context):
+        light = context.scene.objects.active
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.BLStudio.initialized and \
+               light and \
+               isFamily(light) and \
+               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+
+    def modal(self, context, event):
+        dist2d = lambda p1, p2: sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
+        
+        if event.type in {'MOUSEMOVE'}:
+            region = context.region  
+            
+            loc2d = [region.width/2, region.height/2]
+            #
+            self.obLoc = (loc2d[0], loc2d[1], 0)
+            
+            self.mouseCoNew = Vector((event.mouse_region_x, event.mouse_region_y, 0))
+            unit = dist2d(loc2d, self.mouseCo)
+            dist = dist2d(loc2d, self.mouseCoNew)
+            
+            scale = (dist/unit)
+            first_scale = Vector(self.first_value)
+            
+            scale_xyz = first_scale + (first_scale * scale - first_scale) / (10 if self.precision else 1)
+            
+            if self.axis == 2:
+                context.area.header_text_set("Scale X: %.4f Y: %.4f" % (scale, scale))
+            elif self.axis == 1:
+                scale_xyz[0] = self.first_value[0]
+                scale_xyz[2] = self.first_value[2]
+                context.area.header_text_set("Scale: %.4f along local Y" % scale)
+            elif self.axis == 0:
+                scale_xyz[1] = self.first_value[1]
+                scale_xyz[2] = self.first_value[2]
+                context.area.header_text_set("Scale: %.4f along local X" % scale)
+            
+            obj_ref['resize'].scale = scale_xyz
+            self.tmp_value = scale_xyz
+            
+            return {'RUNNING_MODAL'}
+        elif event.type == 'X' and event.value == 'PRESS':
+            self.axis = 0 if self.axis != 0 else 2
+        elif event.type == 'Y' and event.value == 'PRESS':
+            self.axis = 1 if self.axis != 1 else 2
+        elif event.type in {'LEFT_SHIFT', 'RIGHT_SHIFT'}:
+             if event.value == 'PRESS':
+                 self.precision = True
+                 
+                 tmp = self.first_value
+                 self.first_value = self.tmp_value
+                 self.tmp_value = tmp
+                 
+                 tmp = self.mouseCo
+                 self.mouseCo = self.mouseCoNew
+                 self.mouseCoNew = tmp
+             elif event.value == 'RELEASE':
+                 self.precision = False
+                 
+                 tmp = self.first_value
+                 self.first_value = self.tmp_value
+                 self.tmp_value = tmp
+                 
+                 tmp = self.mouseCo
+                 self.mouseCo = self.mouseCoNew
+                 self.mouseCoNew = tmp
+        elif event.type == 'LEFTMOUSE':
+            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
+            context.area.header_text_set()
+            context.scene.objects.active = context.scene.objects.active
+            return {'FINISHED'}
+        elif event.type in {'RIGHTMOUSE', 'ESC'}:
+            obj_ref['resize'].scale = self.backup_value
+            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
+            context.area.header_text_set()
+            context.scene.objects.active = context.scene.objects.active
+            return {'CANCELLED'}
+        else:
+            #return {'PASS_THROUGH'}
+            return {'RUNNING_MODAL'}
+
+        return {'RUNNING_MODAL'}
+
+    def invoke(self, context, event):
+        if context.space_data.type == 'VIEW_3D':
+            self.mouseCo = Vector((event.mouse_region_x, event.mouse_region_y, 0))
+            obj_ref['resize'] = getLightController()
+            self.first_value = obj_ref['resize'].scale
+            self.backup_value = obj_ref['resize'].scale[:]
+            args = (self, context)
+            self._handle = bpy.types.SpaceView3D.draw_handler_add(draw_callback_px, args, 'WINDOW', 'POST_PIXEL')
+            context.window_manager.modal_handler_add(self)
+            context.area.header_text_set("Scale X: 1.000 Y: 1.000  [X/Y] Axis, [Shift] Precision mode")
+            return {'RUNNING_MODAL'}
+        else:
+            self.report({'WARNING'}, "Active space must be a View3d")
+            return {'CANCELLED'}
+        
+obj_ref['move'] = None
+class BLS_MoveLight(bpy.types.Operator):
+    """Move BLS Light Mesh"""
+    bl_idname = "bls.move_light"
+    bl_label = "Move BLS Light"
+    bl_options = {"REGISTER", "UNDO"}
+    
+    #mouse and ui
+    mouseCo = FloatVectorProperty()
+    mouseCoNew = FloatVectorProperty(default=(0,0,0))
+    tmp_mouseCo = FloatVectorProperty()
+    obLoc = FloatVectorProperty()
+    
+    #values
+    first_value = FloatVectorProperty()
+    tmp_value = FloatVectorProperty()
+    back_value = FloatVectorProperty()
+    
+    #operator dependants
+    axis = IntProperty(default=2) # [x,y,xy]
+    precision = BoolProperty()
+    
+    @classmethod
+    def poll(cls, context):
+        light = context.scene.objects.active
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.BLStudio.initialized and \
+               light and \
+               isFamily(light) and \
+               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+
+    def modal(self, context, event):
+        dist2d = lambda p1, p2: sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
+        
+        if event.type in {'MOUSEMOVE'}:
+            region = context.region  
+            rv3d = context.space_data.region_3d
+            
+            self.mouseCoNew = (event.mouse_region_x, event.mouse_region_y, 0)
+            #        
+            loc2d = loc3d2d(region, rv3d, self.obLoc)
+            dx = self.mouseCoNew[0] - self.mouseCo[0]
+            dy = self.mouseCoNew[1] - self.mouseCo[1]
+                        
+            first_loc = Vector(self.first_value)
+            last_loc = Vector((first_loc[0] + dx/(1000 if self.precision else 100), first_loc[1] + dy/(1000 if self.precision else 100), first_loc[2]))
+            
+            if self.axis == 2: #xy
+                context.area.header_text_set("Move Dx: %.4f Dy: %.4f" % (dx, dy))
+                last_loc[2] = self.backup_value[2]
+            elif self.axis == 1: #y
+                last_loc[0] = self.first_value[0]
+                last_loc[2] = self.backup_value[2]
+                context.area.header_text_set("Move: %.4f along local Y" % dy)
+            elif self.axis == 0: #x
+                last_loc[1] = self.first_value[1]
+                last_loc[2] = self.backup_value[2]
+                context.area.header_text_set("Move: %.4f along local X" % dx)
+            
+            last_loc[0] = (last_loc[0] + 2) % 4 - 2
+            obj_ref['move'].location = last_loc
+            self.tmp_value = last_loc
+            
+            return {'RUNNING_MODAL'}
+        elif event.type == 'X' and event.value == 'PRESS':
+            self.axis = 0 if self.axis != 0 else 2
+        elif event.type == 'Y' and event.value == 'PRESS':
+            self.axis = 1 if self.axis != 1 else 2
+        elif event.type in {'LEFT_SHIFT', 'RIGHT_SHIFT'}:
+             if event.value == 'PRESS':
+                 self.precision = True
+                 
+                 tmp = self.first_value
+                 self.first_value = self.tmp_value
+                 self.tmp_value = tmp
+                 
+                 tmp = self.mouseCo
+                 self.mouseCo = self.mouseCoNew
+                 self.mouseCoNew = tmp
+             elif event.value == 'RELEASE':
+                 self.precision = False
+                 
+                 tmp = self.first_value
+                 self.first_value = self.tmp_value
+                 self.tmp_value = tmp
+                 
+                 tmp = self.mouseCo
+                 self.mouseCo = self.mouseCoNew
+                 self.mouseCoNew = tmp
+        elif event.type == 'LEFTMOUSE':
+            context.area.header_text_set()
+            return {'FINISHED'}
+        elif event.type in {'RIGHTMOUSE', 'ESC'}:
+            obj_ref['move'].location = self.backup_value
+            context.area.header_text_set()
+            return {'CANCELLED'}
+        else:
+            #return {'PASS_THROUGH'}
+            return {'RUNNING_MODAL'}
+
+        return {'RUNNING_MODAL'}
+
+    def invoke(self, context, event):
+        if context.space_data.type == 'VIEW_3D':
+            self.mouseCo = Vector((event.mouse_region_x, event.mouse_region_y, 0))
+            obj_ref['move'] = getLightController()
+            self.first_value = obj_ref['move'].location
+            self.backup_value = obj_ref['move'].location[:]
+            context.window_manager.modal_handler_add(self)
+            context.area.header_text_set("Move Dx: 0.000 Dy: 0.000  [X/Y] Axis, [Shift] Precision mode")
+            
+            self.obLoc = getLightMesh().matrix_world.to_translation()
+            
+            return {'RUNNING_MODAL'}
+        else:
+            self.report({'WARNING'}, "Active space must be a View3d")
+            return {'CANCELLED'}
+        
+obj_ref['rotate'] = None
+class BLS_RotateLight(bpy.types.Operator):
+    """Rotate BLS Light Mesh"""
+    bl_idname = "bls.rotate_light"
+    bl_label = "Rotate BLS Light"
+    bl_options = {"REGISTER", "UNDO"}
+    
+    #mouse and ui
+    mouseCo = FloatVectorProperty()
+    mouseCoNew = FloatVectorProperty(default=(0,0,0))
+    tmp_mouseCo = FloatVectorProperty()
+    obLoc = FloatVectorProperty()
+    
+    #values
+    first_value = FloatProperty()
+    tmp_value = FloatProperty()
+    backup_value = FloatProperty()
+    
+    #operator dependants
+    precision = BoolProperty()
+    
+    @classmethod
+    def poll(cls, context):
+        light = context.scene.objects.active
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.BLStudio.initialized and \
+               light and \
+               isFamily(light) and \
+               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+
+    def modal(self, context, event):
+        dist2d = lambda p1, p2: sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2)
+        
+        if event.type in {'MOUSEMOVE'}:
+            region = context.region  
+            loc2d = [region.width/2, region.height/2]
+            self.obLoc = (loc2d[0], loc2d[1], 0)
+            #
+            self.mouseCoNew = Vector((event.mouse_region_x, event.mouse_region_y, 0))
+            angle0 = atan2(self.mouseCo[0] - loc2d[0], self.mouseCo[1] - loc2d[1])
+            angle1 = atan2(self.mouseCoNew[0] - loc2d[0], self.mouseCoNew[1] - loc2d[1])
+            angle_diff = (angle1 - angle0)
+            new_angle = self.first_value + angle_diff
+            
+            context.area.header_text_set("Rot: {:^0.3f}".format(degrees(angle_diff)))
+            
+            obj_ref['rotate'].rotation_euler[2] = new_angle
+            self.tmp_value = new_angle
+            
+            return {'RUNNING_MODAL'}
+        elif event.type == 'LEFTMOUSE':
+            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
+            context.area.header_text_set()
+            context.scene.objects.active = context.scene.objects.active
+            return {'FINISHED'}
+        elif event.type in {'RIGHTMOUSE', 'ESC'}:
+            obj_ref['rotate'].rotation_euler[2] = self.backup_value
+            bpy.types.SpaceView3D.draw_handler_remove(self._handle, 'WINDOW')
+            context.area.header_text_set()
+            context.scene.objects.active = context.scene.objects.active
+            return {'CANCELLED'}
+        else:
+            #return {'PASS_THROUGH'}
+            return {'RUNNING_MODAL'}
+
+        return {'RUNNING_MODAL'}
+
+    def invoke(self, context, event):
+        if context.space_data.type == 'VIEW_3D':
+            self.mouseCo = Vector((event.mouse_region_x, event.mouse_region_y, 0))
+            obj_ref['rotate'] = getLightController()
+            self.first_value = obj_ref['rotate'].rotation_euler[2]
+            self.backup_value = obj_ref['rotate'].rotation_euler[2]
+            args = (self, context)
+            self._handle = bpy.types.SpaceView3D.draw_handler_add(draw_callback_px, args, 'WINDOW', 'POST_PIXEL')
+            context.window_manager.modal_handler_add(self)
+            context.area.header_text_set("Rot: 0.000")
+            return {'RUNNING_MODAL'}
+        else:
+            self.report({'WARNING'}, "Active space must be a View3d")
+            return {'CANCELLED'}
\ No newline at end of file
diff --git a/src/light_operators.py b/src/light_operators.py
new file mode 100644
index 0000000..4041849
--- /dev/null
+++ b/src/light_operators.py
@@ -0,0 +1,380 @@
+import bpy
+from bpy.props import BoolProperty, PointerProperty, FloatProperty, CollectionProperty, IntProperty, StringProperty
+from . window_operations import splitV3DtoBLS
+from . light_profiles import ListItem, update_list_index
+from . common import *
+import os
+
+_ = os.sep
+
+class Blender_Light_Studio_Properties(bpy.types.PropertyGroup):
+    initialized = BoolProperty(default = False)
+      
+    def get_light_x(self):
+        return getLightMesh().location.x
+    
+    def set_light_x(self, context):
+        getLightMesh().location.x = context
+        
+    def get_light_hidden(self):
+        return getLightMesh().hide_render
+    
+    def set_light_hidden(self, context):
+        light = getLightMesh()
+        light.hide_render = context
+        light.hide = context
+        bpy.context.scene.frame_current = bpy.context.scene.frame_current # refresh hack
+        refreshMaterials()  
+    
+    light_radius = FloatProperty(name="Light Distance", default=30.0, min=0.5, set=set_light_x, step=5, get=get_light_x)
+    light_muted = BoolProperty(name="Mute Light", default=False, set=set_light_hidden, get=get_light_hidden)
+    
+    ''' Profile List '''
+    profile_list = CollectionProperty(type = ListItem)
+    list_index = IntProperty(name = "Index for profile_list", default = 0, update=update_list_index)
+    last_empty = StringProperty(name="Name of last Empty holding profile", default="")
+    
+
+class CreateBlenderLightStudio(bpy.types.Operator):
+    bl_idname = "scene.create_blender_light_studio"
+    bl_label = "Create Light Studio"
+    bl_description = "Append Blender Light Studio to current scene"
+    bl_options = {"REGISTER"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and not context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        script_file = os.path.realpath(__file__)
+        dir = os.path.dirname(script_file)
+        
+        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Object'+_,
+        directory=os.path.join(dir,"BLS.blend"+_+"Object"+_),
+        filename="BLENDER_LIGHT_STUDIO",
+        active_layer=False)
+
+        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Object'+_,
+        directory=os.path.join(dir,"BLS.blend"+_+"Object"+_),
+        filename="BLS_PANEL",
+        active_layer=False)
+        
+        cpanel = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLS_PANEL')][0]
+        cpanel.parent = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
+
+        bpy.ops.bls_list.new_profile()
+        
+        context.scene.BLStudio.initialized = True
+        
+        return {"FINISHED"}
+  
+class DeleteBlenderLightStudio(bpy.types.Operator):
+    bl_idname = "scene.delete_blender_light_studio"
+    bl_label = "Delete Studio"
+    bl_description = "Delete Blender Light Studio from current scene"
+    bl_options = {"REGISTER"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        scene = context.scene
+        scene.BLStudio.initialized = False
+        
+        ''' for each profile from this scene: delete objects then remove from list '''
+        while len(context.scene.BLStudio.profile_list):
+            bpy.ops.bls_list.delete_profile()
+            
+        obsToRemove = [ob for ob in scene.objects if isFamily(ob)]
+        for ob in obsToRemove:
+            scene.objects.unlink(ob)
+            for gr in ob.users_group:
+                gr.objects.unlink(ob)
+            ob.user_clear()
+            ob.use_fake_user = False
+            bpy.data.objects.remove(ob)
+            
+        
+        return {"FINISHED"}
+     
+    def invoke(self, context, event):
+        wm = context.window_manager
+        return wm.invoke_props_dialog(self)
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        col.label(text="Deleting Studio is irreversible!")
+        col.label(text="Your lighting setup will be lost.")
+
+class AddBSLight(bpy.types.Operator):
+    bl_idname = "scene.add_blender_studio_light"
+    bl_label = "Add Studio Light"
+    bl_description = "Add Light to Studio"
+    bl_options = {"REGISTER", "UNDO"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        script_file = os.path.realpath(__file__)
+        dir = os.path.dirname(script_file)
+        
+        scene = context.scene
+        bls = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
+    
+        # before
+        A = set(bpy.data.groups[:])
+        A_actions = set(bpy.data.actions[:]) # remove bugged actions (Blender 2.78 bug)
+        
+        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Group'+_,
+        directory=os.path.join(dir,"BLS.blend"+_+"Group"+_),
+        filename="BLS_Light",
+        active_layer=False)
+        
+        if bpy.data.actions.find("BLS_ROT_X") == -1:
+            bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Action'+_,
+            directory=os.path.join(dir,"BLS.blend"+_+"Action"+_),
+            filename="BLS_ROT_X",
+            active_layer=False)
+
+        if bpy.data.actions.find("BLS_ROT_Z") == -1:
+            bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Action'+_,
+            directory=os.path.join(dir,"BLS.blend"+_+"Action"+_),
+            filename="BLS_ROT_Z",
+            active_layer=False)
+            
+
+        #################
+        # maybe later
+        '''
+        filepath = os.path.join(dir,"BLS.blend") #os.path.join(os.sep, "BLS.blend")
+        # load a single scene we know the name of.
+        with bpy.data.libraries.load(filepath) as (data_from, data_to):
+            data_to.groups = ["BLS_Light"]
+            
+        for group in data_to.groups:
+            if group is not None:
+                print(group.name)
+                bpy.ops.object.group_link(group=group.name)
+        '''
+        #################
+        
+        # after operation
+        B = set(bpy.data.groups[:])
+
+        # whats the difference
+        new_objects = (A ^ B).pop().objects
+        
+        for ob in new_objects:
+            print(ob)
+            ob.use_fake_user = True
+        
+        lightGrp = [l for l in new_objects if l.name.startswith('BLS_LIGHT_GRP')][0]
+        lightGrp.parent = [ob for ob in bpy.context.scene.objects if ob and ob.name.startswith('BLS_PROFILE') and isFamily(ob)][0]
+        
+        bpy.ops.object.select_all(action='DESELECT')
+        light = [p for p in new_objects if p.name.startswith('BLS_LIGHT_MESH')][0]
+        light.select = True
+        panel = [p for p in new_objects if p.name.startswith('BLS_CONTROLLER')][0]
+        panel.select = True
+        context.scene.objects.active = panel
+        
+        ##### Blender 2.78 workaround. Constraints cannot be appended
+        c = light.constraints.new('COPY_ROTATION')
+        c.target = panel
+        c.use_x = False
+        c.use_y = False
+        c.owner_space = 'LOCAL'
+        c.use_z = True
+        c.invert_z = True
+        
+        c = light.constraints.new('TRANSFORM')
+        c.target = panel
+        c.use_motion_extrapolate = True
+        c.map_from = 'SCALE'
+        c.from_min_x_scale = 0.1
+        c.from_max_x_scale = 20
+        c.from_min_y_scale = 0.1
+        c.from_max_y_scale = 20
+        c.from_min_z_scale = 0.1
+        c.from_max_z_scale = 20
+        
+        c.map_to_x_from = 'Z'
+        c.map_to_y_from = 'X'
+        c.map_to_z_from = 'Y'
+        
+        c.map_to = 'SCALE'
+        c.to_min_x_scale = 0.1
+        c.to_max_x_scale = 20
+        c.to_min_y_scale = 0.1
+        c.to_max_y_scale = 20
+        c.to_min_z_scale = 0.1
+        c.to_max_z_scale = 20
+        
+        ##
+        c = panel.constraints.new('LIMIT_LOCATION')
+        c.use_min_x = True
+        c.min_x = -2
+        c.use_max_x = True
+        c.max_x = 2
+        
+        c.use_min_y = True
+        c.min_y = -1
+        c.use_max_y = True
+        c.max_y = 1
+        
+        c = panel.constraints.new('LIMIT_SCALE')
+        c.use_min_x = True
+        c.min_x = 0.1
+        c.use_min_y = True
+        c.min_y = 0.1
+        c.use_min_z = True
+        c.min_z = 0.1
+        
+        ##
+        armature1 = [a for a in new_objects if a.name.startswith("BLS_Armature")][0]
+        armature2 = [a for a in new_objects if a.name.startswith("BLS_Armature2")][0]
+        
+        c = armature1.constraints.new('ACTION')
+        c.target = panel
+        c.action = bpy.data.actions["BLS_ROT_Z"]
+        c.min = -2
+        c.max = 2
+        c.frame_start = 1
+        c.frame_end = 500
+        
+        c = armature2.constraints.new('ACTION')
+        c.target = panel
+        c.action = bpy.data.actions["BLS_ROT_X"]
+        c.transform_channel = 'LOCATION_Y'
+        c.min = -1
+        c.max = 1
+        c.frame_start = 1
+        c.frame_end = 500
+        #####
+
+        bpy.context.scene.frame_current = bpy.context.scene.frame_current # refresh hack
+        refreshMaterials()
+                
+        return {"FINISHED"}
+    
+class DeleteBSLight(bpy.types.Operator):
+    bl_idname = "scene.delete_blender_studio_light"
+    bl_label = "Delete BLS Light"
+    bl_description = "Delete selected Light from Studio"
+    bl_options = {"REGISTER", "UNDO"}
+    
+    @classmethod
+    def poll(cls, context):
+        light = context.scene.objects.active
+        return context.area.type == 'VIEW_3D' and \
+               context.mode == 'OBJECT' and \
+               context.scene.BLStudio.initialized and \
+               light and \
+               light.name.startswith('BLS_') and \
+               not (light.name.startswith('BLS_PANEL') or light.name.startswith('BLS_PROFILE') or light.name.startswith('BLS_LIGHT_GRP'))
+
+    def execute(self, context):
+        scene = context.scene
+        oldlaysArea = context.area.spaces[0].layers[:]
+        oldlaysScene = context.scene.layers[:]
+        context.area.spaces[0].layers = [True]*20
+        context.scene.layers = [True]*20
+        
+        light = bpy.context.scene.objects.active
+        
+        lightGrp = findLightGrp(light)
+        ending = lightGrp.name.split('.')[1]
+        
+        #obsToRemove = [ob for ob in scene.objects if not ob.name.startswith('BLS_PROFILE.') and ob.name.endswith(ending) and isFamily(ob)]
+        #print(obsToRemove)
+        for ob in family(lightGrp):
+            scene.objects.unlink(ob)
+            for gr in ob.users_group:
+                gr.objects.unlink(ob)
+            ob.user_clear()
+            ob.use_fake_user = False
+            bpy.data.objects.remove(ob)
+        
+        context.area.spaces[0].layers = oldlaysArea
+        context.scene.layers = oldlaysScene
+                
+        return {"FINISHED"}
+    
+    def invoke(self, context, event):
+        wm = context.window_manager
+        return wm.invoke_props_dialog(self)
+    
+    def draw(self, context):
+        layout = self.layout
+        col = layout.column(align=True)
+        col.label(text="OK?")
+    
+class PrepareBSLV3D(bpy.types.Operator):
+    bl_idname = "scene.prepare_blender_studio_light"
+    bl_label = "Prepare Layout"
+    bl_description = "Split current Viewport for easier Studio usage."
+    bl_options = {"REGISTER"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        splitV3DtoBLS(context)
+        context.scene.render.engine="CYCLES"
+        return {"FINISHED"}
+    
+class BSL_MuteOtherLights(bpy.types.Operator):
+    bl_idname = "object.mute_other_lights"
+    bl_label = "Show Only This Light"
+    bl_description = "Show only this light."
+    bl_options = {"INTERNAL", "UNDO"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized \
+            and context.scene.objects.active and (context.scene.objects.active.name.startswith('BLS_CONTROLLER') or context.scene.objects.active.name.startswith('BLS_LIGHT_MESH'))
+    
+    def execute(self, context):
+        obs = context.scene.objects
+        lightGrp = obs.active
+        light_no = lightGrp.name.split('.')[1]
+    
+        for light in (ob for ob in obs if ob.name.startswith('BLS_LIGHT_MESH') and isFamily(ob)):
+            if light.name[-3:] == light_no:
+                light.hide_render = False
+                light.hide = False
+            else:
+                light.hide_render = True
+                light.hide = True
+                
+        context.scene.frame_current = context.scene.frame_current # refresh hack
+        refreshMaterials()
+    
+        return {"FINISHED"}
+    
+class BSL_ShowAllLights(bpy.types.Operator):
+    bl_idname = "object.show_all_lights"
+    bl_label = "Show All Lights"
+    bl_description = "Show all lights."
+    bl_options = {"INTERNAL", "UNDO"}
+    
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT' and context.scene.BLStudio.initialized
+    
+    def execute(self, context):
+        obs = context.scene.objects
+        for light in (ob for ob in obs if ob.name.startswith('BLS_LIGHT_MESH') and isFamily(ob)):
+            light.hide_render = False
+            light.hide = False
+                
+        context.scene.frame_current = context.scene.frame_current # refresh hack
+        refreshMaterials()
+    
+        return {"FINISHED"}
+        
\ No newline at end of file
diff --git a/src/light_preview_list.py b/src/light_preview_list.py
new file mode 100644
index 0000000..89e26f1
--- /dev/null
+++ b/src/light_preview_list.py
@@ -0,0 +1,102 @@
+import os
+import bpy
+from . common import getLightMesh, isFamily
+
+_ = os.sep
+    
+def enum_previews_from_directory_items(self, context):
+    """EnumProperty callback"""
+    enum_items = []
+
+    if context is None:
+        return enum_items
+
+    wm = context.window_manager
+    
+    script_file = os.path.realpath(__file__)
+    dir = os.path.dirname(script_file)
+    directory=os.path.join(dir,"textures_real_lights"+_)
+
+    # Get the preview collection (defined in register func).
+    pcoll = preview_collections["main"]
+
+    if not pcoll.updated:
+        return pcoll.tex_previews
+
+    print("Scanning directory: %s" % directory)
+
+    if directory and os.path.exists(directory):
+        # Scan the directory for png files
+        image_paths = []
+        for fn in os.listdir(directory):
+            if os.path.splitext(fn)[1] in (".tif", ".exr", ".hdr"):
+                image_paths.append(fn)
+
+        for i, name in enumerate(image_paths):
+            # generates a thumbnail preview for a file.
+            filepath = os.path.join(directory, name)
+            thumb = pcoll.load(filepath, filepath, 'IMAGE')
+            basename = os.path.splitext(name)[0]
+            enum_items.append((name, basename, name, thumb.icon_id, i))
+
+    pcoll.tex_previews = enum_items
+    pcoll.updated = False
+    return pcoll.tex_previews
+
+
+# We can store multiple preview collections here,
+# however in this example we only store "main"
+preview_collections = {}
+
+def preview_enum_get(wm):
+    nodes = getLightMesh().active_material.node_tree.nodes
+    if not "Light Texture" in nodes:
+        return -1
+    
+    tex = nodes["Light Texture"].image.filepath
+    tex = os.path.split(tex)[1]
+    names = (p[0] for p in preview_collections["main"].tex_previews)
+    
+    for i, name in enumerate(names):
+        if name == tex:
+            return i
+    return -1
+    
+def preview_enum_set(wm, context):
+    print("Set preview = %s" % context)
+    name = preview_collections["main"].tex_previews[context][0]
+    
+    light = getLightMesh()
+    script_file = os.path.realpath(__file__)
+    dir = os.path.dirname(script_file)
+    directory=os.path.join(dir,"textures_real_lights"+_)
+    light.active_material.node_tree.nodes["Light Texture"].image.filepath = directory + name
+    
+    return None
+
+def register():
+    from bpy.types import WindowManager
+    from bpy.props import EnumProperty
+
+    WindowManager.bls_tex_previews = EnumProperty(
+            items=enum_previews_from_directory_items,
+            get=preview_enum_get,
+            set=preview_enum_set,
+            )
+
+    import bpy.utils.previews
+    pcoll = bpy.utils.previews.new()
+    pcoll.bls_tex_previews = ()
+    pcoll.updated = True
+
+    preview_collections["main"] = pcoll
+
+
+def unregister():
+    from bpy.types import WindowManager
+
+    del WindowManager.bls_tex_previews
+
+    for pcoll in preview_collections.values():
+        bpy.utils.previews.remove(pcoll)
+    preview_collections.clear()
diff --git a/src/light_profiles.py b/src/light_profiles.py
new file mode 100644
index 0000000..54a9fd1
--- /dev/null
+++ b/src/light_profiles.py
@@ -0,0 +1,342 @@
+import bpy
+from bpy.props import StringProperty, PointerProperty, FloatProperty
+import os
+from . common import isFamily, family, findLightGrp
+from itertools import chain
+
+_ = os.sep
+
+class ListItem(bpy.types.PropertyGroup):
+    """ Group of properties representing an item in the list """
+    def update_name(self, context):
+        print("{} : {}".format(repr(self.name), repr(context)))
+                
+    name = StringProperty(
+            name="Profile Name",
+            default="Untitled")
+
+    empty_name = StringProperty(
+            name="Name of Empty holding profile",
+            description="",
+            default="")
+            
+class BLS_UL_List(bpy.types.UIList):
+    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
+        custom_icon = 'OUTLINER_OB_LAMP' if index == context.scene.BLStudio.list_index else 'LAMP'
+
+        # Make sure your code supports all 3 layout types
+        if self.layout_type in {'DEFAULT', 'COMPACT'}:
+            layout.prop(item, 'name', text='', icon = custom_icon, emboss=False, translate=False)
+
+        elif self.layout_type in {'GRID'}:
+            layout.alignment = 'CENTER'
+            layout.label("", icon = custom_icon)
+            
+            
+class LIST_OT_NewItem(bpy.types.Operator):
+    """ Add a new profile to the list """
+
+    bl_idname = "bls_list.new_profile"
+    bl_label = "Add a new Profile"
+    bl_options = {"INTERNAL"}
+
+    def execute(self, context):
+        props = context.scene.BLStudio
+        item = props.profile_list.add()
+        
+        idx = 0
+        for id in (i.name.split('Profile ')[1] for i in props.profile_list if i.name.startswith('Profile ')):
+            try:
+                id = int(id)
+            except ValueError:
+                continue
+            
+            if id > idx: idx = id
+            
+        item.name = 'Profile '+str(idx+1)
+        
+        ''' Add Hierarchy stuff '''
+        # before
+        A = set(bpy.data.objects[:])
+        
+        script_file = os.path.realpath(__file__)
+        dir = os.path.dirname(script_file)
+        bpy.ops.wm.append(filepath=_+'BLS.blend'+_+'Object'+_,
+        directory=os.path.join(dir,"BLS.blend"+_+"Object"+_),
+        filename="BLS_PROFILE.000",
+        active_layer=False)
+        
+        # after operation
+        B = set(bpy.data.objects[:])
+
+        # whats the difference
+        profile = (A ^ B).pop()
+        
+        profile.parent = [ob for ob in bpy.context.scene.objects if ob.name.startswith('BLENDER_LIGHT_STUDIO')][0]
+        profile.use_fake_user = True
+        
+        item.empty_name = profile.name
+        
+        #if len([prof for prof in profile.parent.children if prof.name.startswith('BLS_PROFILE.')]) > 1:
+        if len([prof for prof in context.scene.objects if prof.name.startswith('BLS_PROFILE.') and isFamily(prof)]) > 1:
+            #profile already exists
+            context.scene.objects.unlink(profile)
+        else:
+            #init last_empty for first profile
+            props.last_empty = profile.name
+            
+
+        return{'FINISHED'}
+
+class LIST_OT_DeleteItem(bpy.types.Operator):
+    """ Delete the selected profile from the list """
+ 
+    bl_idname = "bls_list.delete_profile"
+    bl_label = "Deletes an profile"
+    bl_options = {"INTERNAL"}
+ 
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        list = props.profile_list
+        index = props.list_index
+ 
+        list.remove(index)
+        
+        ''' Delete/Switch Hierarchy stuff '''
+        #delete objects from current profile           
+        obsToRemove = family(context.scene.objects[props.last_empty])
+        for ob in obsToRemove:
+            context.scene.objects.unlink(ob)
+            for gr in ob.users_group:
+                gr.objects.unlink(ob)
+            ob.user_clear()
+            ob.use_fake_user = False
+            bpy.data.objects.remove(ob)
+        
+        # update index
+        if index > 0:
+            index = index - 1
+        props.list_index = index
+ 
+        return{'FINISHED'}
+    
+    
+class LIST_OT_DeleteItem(bpy.types.Operator):
+    """ Delete the selected profile from the list """
+ 
+    bl_idname = "bls_list.delete_profile"
+    bl_label = "Deletes an profile"
+    bl_options = {"INTERNAL"}
+ 
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list """
+        return len(context.scene.BLStudio.profile_list)
+ 
+    def execute(self, context):
+        props = context.scene.BLStudio
+        list = props.profile_list
+        index = props.list_index
+ 
+        list.remove(index)
+        
+        ''' Delete/Switch Hierarchy stuff '''
+        #delete objects from current profile           
+        obsToRemove = family(context.scene.objects[props.last_empty])
+        for ob in obsToRemove:
+            context.scene.objects.unlink(ob)
+            for gr in ob.users_group:
+                gr.objects.unlink(ob)
+            ob.user_clear()
+            ob.use_fake_user = False
+            bpy.data.objects.remove(ob)
+        
+        # update index
+        if index > 0:
+            index = index - 1
+        props.list_index = index
+ 
+        return{'FINISHED'}
+    
+
+class LIST_OT_CopyItem(bpy.types.Operator):
+    """ Copy an item in the list """
+
+    bl_idname = "bls_list.copy_profile"
+    bl_label = "Copy an profile in the list"
+    bl_options = {"INTERNAL"}
+
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list. """
+        return len(context.scene.BLStudio.profile_list)
+
+    def execute(self, context):
+        props = context.scene.BLStudio
+        list = props.profile_list
+        index = props.list_index
+        
+        scene = context.scene
+        
+        # all objects on all layers visible
+        oldlaysArea = context.area.spaces[0].layers[:]
+        oldlaysScene = context.scene.layers[:]
+        context.area.spaces[0].layers = [True]*20
+        context.scene.layers = [True]*20
+        
+        obsToCopy = family(context.scene.objects[props.last_empty])
+        
+        for ob in context.selected_objects: ob.select = False
+        for ob in obsToCopy:
+            if ob.name.startswith('BLS_PROFILE.'): continue
+            ob.hide_select = False
+            ob.hide = False
+            ob.select = True
+            
+            
+        # before
+        A = set(scene.objects[:])
+        
+        bpy.ops.object.duplicate()
+        
+        # after operation
+        B = set(scene.objects[:])
+
+        # whats the difference
+        new_objects = (A ^ B)
+        
+        # make icon material single user and update selection drivers
+        bpy.ops.group.objects_remove_all()
+        bpy.ops.group.create(name='BLS_Light')
+        for ob in new_objects:
+            if ob.name.startswith('BLS_CONTROLLER.'):
+                for id, mat in enumerate(ob.data.materials):
+                    if mat.name.startswith('BLS_icon_ctrl'):
+                        mat = mat.copy()
+                        ob.data.materials[id] = mat
+                        
+                        for d in mat.animation_data.drivers:
+                            d.driver.variables[0].targets[0].id = scene.objects['BLS_LIGHT_MESH.'+ob.name.split('.')[1]]
+                        
+                        for d in mat.node_tree.animation_data.drivers:
+                            for v in d.driver.variables:
+                                v.targets[0].id = scene.objects['BLS_LIGHT_MESH.'+ob.name.split('.')[1]]
+                            
+        # revert visibility
+        for ob in chain(obsToCopy, new_objects):
+            ob.hide = True
+            ob.hide_select = True
+            
+            if ob.name.startswith('BLS_LIGHT_MESH.') or \
+               ob.name.startswith('BLS_CONTROLLER.'):
+                ob.hide = False
+                ob.hide_select = False
+                
+        profileName = props.profile_list[props.list_index].name
+        
+        bpy.ops.bls_list.new_profile()
+        lastItemId = len(props.profile_list)-1
+        
+        # parent objects to new profile
+        for ob in new_objects:
+            scene.objects.unlink(ob)
+            if ob.name.startswith('BLS_LIGHT_GRP.'):
+                ob.parent = bpy.data.objects[props.profile_list[lastItemId].empty_name]
+            
+        props.profile_list[len(props.profile_list)-1].name = profileName + ' Copy'
+        
+        
+        # place copied profile next to source profile
+        while lastItemId > props.list_index+1:
+            list.move(lastItemId-1, lastItemId)
+            lastItemId -= 1
+        
+        context.area.spaces[0].layers = oldlaysArea
+        context.scene.layers = oldlaysScene
+        
+        return{'FINISHED'}
+    
+    
+ 
+class LIST_OT_MoveItem(bpy.types.Operator):
+    """ Move an item in the list """
+
+    bl_idname = "bls_list.move_profile"
+    bl_label = "Move an profile in the list"
+    bl_options = {"INTERNAL"}
+
+    direction = bpy.props.EnumProperty(
+                items=(
+                    ('UP', 'Up', ""),
+                    ('DOWN', 'Down', ""),))
+
+    @classmethod
+    def poll(self, context):
+        """ Enable if there's something in the list. """
+        return len(context.scene.BLStudio.profile_list)
+
+
+    def move_index(self, context):
+        """ Move index of an item render queue while clamping it. """
+        props = context.scene.BLStudio
+        index = props.list_index
+        list_length = len(props.profile_list) - 1 # (index starts at 0)
+        new_index = 0
+
+        if self.direction == 'UP':
+            new_index = index - 1
+        elif self.direction == 'DOWN':
+            new_index = index + 1
+
+        new_index = max(0, min(new_index, list_length))
+        props.list_index = new_index
+
+
+    def execute(self, context):
+        props = context.scene.BLStudio
+        list = props.profile_list
+        index = props.list_index
+
+        if self.direction == 'DOWN':
+            neighbor = index + 1
+            list.move(index,neighbor)
+        elif self.direction == 'UP':
+            neighbor = index - 1
+            list.move(neighbor, index)
+        else:
+            return{'CANCELLED'}
+        self.move_index(context)
+
+        return{'FINISHED'}
+
+
+def update_list_index(self, context):
+    props = context.scene.BLStudio
+    
+    if len(props.profile_list) == 0: return
+        
+    selected_profile = props.profile_list[self.list_index]
+    
+    if selected_profile.empty_name == props.last_empty: return
+
+    print('Index update {}'.format(self.list_index))
+        
+    #unlink current profile
+    if context.scene.objects.find(props.last_empty) > -1: # in case of update after deletion
+        for ob in family(context.scene.objects[props.last_empty]):
+            ob['last_layers'] = ob.layers[:]
+            context.scene.objects.unlink(ob)
+        
+    #link selected profile
+    for ob in family(bpy.data.objects[selected_profile.empty_name]):
+        context.scene.objects.link(ob)
+        ob.layers = [bool(l) for l in ob['last_layers']]
+        
+    props.last_empty = selected_profile.empty_name
+    
+        
\ No newline at end of file
diff --git a/src/selectOperator.py b/src/selectOperator.py
new file mode 100644
index 0000000..803272d
--- /dev/null
+++ b/src/selectOperator.py
@@ -0,0 +1,119 @@
+import bpy
+from bpy.props import BoolProperty, IntVectorProperty
+from . common import isFamily, findLightGrp, family, refreshMaterials
+
+class SelectionOperator(bpy.types.Operator):
+    """ Custom selection """
+    bl_idname = "view3d.select_custom" 
+    bl_label = "Custom selection"
+
+    extend = BoolProperty(default = False)
+    deselect = BoolProperty(default = False)
+    toggle = BoolProperty(default = False)
+    center = BoolProperty(default = False)
+    enumerate = BoolProperty(default = False)
+    object = BoolProperty(default = False)
+    location = IntVectorProperty(default = (0,0),subtype ='XYZ', size = 2)
+
+    @classmethod
+    def poll(cls, context):
+        return context.area.type == 'VIEW_3D' and context.mode == 'OBJECT'
+    
+    def execute(self, context):
+        deactivate=''
+        if context.active_object:
+            obname = context.active_object.name
+            deactivate = obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.')
+            
+        bpy.ops.view3d.select(extend=self.extend, deselect=self.deselect, toggle=self.toggle, center=self.center, enumerate=self.enumerate, object=self.object, location=(self.location[0] , self.location[1] ))
+        if context.active_object:
+            obname = context.active_object.name
+            if obname.startswith('BLS_CONTROLLER.'):
+                lno = obname.split('.')[1]
+                lno = context.scene.objects.find('BLS_LIGHT_MESH.'+lno)
+                if lno is not -1:
+                    context.scene.objects[lno].select = True
+                
+            if deactivate or obname.startswith('BLS_CONTROLLER.') or obname.startswith('BLS_LIGHT_MESH.'):
+                refreshMaterials()
+                    
+            context.scene.frame_current = context.scene.frame_current
+            refreshMaterials()
+            
+        return {'FINISHED'}
+
+    def invoke(self, context, event):
+        self.location[0] = event.mouse_region_x
+        self.location[1] = event.mouse_region_y
+        return self.execute(context)
+
+addon_keymaps = []
+def add_shortkeys():
+    def prepKmi(kmi):
+        kmi.properties.toggle = False
+        kmi.properties.center = False
+        kmi.properties.object = False
+        kmi.properties.enumerate = False
+        kmi.properties.extend = False
+        kmi.properties.deselect = False
+        
+    wm = bpy.context.window_manager
+    addon_km = wm.keyconfigs.addon.keymaps.new(name='Object Mode', space_type='EMPTY')
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    prepKmi(addon_kmi)
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    addon_kmi.shift = True
+    prepKmi(addon_kmi)
+    addon_kmi.properties.toggle = True
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    addon_kmi.ctrl = True
+    prepKmi(addon_kmi)
+    addon_kmi.properties.center = True
+    addon_kmi.properties.object = True
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    addon_kmi.alt = True
+    addon_kmi.properties.enumerate = True
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    addon_kmi.shift = True
+    addon_kmi.ctrl = True
+    prepKmi(addon_kmi)
+    addon_kmi.properties.center = True
+    addon_kmi.properties.extend = True
+    addon_kmi.properties.toggle = True
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    addon_kmi.ctrl = True
+    addon_kmi.alt = True
+    prepKmi(addon_kmi)
+    addon_kmi.properties.center = True
+    addon_kmi.properties.enumerate = True
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    addon_kmi.shift = True
+    addon_kmi.alt = True
+    prepKmi(addon_kmi)
+    addon_kmi.properties.enumerate = True
+    addon_kmi.properties.toggle = True
+    
+    addon_kmi = addon_km.keymap_items.new(SelectionOperator.bl_idname, 'SELECTMOUSE', 'PRESS')
+    addon_kmi.shift = True
+    addon_kmi.ctrl = True
+    addon_kmi.alt = True
+    prepKmi(addon_kmi)
+    addon_kmi.properties.center = True
+    addon_kmi.properties.enumerate = True
+    addon_kmi.properties.toggle = True
+    
+    addon_keymaps.append(addon_km)
+    
+def remove_shortkeys():
+    wm = bpy.context.window_manager
+    for km in addon_keymaps:
+        wm.keyconfigs.addon.keymaps.remove(km)
+        
+    addon_keymaps.clear()
\ No newline at end of file
diff --git a/src/texs/ramp_A.tif b/src/texs/ramp_A.tif
new file mode 100644
index 0000000..d3d163a
Binary files /dev/null and b/src/texs/ramp_A.tif differ
diff --git a/src/texs/ramp_B.tif b/src/texs/ramp_B.tif
new file mode 100644
index 0000000..337deeb
Binary files /dev/null and b/src/texs/ramp_B.tif differ
diff --git a/src/texs/ramp_C.tif b/src/texs/ramp_C.tif
new file mode 100644
index 0000000..9bca620
Binary files /dev/null and b/src/texs/ramp_C.tif differ
diff --git a/src/texs/ramp_CUT.tif b/src/texs/ramp_CUT.tif
new file mode 100644
index 0000000..e2ade47
Binary files /dev/null and b/src/texs/ramp_CUT.tif differ
diff --git a/src/textures_real_lights/Camera Flash 5600K.exr b/src/textures_real_lights/Camera Flash 5600K.exr
new file mode 100644
index 0000000..9ecf821
Binary files /dev/null and b/src/textures_real_lights/Camera Flash 5600K.exr differ
diff --git a/src/textures_real_lights/Fluorescent Tube A.hdr b/src/textures_real_lights/Fluorescent Tube A.hdr
new file mode 100644
index 0000000..5407508
Binary files /dev/null and b/src/textures_real_lights/Fluorescent Tube A.hdr differ
diff --git a/src/textures_real_lights/Fluorescent Tube B.exr b/src/textures_real_lights/Fluorescent Tube B.exr
new file mode 100644
index 0000000..9953687
Binary files /dev/null and b/src/textures_real_lights/Fluorescent Tube B.exr differ
diff --git a/src/textures_real_lights/Soft Box A.exr b/src/textures_real_lights/Soft Box A.exr
new file mode 100644
index 0000000..6352164
Binary files /dev/null and b/src/textures_real_lights/Soft Box A.exr differ
diff --git a/src/textures_real_lights/Synthetic Area A.exr b/src/textures_real_lights/Synthetic Area A.exr
new file mode 100644
index 0000000..5e448bf
Binary files /dev/null and b/src/textures_real_lights/Synthetic Area A.exr differ
diff --git a/src/textures_real_lights/Synthetic Area B.exr b/src/textures_real_lights/Synthetic Area B.exr
new file mode 100644
index 0000000..3dc61b5
Binary files /dev/null and b/src/textures_real_lights/Synthetic Area B.exr differ
diff --git a/src/textures_real_lights/Synthetic Area C.exr b/src/textures_real_lights/Synthetic Area C.exr
new file mode 100644
index 0000000..46a188c
Binary files /dev/null and b/src/textures_real_lights/Synthetic Area C.exr differ
diff --git a/src/textures_real_lights/Synthetic Area D.exr b/src/textures_real_lights/Synthetic Area D.exr
new file mode 100644
index 0000000..7f2ce35
Binary files /dev/null and b/src/textures_real_lights/Synthetic Area D.exr differ
diff --git a/src/textures_real_lights/Synthetic Disc A.exr b/src/textures_real_lights/Synthetic Disc A.exr
new file mode 100644
index 0000000..b0f8bc5
Binary files /dev/null and b/src/textures_real_lights/Synthetic Disc A.exr differ
diff --git a/src/textures_real_lights/Synthetic Octagon A.exr b/src/textures_real_lights/Synthetic Octagon A.exr
new file mode 100644
index 0000000..a77bffe
Binary files /dev/null and b/src/textures_real_lights/Synthetic Octagon A.exr differ
diff --git a/src/textures_real_lights/Synthetic Ring A.exr b/src/textures_real_lights/Synthetic Ring A.exr
new file mode 100644
index 0000000..ea03d03
Binary files /dev/null and b/src/textures_real_lights/Synthetic Ring A.exr differ
diff --git a/src/textures_real_lights/Synthetic Ring B.exr b/src/textures_real_lights/Synthetic Ring B.exr
new file mode 100644
index 0000000..6c38cfb
Binary files /dev/null and b/src/textures_real_lights/Synthetic Ring B.exr differ
diff --git a/src/textures_real_lights/Television A.exr b/src/textures_real_lights/Television A.exr
new file mode 100644
index 0000000..a12cc96
Binary files /dev/null and b/src/textures_real_lights/Television A.exr differ
diff --git a/src/textures_real_lights/Umbrella A.exr b/src/textures_real_lights/Umbrella A.exr
new file mode 100644
index 0000000..9d5e73b
Binary files /dev/null and b/src/textures_real_lights/Umbrella A.exr differ
diff --git a/src/textures_real_lights/Window A.exr b/src/textures_real_lights/Window A.exr
new file mode 100644
index 0000000..3c53a77
Binary files /dev/null and b/src/textures_real_lights/Window A.exr differ
diff --git a/src/window_operations.py b/src/window_operations.py
new file mode 100644
index 0000000..73dff7e
--- /dev/null
+++ b/src/window_operations.py
@@ -0,0 +1,90 @@
+import bpy
+
+# original source https://github.com/dustractor/ui_teardown_recreate
+
+def get_mergables(areas):
+    xs,ys = dict(),dict()
+    for a in areas:
+        xs[a.x] = a
+        ys[a.y] = a
+    for area in reversed(areas):
+        tx = area.x + area.width + 1
+        ty = area.y + area.height + 1
+        if tx in xs and xs[tx].y == area.y and xs[tx].height == area.height:
+            return area,xs[tx]
+        elif ty in ys and ys[ty].x == area.x and ys[ty].width == area.width:
+            return area,ys[ty]
+    return None,None
+
+def teardown(context):
+    while len(context.screen.areas) > 1:
+        a,b = get_mergables(context.screen.areas)
+        if a and b:
+            bpy.ops.screen.area_join(min_x=a.x,min_y=a.y,max_x=b.x,max_y=b.y)
+            area = context.screen.areas[0]
+            region = area.regions[0]
+            blend_data = context.blend_data
+            bpy.ops.screen.screen_full_area(dict(screen=context.screen,window=context.window,region=region,area=area,blend_data=blend_data))
+            bpy.ops.screen.back_to_previous(dict(screen=context.screen,window=context.window,region=region,area=area,blend_data=blend_data))
+
+def area_from_ptr(ptr):
+    for screen in bpy.data.screens:
+        for area in screen.areas:
+            if area.as_pointer() == ptr:
+                return area
+
+def split_area(window,screen,region,area,xtype,direction="VERTICAL",factor=0.5,mouse_x=-100,mouse_y=-100):
+    beforeptrs = set(list((a.as_pointer() for a in screen.areas)))
+    bpy.ops.screen.area_split(dict(region=region,area=area,screen=screen,window=window),direction=direction,factor=factor)
+    afterptrs = set(list((a.as_pointer() for a in screen.areas)))
+    newareaptr = list(afterptrs-beforeptrs)
+    newarea = area_from_ptr(newareaptr[0])
+    newarea.type = xtype
+    return newarea
+
+
+def splitV3DtoBLS(context):
+    window = context.window
+    region = context.region
+    screen = context.screen
+    main = context.area
+    
+    main.type = "INFO"
+    
+    ctrlPanel = split_area(window,screen,region,main,"VIEW_3D",direction="HORIZONTAL",factor=0.3)
+    ctrlPanel.spaces[0].lock_camera_and_layers = False
+    ctrlPanel.spaces[0].layers = [False]*19 + [True]
+    ctrlPanel.spaces[0].show_relationship_lines
+    ctrlPanel.spaces[0].viewport_shade = 'MATERIAL'
+    
+    override = {'window': window, 'screen': screen, 'area': ctrlPanel, 'region': ctrlPanel.regions[2], 'scene': context.scene}
+    if ctrlPanel.spaces[0].region_3d.is_perspective: bpy.ops.view3d.view_persportho(override)
+    bpy.ops.view3d.viewnumpad(override, type = 'TOP')
+    
+    #nodeEditor = split_area(window,screen,region,ctrlPanel,"NODE_EDITOR",direction="VERTICAL",factor=0.51)
+    
+    main.type = "VIEW_3D"
+    
+    
+    
+'''
+def test_contains(bounds,point):
+    ax,ay,bx,by = bounds
+    x,y = point
+    return (ax <= x <= bx) and (ay <= y <= by)
+def example_layout(context):
+    window = context.window
+    region = context.region
+    screen = context.screen
+    main = context.screen.areas[0]
+    main.type = "TEXT_EDITOR"
+    info = split_area(window,screen,region,main,"INFO",direction="HORIZONTAL",factor=0.99)
+    properties = split_area(window,screen,region,main,"PROPERTIES",direction="VERTICAL",factor=0.85)
+    timeline = split_area(window,screen,region,main,"TIMELINE",direction="HORIZONTAL",factor=0.1)
+    v3d = split_area(window,screen,region,main,"VIEW_3D",direction="VERTICAL",factor=0.7)
+    lightPanel = split_area(window,screen,region,v3d,"VIEW_3D",direction="HORIZONTAL",factor=0.3)
+    lightPanel.spaces[0].lock_camera_and_layers = False
+    #split2 = split_area(window,screen,region,other,"NODE_EDITOR",direction="HORIZONTAL",factor=0.6)
+    #split3 = split_area(window,screen,region,other,"IMAGE_EDITOR",direction="VERTICAL",factor=0.7)
+    #split4 = split_area(window,screen,region,other,"VIEW_3D",direction="VERTICAL",factor=0.7)
+'''

commit a9cc95ea864b3f6687bac93534fac53a07f219b8
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Fri Jan 27 10:46:04 2017 -0800

    readme.md

diff --git a/README.md b/README.md
index 56fa33b..d275814 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,92 @@
-# blender-light-studio
-Blender Light Studio has been moved to leomoon.com
+# Light Studio plugin for Blender
+## Introduction
+Introducing Light Studio plugin for Blender. Based on a prototype by Maciek Ptaszynski and inspired by HDR Light Studio 5 lighting system.
+
+[![Light Studio plugin for Blender](http://img.youtube.com/vi/I6KVYMLFR98/0.jpg)](https://www.youtube.com/watch?v=I6KVYMLFR98)
+
+## Features
+  - Add/Remove lights around objects (0,0,0)
+  - Add unlimited number of lights
+  - Each light has options like intensity, color, scale, distance, etc.
+  - Easy 2D manipulation of light which translates to 3D positioning of light
+  - Realistic HDR light textures included
+  - Each light can have different light texture
+  - Toggle lights
+  - Isolate light
+  - Lights are selectable to use render layers
+  - 3D Edit operator - interactive light placement and adjustment:
+	- Click on object to reposition light in one of two modes: reflection or normal [N].
+	- [S] Scale light mesh
+	- [G] Grab (meant to be used in rendered preview)
+	- [R] Rotate
+
+## Donations
+The speed of future development of this plugin depends on community donations. If you use this plugin, please consider donating. Any amount will help and 100% of donations will go towards development of this plugin. You can donate using "[THIS LINK](https://www.paypal.me/aminpersia)".
+
+## Funded by
+  - LeoMoon Studios
+
+## Donors
+  - NULL
+
+## Main Programmer
+  - Marcin Zielinski
+
+## Prototype and Initial Scene by
+  - Maciek Ptaszynski
+
+## Changelog
+  - 2.3.0:
+    - 3D Edit (first iteration of Light Brush)
+    - Bugfixes
+  - 2.2.1:
+    - Added Blender 2.78 support
+  - 2.1:
+    - Added the ability to delete lights like other objects
+    - Added more HDR lights
+    - Added light previews
+    - All HDR lights now have transparency
+    - GUI changes
+    - Bug fixes
+  - 2.0.1:
+    - Added Light Profiles feature
+	- Added light preview for each light
+  - 1.2.3: Solved Linux problems
+  - 1.2.2:
+    - Linux paths bugfix
+    - Control plane highlights when new light added
+  - 1.2.1: Minor bugfix
+  - 1.2.0:
+    - Protection from accidental deletion
+    - Light objects made selectable
+    - Control plane lights up when corresponding light object is selected, and vice versa
+  - 1.1.1:
+    - Added Light visibility toggles
+    - Added Light Distance option
+  - 1.1.0: 
+    - Automatically switch to cycles after clicking "Prepare Light Studio"
+  - 1.0.1: Some fixes
+  - 1.0.0: Beta release
+
+## How to install
+  - 01: Download "[Blender Light Studio](https://leomoon.com/projects/plugins/blender-light-studio/)"
+  - 02: Open Blender and go to File -> User Preferences... -> Addons
+  - 03: Click on "Install from File..." and select "blender-light-studio.zip"
+  - 04: After installation, the new plugin should show up and you can enable it
+    - If it doesn't, search for "studio" and enable the plugin
+  - 06: Close "User Preferences..."
+  - 07: Go to the new tab called "Light Studio"
+  - 08: Click on "Create Light Studio"
+  - 09: Click on "Prepare Layout"
+  - 10: Start adding lights by clicking "Add Light" and moving them around using the new split viewport
+  - 11: Use the options for the selected light and light your scene
+  - 12: Happy Blending!
+
+## Future Ideas to Implement
+  - Exporting/importing light profiles (using XML file or blend).
+  - Copy profile to scene (internal) operator
+  - Modal operator to controll position (click to place) and parameters (strength, size, etc.) of lights in 3D Viewport.
+  - Add ability to export (render) the light setup as environment texture (Equirectangular Panoramic)
+
+## Compatibility
+Tested with Blender 2.78

commit 281b919b5fcda5877996e30ca110625c77aae6e7
Author: Amin Babaeipanah <leomoon@gmail.com>
Date:   Fri Jan 27 10:41:38 2017 -0800

    Initial commit

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..56fa33b
--- /dev/null
+++ b/README.md
@@ -0,0 +1,2 @@
+# blender-light-studio
+Blender Light Studio has been moved to leomoon.com
